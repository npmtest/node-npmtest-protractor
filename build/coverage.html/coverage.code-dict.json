{"/home/travis/build/npmtest/node-npmtest-protractor/test.js":"/* istanbul instrument in package npmtest_protractor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-protractor/lib.npmtest_protractor.js":"/* istanbul instrument in package npmtest_protractor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_protractor = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_protractor = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-protractor/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-protractor && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_protractor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_protractor\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_protractor.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_protractor.rollup.js'] =\n            local.assetsDict['/assets.npmtest_protractor.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_protractor.__dirname +\n                    '/lib.npmtest_protractor.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-protractor/protractor/built/index.js":"\"use strict\";\n// Re-export selenium-webdriver types.\nvar selenium_webdriver_1 = require('selenium-webdriver');\nexports.ActionSequence = selenium_webdriver_1.ActionSequence;\nexports.Browser = selenium_webdriver_1.Browser;\nexports.Builder = selenium_webdriver_1.Builder;\nexports.Button = selenium_webdriver_1.Button;\nexports.Capabilities = selenium_webdriver_1.Capabilities;\nexports.Capability = selenium_webdriver_1.Capability;\nexports.error = selenium_webdriver_1.error;\nexports.EventEmitter = selenium_webdriver_1.EventEmitter;\nexports.FileDetector = selenium_webdriver_1.FileDetector;\nexports.Key = selenium_webdriver_1.Key;\nexports.logging = selenium_webdriver_1.logging;\nexports.promise = selenium_webdriver_1.promise;\nexports.Session = selenium_webdriver_1.Session;\nexports.until = selenium_webdriver_1.until;\nexports.WebDriver = selenium_webdriver_1.WebDriver;\nexports.WebElement = selenium_webdriver_1.WebElement;\nexports.WebElementPromise = selenium_webdriver_1.WebElementPromise;\n// Re-export public types.\nvar browser_1 = require('./browser');\nexports.ProtractorBrowser = browser_1.ProtractorBrowser;\nvar element_1 = require('./element');\nexports.ElementArrayFinder = element_1.ElementArrayFinder;\nexports.ElementFinder = element_1.ElementFinder;\nvar expectedConditions_1 = require('./expectedConditions');\nexports.ProtractorExpectedConditions = expectedConditions_1.ProtractorExpectedConditions;\nvar locators_1 = require('./locators');\nexports.ProtractorBy = locators_1.ProtractorBy;\nvar ptor_1 = require('./ptor');\nexports.Ptor = ptor_1.Ptor;\nexports.utils = {\n    firefox: require('selenium-webdriver/firefox'),\n    http: require('selenium-webdriver/http'),\n    remote: require('selenium-webdriver/remote')\n};\nexports.Command = require('selenium-webdriver/lib/command').Command;\nexports.CommandName = require('selenium-webdriver/lib/command').Name;\nObject.defineProperty(exports, 'protractor', { get: () => global['protractor'] });\nfunction registerGlobal(name) {\n    Object.defineProperty(exports, name, { get: () => exports.protractor ? exports.protractor[name] : undefined });\n}\nregisterGlobal('browser');\nregisterGlobal('$');\nregisterGlobal('$$');\nregisterGlobal('element');\nregisterGlobal('By');\nregisterGlobal('by');\nregisterGlobal('ExpectedConditions');\n//# sourceMappingURL=index.js.map","/home/travis/build/npmtest/node-npmtest-protractor/protractor/built/browser.js":"\"use strict\";\nconst blocking_proxy_1 = require('blocking-proxy');\nconst selenium_webdriver_1 = require('selenium-webdriver');\nconst url = require('url');\nconst webdriver_js_extender_1 = require('webdriver-js-extender');\nconst debugger_1 = require('./debugger');\nconst element_1 = require('./element');\nconst expectedConditions_1 = require('./expectedConditions');\nconst locators_1 = require('./locators');\nconst logger_1 = require('./logger');\nconst clientSideScripts = require('./clientsidescripts');\n// TODO: fix the typings for selenium-webdriver/lib/command\nconst Command = require('selenium-webdriver/lib/command').Command;\nconst CommandName = require('selenium-webdriver/lib/command').Name;\n// jshint browser: true\nconst DEFER_LABEL = 'NG_DEFER_BOOTSTRAP!';\nconst DEFAULT_RESET_URL = 'data:text/html,<html></html>';\nconst DEFAULT_GET_PAGE_TIMEOUT = 10000;\nlet logger = new logger_1.Logger('protractor');\n// TODO(cnishina): either remove for loop entirely since this does not export anything\n// the user might need since everything is composed (with caveat that this could be a\n// potential breaking change) or export the types with `export * from 'selenium-webdriver'`;\n/*\n * Mix in other webdriver functionality to be accessible via protractor.\n */\nfor (let foo in require('selenium-webdriver')) {\n    exports[foo] = require('selenium-webdriver')[foo];\n}\n// Explicitly define types for webdriver.WebDriver and ExtendedWebDriver.\n// We do this because we use composition over inheritance to implement polymorphism, and therefore\n// we don't want to inherit WebDriver's constructor.\nclass AbstractWebDriver {\n}\nexports.AbstractWebDriver = AbstractWebDriver;\nclass AbstractExtendedWebDriver extends AbstractWebDriver {\n}\nexports.AbstractExtendedWebDriver = AbstractExtendedWebDriver;\n/**\n * Mix a function from one object onto another. The function will still be\n * called in the context of the original object.  Any arguments of type\n * `ElementFinder` will be unwrapped to their underlying `WebElement` instance\n *\n * @private\n * @param {Object} to\n * @param {Object} from\n * @param {string} fnName\n * @param {function=} setupFn\n */\nfunction ptorMixin(to, from, fnName, setupFn) {\n    to[fnName] = function () {\n        const args = arguments;\n        for (let i = 0; i < args.length; i++) {\n            if (args[i] instanceof element_1.ElementFinder) {\n                args[i] = args[i].getWebElement();\n            }\n        }\n        const run = () => {\n            return from[fnName].apply(from, args);\n        };\n        if (setupFn) {\n            const setupResult = setupFn();\n            if (setupResult && (typeof setupResult.then === 'function')) {\n                return setupResult.then(run);\n            }\n        }\n        return run();\n    };\n}\n;\n/**\n * Build the helper 'element' function for a given instance of Browser.\n *\n * @private\n * @param {Browser} browser A browser instance.\n * @returns {function(webdriver.Locator): ElementFinder}\n */\nfunction buildElementHelper(browser) {\n    let element = ((locator) => {\n        return new element_1.ElementArrayFinder(browser).all(locator).toElementFinder_();\n    });\n    element.all = (locator) => {\n        return new element_1.ElementArrayFinder(browser).all(locator);\n    };\n    return element;\n}\n;\n/**\n * @alias browser\n * @constructor\n * @extends {webdriver_extensions.ExtendedWebDriver}\n * @param {webdriver.WebDriver} webdriver\n * @param {string=} opt_baseUrl A base URL to run get requests against.\n * @param {string|webdriver.promise.Promise<string>=} opt_rootElement  Selector element that has an\n *     ng-app in scope.\n * @param {boolean=} opt_untrackOutstandingTimeouts Whether Protractor should\n *     stop tracking outstanding $timeouts.\n */\nclass ProtractorBrowser extends AbstractExtendedWebDriver {\n    constructor(webdriverInstance, opt_baseUrl, opt_rootElement, opt_untrackOutstandingTimeouts, opt_blockingProxyUrl) {\n        super();\n        // These functions should delegate to the webdriver instance, but should\n        // wait for Angular to sync up before performing the action. This does not\n        // include functions which are overridden by protractor below.\n        let methodsToSync = ['getCurrentUrl', 'getPageSource', 'getTitle'];\n        let extendWDInstance;\n        try {\n            extendWDInstance = webdriver_js_extender_1.extend(webdriverInstance);\n        }\n        catch (e) {\n            // Probably not a driver that can be extended (e.g. gotten using\n            // `directConnect: true` in the config)\n            extendWDInstance = webdriverInstance;\n        }\n        // Mix all other driver functionality into Protractor.\n        Object.getOwnPropertyNames(selenium_webdriver_1.WebDriver.prototype).forEach(method => {\n            if (!this[method] && typeof extendWDInstance[method] === 'function') {\n                if (methodsToSync.indexOf(method) !== -1) {\n                    ptorMixin(this, extendWDInstance, method, this.waitForAngular.bind(this));\n                }\n                else {\n                    ptorMixin(this, extendWDInstance, method);\n                }\n            }\n        });\n        this.driver = extendWDInstance;\n        if (opt_blockingProxyUrl) {\n            logger.info('Starting BP client for ' + opt_blockingProxyUrl);\n            this.bpClient = new blocking_proxy_1.BPClient(opt_blockingProxyUrl);\n        }\n        this.element = buildElementHelper(this);\n        this.$ = element_1.build$(this.element, selenium_webdriver_1.By);\n        this.$$ = element_1.build$$(this.element, selenium_webdriver_1.By);\n        this.baseUrl = opt_baseUrl || '';\n        this.getPageTimeout = DEFAULT_GET_PAGE_TIMEOUT;\n        this.params = {};\n        this.resetUrl = DEFAULT_RESET_URL;\n        this.debugHelper = new debugger_1.DebugHelper(this);\n        let ng12Hybrid_ = false;\n        Object.defineProperty(this, 'ng12Hybrid', {\n            get: function () {\n                return ng12Hybrid_;\n            },\n            set: function (ng12Hybrid) {\n                if (ng12Hybrid) {\n                    logger.warn('You have set ng12Hybrid.  As of Protractor 4.1.0, ' +\n                        'Protractor can automatically infer if you are using an ' +\n                        'ngUpgrade app (as long as ng1 is loaded before you call ' +\n                        'platformBrowserDynamic()), and this flag is no longer needed ' +\n                        'for most users');\n                }\n                ng12Hybrid_ = ng12Hybrid;\n            }\n        });\n        this.ready = this.angularAppRoot(opt_rootElement || '')\n            .then(() => {\n            return this.driver.getSession();\n        })\n            .then((session) => {\n            // Internet Explorer does not accept data URLs, which are the default\n            // reset URL for Protractor.\n            // Safari accepts data urls, but SafariDriver fails after one is used.\n            // PhantomJS produces a \"Detected a page unload event\" if we use data urls\n            let browserName = session.getCapabilities().get('browserName');\n            if (browserName === 'internet explorer' || browserName === 'safari' ||\n                browserName === 'phantomjs' || browserName === 'MicrosoftEdge') {\n                this.resetUrl = 'about:blank';\n            }\n            return this;\n        });\n        this.trackOutstandingTimeouts_ = !opt_untrackOutstandingTimeouts;\n        this.mockModules_ = [];\n        this.addBaseMockModules_();\n        // set up expected conditions\n        this.ExpectedConditions = new expectedConditions_1.ProtractorExpectedConditions(this);\n    }\n    /**\n     * The css selector for an element on which to find Angular. This is usually\n     * 'body' but if your ng-app is on a subsection of the page it may be\n     * a subelement.\n     *\n     * This property is deprecated - please use angularAppRoot() instead.\n     *\n     * @deprecated\n     * @type {string}\n     */\n    set rootEl(value) {\n        this.angularAppRoot(value);\n    }\n    get rootEl() {\n        return this.internalRootEl;\n    }\n    /**\n     * Set the css selector for an element on which to find Angular. This is usually\n     * 'body' but if your ng-app is on a subsection of the page it may be\n     * a subelement.\n     *\n     * The change will be made within WebDriver's control flow, so that commands after\n     * this method is called use the new app root. Pass nothing to get a promise that\n     * resolves to the value of the selector.\n     *\n     * @param {string|webdriver.promise.Promise<string>} value The new selector.\n     * @returns A promise that resolves with the value of the selector.\n     */\n    angularAppRoot(value = null) {\n        return this.driver.controlFlow().execute(() => {\n            if (value != null) {\n                return selenium_webdriver_1.promise.when(value).then((value) => {\n                    this.internalRootEl = value;\n                    if (this.bpClient) {\n                        const bpCommandPromise = this.bpClient.setWaitParams(value);\n                        // Convert to webdriver promise as best as possible\n                        return selenium_webdriver_1.promise.when(bpCommandPromise).then(() => this.internalRootEl);\n                    }\n                    return this.internalRootEl;\n                });\n            }\n        }, `Set angular root selector to ${value}`);\n    }\n    /**\n     * If true, Protractor will not attempt to synchronize with the page before\n     * performing actions. This can be harmful because Protractor will not wait\n     * until $timeouts and $http calls have been processed, which can cause\n     * tests to become flaky. This should be used only when necessary, such as\n     * when a page continuously polls an API using $timeout.\n     *\n     * Initialized to `false` by the runner.\n     *\n     * This property is deprecated - please use waitForAngularEnabled instead.\n     *\n     * @deprecated\n     * @type {boolean}\n     */\n    set ignoreSynchronization(value) {\n        this.waitForAngularEnabled(!value);\n    }\n    get ignoreSynchronization() {\n        return this.internalIgnoreSynchronization;\n    }\n    /**\n     * If set to false, Protractor will not wait for Angular $http and $timeout\n     * tasks to complete before interacting with the browser. This can cause\n     * flaky tests, but should be used if, for instance, your app continuously\n     * polls an API with $timeout.\n     *\n     * Call waitForAngularEnabled() without passing a value to read the current\n     * state without changing it.\n     */\n    waitForAngularEnabled(enabled = null) {\n        if (enabled != null) {\n            const ret = this.driver.controlFlow().execute(() => {\n                return selenium_webdriver_1.promise.when(enabled).then((enabled) => {\n                    if (this.bpClient) {\n                        logger.debug('Setting waitForAngular' + !enabled);\n                        const bpCommandPromise = this.bpClient.setWaitEnabled(enabled);\n                        // Convert to webdriver promise as best as possible\n                        return selenium_webdriver_1.promise.when(bpCommandPromise).then(() => enabled);\n                    }\n                });\n            }, `Set proxy synchronization enabled to ${enabled}`);\n            this.internalIgnoreSynchronization = !enabled;\n            return ret;\n        }\n        return selenium_webdriver_1.promise.when(!this.ignoreSynchronization);\n    }\n    /**\n     * Get the processed configuration object that is currently being run. This\n     * will contain the specs and capabilities properties of the current runner\n     * instance.\n     *\n     * Set by the runner.\n     *\n     * @returns {webdriver.promise.Promise} A promise which resolves to the\n     * capabilities object.\n     */\n    getProcessedConfig() {\n        return null;\n    }\n    /**\n     * Fork another instance of browser for use in interactive tests.\n     *\n     * @example\n     * // Running with control flow enabled\n     * var fork = browser.forkNewDriverInstance();\n     * fork.get('page1'); // 'page1' gotten by forked browser\n     *\n     * // Running with control flow disabled\n     * var forked = await browser.forkNewDriverInstance().ready;\n     * await forked.get('page1'); // 'page1' gotten by forked browser\n     *\n     * @param {boolean=} useSameUrl Whether to navigate to current url on creation\n     * @param {boolean=} copyMockModules Whether to apply same mock modules on creation\n     * @param {boolean=} copyConfigUpdates Whether to copy over changes to `baseUrl` and similar\n     *   properties initialized to values in the the config.  Defaults to `true`\n     *\n     * @returns {ProtractorBrowser} A browser instance.\n     */\n    forkNewDriverInstance(useSameUrl, copyMockModules, copyConfigUpdates = true) {\n        return null;\n    }\n    /**\n     * Restart the browser.  This is done by closing this browser instance and creating a new one.\n     * A promise resolving to the new instance is returned, and if this function was called on the\n     * global `browser` instance then Protractor will automatically overwrite the global `browser`\n     * variable.\n     *\n     * When restarting a forked browser, it is the caller's job to overwrite references to the old\n     * instance.\n     *\n     * This function behaves slightly differently depending on if the webdriver control flow is\n     * enabled.  If the control flow is enabled, the global `browser` object is synchronously\n     * replaced. If the control flow is disabled, the global `browser` is replaced asynchronously\n     * after the old driver quits.\n     *\n     * Set by the runner.\n     *\n     * @example\n     * // Running against global browser, with control flow enabled\n     * browser.get('page1');\n     * browser.restart();\n     * browser.get('page2'); // 'page2' gotten by restarted browser\n     *\n     * // Running against global browser, with control flow disabled\n     * await browser.get('page1');\n     * await browser.restart();\n     * await browser.get('page2'); // 'page2' gotten by restarted browser\n     *\n     * // Running against forked browsers, with the control flow enabled\n     * // In this case, you may prefer `restartSync` (documented below)\n     * var forked = browser.forkNewDriverInstance();\n     * fork.get('page1');\n     * fork.restart().then(function(fork) {\n     *   fork.get('page2'); // 'page2' gotten by restarted fork\n     * });\n     *\n     * // Running against forked browsers, with the control flow disabled\n     * var forked = await browser.forkNewDriverInstance().ready;\n     * await fork.get('page1');\n     * fork = await fork.restart();\n     * await fork.get('page2'); // 'page2' gotten by restarted fork\n     *\n     * // Unexpected behavior can occur if you save references to the global `browser`\n     * var savedBrowser = browser;\n     * browser.get('foo').then(function() {\n     *   console.log(browser === savedBrowser); // false\n     * });\n     * browser.restart();\n     *\n     * @returns {webdriver.promise.Promise<ProtractorBrowser>} A promise resolving to the restarted\n     *   browser\n     */\n    restart() {\n        return;\n    }\n    /**\n     * Like `restart`, but instead of returning a promise resolving to the new browser instance,\n     * returns the new browser instance directly.  Can only be used when the control flow is enabled.\n     *\n     * @example\n     * // Running against global browser\n     * browser.get('page1');\n     * browser.restartSync();\n     * browser.get('page2'); // 'page2' gotten by restarted browser\n     *\n     * // Running against forked browsers\n     * var forked = browser.forkNewDriverInstance();\n     * fork.get('page1');\n     * fork = fork.restartSync();\n     * fork.get('page2'); // 'page2' gotten by restarted fork\n     *\n     * @throws {TypeError} Will throw an error if the control flow is not enabled\n     * @returns {ProtractorBrowser} The restarted browser\n     */\n    restartSync() {\n        return;\n    }\n    /**\n     * Instead of using a single root element, search through all angular apps\n     * available on the page when finding elements or waiting for stability.\n     * Only compatible with Angular2.\n     */\n    useAllAngular2AppRoots() {\n        // The empty string is an invalid css selector, so we use it to easily\n        // signal to scripts to not find a root element.\n        this.angularAppRoot('');\n    }\n    /**\n     * The same as {@code webdriver.WebDriver.prototype.executeScript},\n     * but with a customized description for debugging.\n     *\n     * @private\n     * @param {!(string|Function)} script The script to execute.\n     * @param {string} description A description of the command for debugging.\n     * @param {...*} var_args The arguments to pass to the script.\n     * @returns {!webdriver.promise.Promise.<T>} A promise that will resolve to\n     * the scripts return value.\n     * @template T\n     */\n    executeScriptWithDescription(script, description, ...scriptArgs) {\n        if (typeof script === 'function') {\n            script = 'return (' + script + ').apply(null, arguments);';\n        }\n        return this.driver.schedule(new Command(CommandName.EXECUTE_SCRIPT)\n            .setParameter('script', script)\n            .setParameter('args', scriptArgs), description);\n    }\n    /**\n     * The same as {@code webdriver.WebDriver.prototype.executeAsyncScript},\n     * but with a customized description for debugging.\n     *\n     * @private\n     * @param {!(string|Function)} script The script to execute.\n     * @param {string} description A description for debugging purposes.\n     * @param {...*} var_args The arguments to pass to the script.\n     * @returns {!webdriver.promise.Promise.<T>} A promise that will resolve to\n     * the\n     *    scripts return value.\n     * @template T\n     */\n    executeAsyncScript_(script, description, ...scriptArgs) {\n        if (typeof script === 'function') {\n            script = 'return (' + script + ').apply(null, arguments);';\n        }\n        return this.driver.schedule(new Command(CommandName.EXECUTE_ASYNC_SCRIPT)\n            .setParameter('script', script)\n            .setParameter('args', scriptArgs), description);\n    }\n    /**\n     * Instruct webdriver to wait until Angular has finished rendering and has\n     * no outstanding $http or $timeout calls before continuing.\n     * Note that Protractor automatically applies this command before every\n     * WebDriver action.\n     *\n     * @param {string=} opt_description An optional description to be added\n     *     to webdriver logs.\n     * @returns {!webdriver.promise.Promise} A promise that will resolve to the\n     *    scripts return value.\n     */\n    waitForAngular(opt_description) {\n        let description = opt_description ? ' - ' + opt_description : '';\n        if (this.ignoreSynchronization) {\n            return this.driver.controlFlow().execute(() => {\n                return true;\n            }, 'Ignore Synchronization Protractor.waitForAngular()');\n        }\n        let runWaitForAngularScript = () => {\n            if (this.plugins_.skipAngularStability() || this.bpClient) {\n                return this.driver.controlFlow().execute(() => {\n                    return selenium_webdriver_1.promise.when(null);\n                }, 'bpClient or plugin stability override');\n            }\n            else {\n                // Need to wrap this so that we read rootEl in the control flow, not synchronously.\n                return this.angularAppRoot().then((rootEl) => {\n                    return this.executeAsyncScript_(clientSideScripts.waitForAngular, 'Protractor.waitForAngular()' + description, rootEl);\n                });\n            }\n        };\n        return runWaitForAngularScript()\n            .then((browserErr) => {\n            if (browserErr) {\n                throw new Error('Error while waiting for Protractor to ' +\n                    'sync with the page: ' + JSON.stringify(browserErr));\n            }\n        })\n            .then(() => {\n            return this.driver.controlFlow()\n                .execute(() => {\n                return this.plugins_.waitForPromise(this);\n            }, 'Plugins.waitForPromise()')\n                .then(() => {\n                return this.driver.wait(() => {\n                    return this.plugins_.waitForCondition(this).then((results) => {\n                        return results.reduce((x, y) => x && y, true);\n                    });\n                }, this.allScriptsTimeout, 'Plugins.waitForCondition()');\n            });\n        }, (err) => {\n            let timeout;\n            if (/asynchronous script timeout/.test(err.message)) {\n                // Timeout on Chrome\n                timeout = /-?[\\d\\.]*\\ seconds/.exec(err.message);\n            }\n            else if (/Timed out waiting for async script/.test(err.message)) {\n                // Timeout on Firefox\n                timeout = /-?[\\d\\.]*ms/.exec(err.message);\n            }\n            else if (/Timed out waiting for an asynchronous script/.test(err.message)) {\n                // Timeout on Safari\n                timeout = /-?[\\d\\.]*\\ ms/.exec(err.message);\n            }\n            if (timeout) {\n                let errMsg = `Timed out waiting for asynchronous Angular tasks to finish after ` +\n                    `${timeout}. This may be because the current page is not an Angular ` +\n                    `application. Please see the FAQ for more details: ` +\n                    `https://github.com/angular/protractor/blob/master/docs/timeouts.md#waiting-for-angular`;\n                if (description.indexOf(' - Locator: ') == 0) {\n                    errMsg += '\\nWhile waiting for element with locator' + description;\n                }\n                let pendingTimeoutsPromise;\n                if (this.trackOutstandingTimeouts_) {\n                    pendingTimeoutsPromise = this.executeScriptWithDescription('return window.NG_PENDING_TIMEOUTS', 'Protractor.waitForAngular() - getting pending timeouts' + description);\n                }\n                else {\n                    pendingTimeoutsPromise = selenium_webdriver_1.promise.when({});\n                }\n                let pendingHttpsPromise = this.executeScriptWithDescription(clientSideScripts.getPendingHttpRequests, 'Protractor.waitForAngular() - getting pending https' + description, this.internalRootEl);\n                return selenium_webdriver_1.promise.all([pendingTimeoutsPromise, pendingHttpsPromise])\n                    .then((arr) => {\n                    let pendingTimeouts = arr[0] || [];\n                    let pendingHttps = arr[1] || [];\n                    let key, pendingTasks = [];\n                    for (key in pendingTimeouts) {\n                        if (pendingTimeouts.hasOwnProperty(key)) {\n                            pendingTasks.push(' - $timeout: ' + pendingTimeouts[key]);\n                        }\n                    }\n                    for (key in pendingHttps) {\n                        pendingTasks.push(' - $http: ' + pendingHttps[key].url);\n                    }\n                    if (pendingTasks.length) {\n                        errMsg += '. \\nThe following tasks were pending:\\n';\n                        errMsg += pendingTasks.join('\\n');\n                    }\n                    err.message = errMsg;\n                    throw err;\n                }, () => {\n                    err.message = errMsg;\n                    throw err;\n                });\n            }\n            else {\n                throw err;\n            }\n        });\n    }\n    /**\n     * Waits for Angular to finish rendering before searching for elements.\n     * @see webdriver.WebDriver.findElement\n     * @returns {!webdriver.WebElementPromise} A promise that will be resolved to\n     *      the located {@link webdriver.WebElement}.\n     */\n    findElement(locator) {\n        return this.element(locator).getWebElement();\n    }\n    /**\n     * Waits for Angular to finish rendering before searching for elements.\n     * @see webdriver.WebDriver.findElements\n     * @returns {!webdriver.promise.Promise} A promise that will be resolved to an\n     *     array of the located {@link webdriver.WebElement}s.\n     */\n    findElements(locator) {\n        return this.element.all(locator).getWebElements();\n    }\n    /**\n     * Tests if an element is present on the page.\n     * @see webdriver.WebDriver.isElementPresent\n     * @returns {!webdriver.promise.Promise} A promise that will resolve to whether\n     *     the element is present on the page.\n     */\n    isElementPresent(locatorOrElement) {\n        let element;\n        if (locatorOrElement instanceof element_1.ElementFinder) {\n            element = locatorOrElement;\n        }\n        else if (locatorOrElement instanceof selenium_webdriver_1.WebElement) {\n            element = element_1.ElementFinder.fromWebElement_(this, locatorOrElement);\n        }\n        else {\n            element = this.element(locatorOrElement);\n        }\n        return element.isPresent();\n    }\n    /**\n     * Add a module to load before Angular whenever Protractor.get is called.\n     * Modules will be registered after existing modules already on the page,\n     * so any module registered here will override preexisting modules with the\n     * same name.\n     *\n     * @example\n     * browser.addMockModule('modName', function() {\n     *   angular.module('modName', []).value('foo', 'bar');\n     * });\n     *\n     * @param {!string} name The name of the module to load or override.\n     * @param {!string|Function} script The JavaScript to load the module.\n     *     Note that this will be executed in the browser context, so it cannot\n     *     access variables from outside its scope.\n     * @param {...*} varArgs Any additional arguments will be provided to\n     *     the script and may be referenced using the `arguments` object.\n     */\n    addMockModule(name, script, ...moduleArgs) {\n        this.mockModules_.push({ name: name, script: script, args: moduleArgs });\n    }\n    /**\n     * Clear the list of registered mock modules.\n     */\n    clearMockModules() {\n        this.mockModules_ = [];\n        this.addBaseMockModules_();\n    }\n    /**\n     * Remove a registered mock module.\n     *\n     * @example\n     * browser.removeMockModule('modName');\n     *\n     * @param {!string} name The name of the module to remove.\n     */\n    removeMockModule(name) {\n        for (let i = 0; i < this.mockModules_.length; ++i) {\n            if (this.mockModules_[i].name == name) {\n                this.mockModules_.splice(i--, 1);\n            }\n        }\n    }\n    /**\n     * Get a list of the current mock modules.\n     *\n     * @returns {Array.<!string|Function>} The list of mock modules.\n     */\n    getRegisteredMockModules() {\n        return this.mockModules_.map(module => module.script);\n    }\n    ;\n    /**\n     * Add the base mock modules used for all Protractor tests.\n     *\n     * @private\n     */\n    addBaseMockModules_() {\n        this.addMockModule('protractorBaseModule_', clientSideScripts.protractorBaseModuleFn, this.trackOutstandingTimeouts_);\n    }\n    /**\n     * @see webdriver.WebDriver.get\n     *\n     * Navigate to the given destination and loads mock modules before\n     * Angular. Assumes that the page being loaded uses Angular.\n     * If you need to access a page which does not have Angular on load, use\n     * the wrapped webdriver directly.\n     *\n     * @example\n     * browser.get('https://angularjs.org/');\n     * expect(browser.getCurrentUrl()).toBe('https://angularjs.org/');\n     *\n     * @param {string} destination Destination URL.\n     * @param {number=} opt_timeout Number of milliseconds to wait for Angular to\n     *     start.\n     */\n    get(destination, timeout = this.getPageTimeout) {\n        destination = this.baseUrl.indexOf('file://') === 0 ? this.baseUrl + destination :\n            url.resolve(this.baseUrl, destination);\n        if (this.ignoreSynchronization) {\n            return this.driver.get(destination)\n                .then(() => this.driver.controlFlow().execute(() => this.plugins_.onPageLoad(this)))\n                .then(() => null);\n        }\n        let msg = (str) => {\n            return 'Protractor.get(' + destination + ') - ' + str;\n        };\n        return this.driver.controlFlow()\n            .execute(() => {\n            return selenium_webdriver_1.promise.when(null);\n        })\n            .then(() => {\n            if (this.bpClient) {\n                return this.driver.controlFlow().execute(() => {\n                    return this.bpClient.setWaitEnabled(false);\n                });\n            }\n        })\n            .then(() => {\n            // Go to reset url\n            return this.driver.get(this.resetUrl);\n        })\n            .then(() => {\n            // Set defer label and navigate\n            return this.executeScriptWithDescription('window.name = \"' + DEFER_LABEL + '\" + window.name;' +\n                'window.location.replace(\"' + destination + '\");', msg('reset url'));\n        })\n            .then(() => {\n            // We need to make sure the new url has loaded before\n            // we try to execute any asynchronous scripts.\n            return this.driver.wait(() => {\n                return this.executeScriptWithDescription('return window.location.href;', msg('get url'))\n                    .then((url) => {\n                    return url !== this.resetUrl;\n                }, (err) => {\n                    if (err.code == 13) {\n                        // Ignore the error, and continue trying. This is\n                        // because IE driver sometimes (~1%) will throw an\n                        // unknown error from this execution. See\n                        // https://github.com/angular/protractor/issues/841\n                        // This shouldn't mask errors because it will fail\n                        // with the timeout anyway.\n                        return false;\n                    }\n                    else {\n                        throw err;\n                    }\n                });\n            }, timeout, 'waiting for page to load for ' + timeout + 'ms');\n        })\n            .then(() => {\n            // Run Plugins\n            return this.driver.controlFlow().execute(() => {\n                return this.plugins_.onPageLoad(this);\n            });\n        })\n            .then(() => {\n            // Make sure the page is an Angular page.\n            return this\n                .executeAsyncScript_(clientSideScripts.testForAngular, msg('test for angular'), Math.floor(timeout / 1000), this.ng12Hybrid)\n                .then((angularTestResult) => {\n                let angularVersion = angularTestResult.ver;\n                if (!angularVersion) {\n                    let message = angularTestResult.message;\n                    logger.error(`Could not find Angular on page ${destination} : ${message}`);\n                    throw new Error(`Angular could not be found on the page ${destination}.` +\n                        `If this is not an Angular application, you may need to turn off waiting for Angular.\n                          Please see \n                          https://github.com/angular/protractor/blob/master/docs/timeouts.md#waiting-for-angular-on-page-load`);\n                }\n                return angularVersion;\n            }, (err) => {\n                throw new Error('Error while running testForAngular: ' + err.message);\n            });\n        })\n            .then((angularVersion) => {\n            // Load Angular Mocks\n            if (angularVersion === 1) {\n                // At this point, Angular will pause for us until angular.resumeBootstrap is called.\n                let moduleNames = [];\n                let modulePromise = selenium_webdriver_1.promise.when(null);\n                for (const { name, script, args } of this.mockModules_) {\n                    moduleNames.push(name);\n                    let executeScriptArgs = [script, msg('add mock module ' + name), ...args];\n                    modulePromise = modulePromise.then(() => this.executeScriptWithDescription.apply(this, executeScriptArgs)\n                        .then(null, (err) => {\n                        throw new Error('Error while running module script ' + name + ': ' + err.message);\n                    }));\n                }\n                return modulePromise.then(() => this.executeScriptWithDescription('window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__ = ' +\n                    'angular.resumeBootstrap(arguments[0]);', msg('resume bootstrap'), moduleNames));\n            }\n            else {\n                // TODO: support mock modules in Angular2. For now, error if someone\n                // has tried to use one.\n                if (this.mockModules_.length > 1) {\n                    throw 'Trying to load mock modules on an Angular v2+ app is not yet supported.';\n                }\n            }\n        })\n            .then(() => {\n            // Reset bpClient sync\n            if (this.bpClient) {\n                return this.driver.controlFlow().execute(() => {\n                    return this.bpClient.setWaitEnabled(!this.internalIgnoreSynchronization);\n                });\n            }\n        })\n            .then(() => {\n            // Run Plugins\n            return this.driver.controlFlow().execute(() => {\n                return this.plugins_.onPageStable(this);\n            });\n        })\n            .then(() => null);\n    }\n    /**\n     * @see webdriver.WebDriver.refresh\n     *\n     * Makes a full reload of the current page and loads mock modules before\n     * Angular. Assumes that the page being loaded uses Angular.\n     * If you need to access a page which does not have Angular on load, use\n     * the wrapped webdriver directly.\n     *\n     * @param {number=} opt_timeout Number of milliseconds to wait for Angular to start.\n     */\n    refresh(opt_timeout) {\n        if (this.ignoreSynchronization) {\n            return this.driver.navigate().refresh();\n        }\n        return this\n            .executeScriptWithDescription('return window.location.href', 'Protractor.refresh() - getUrl')\n            .then((href) => {\n            return this.get(href, opt_timeout);\n        });\n    }\n    /**\n     * Mixin navigation methods back into the navigation object so that\n     * they are invoked as before, i.e. driver.navigate().refresh()\n     */\n    navigate() {\n        let nav = this.driver.navigate();\n        ptorMixin(nav, this, 'refresh');\n        return nav;\n    }\n    /**\n     * Browse to another page using in-page navigation.\n     *\n     * @example\n     * browser.get('http://angular.github.io/protractor/#/tutorial');\n     * browser.setLocation('api');\n     * expect(browser.getCurrentUrl())\n     *     .toBe('http://angular.github.io/protractor/#/api');\n     *\n     * @param {string} url In page URL using the same syntax as $location.url()\n     * @returns {!webdriver.promise.Promise} A promise that will resolve once\n     *    page has been changed.\n     */\n    setLocation(url) {\n        return this.waitForAngular()\n            .then(() => this.angularAppRoot())\n            .then((rootEl) => this.executeScriptWithDescription(clientSideScripts.setLocation, 'Protractor.setLocation()', rootEl, url)\n            .then((browserErr) => {\n            if (browserErr) {\n                throw 'Error while navigating to \\'' + url + '\\' : ' +\n                    JSON.stringify(browserErr);\n            }\n        }));\n    }\n    /**\n     * Deprecated, use `browser.getCurrentUrl()` instead.\n     *\n     * Despite its name, this function will generally return `$location.url()`, though in some\n     * cases it will return `$location.absUrl()` instead.  This function is only here for legacy\n     * users, and will probably be removed in Protractor 6.0.\n     *\n     * @deprecated Please use `browser.getCurrentUrl()`\n     * @example\n     * browser.get('http://angular.github.io/protractor/#/api');\n     * expect(browser.getLocationAbsUrl())\n     *     .toBe('http://angular.github.io/protractor/#/api');\n     * @returns {webdriver.promise.Promise<string>} The current absolute url from\n     * AngularJS.\n     */\n    getLocationAbsUrl() {\n        logger.warn('`browser.getLocationAbsUrl()` is deprecated, please use `browser.getCurrentUrl` instead.');\n        return this.waitForAngular()\n            .then(() => this.angularAppRoot())\n            .then((rootEl) => this.executeScriptWithDescription(clientSideScripts.getLocationAbsUrl, 'Protractor.getLocationAbsUrl()', rootEl));\n    }\n    /**\n     * Adds a task to the control flow to pause the test and inject helper\n     * functions\n     * into the browser, so that debugging may be done in the browser console.\n     *\n     * This should be used under node in debug mode, i.e. with\n     * protractor debug <configuration.js>\n     *\n     * @example\n     * While in the debugger, commands can be scheduled through webdriver by\n     * entering the repl:\n     *   debug> repl\n     *   > element(by.input('user')).sendKeys('Laura');\n     *   > browser.debugger();\n     *   Press Ctrl + c to leave debug repl\n     *   debug> c\n     *\n     * This will run the sendKeys command as the next task, then re-enter the\n     * debugger.\n     */\n    debugger() {\n        // jshint debug: true\n        return this.driver.executeScript(clientSideScripts.installInBrowser)\n            .then(() => selenium_webdriver_1.promise.controlFlow().execute(() => {\n            debugger;\n        }, 'add breakpoint to control flow'));\n    }\n    /**\n     * See browser.explore().\n     */\n    enterRepl(opt_debugPort) {\n        return this.explore(opt_debugPort);\n    }\n    /**\n     * Beta (unstable) explore function for entering the repl loop from\n     * any point in the control flow. Use browser.explore() in your test.\n     * Does not require changes to the command line (no need to add 'debug').\n     * Note, if you are wrapping your own instance of Protractor, you must\n     * expose globals 'browser' and 'protractor' for pause to work.\n     *\n     * @example\n     * element(by.id('foo')).click();\n     * browser.explore();\n     * // Execution will stop before the next click action.\n     * element(by.id('bar')).click();\n     *\n     * @param {number=} opt_debugPort Optional port to use for the debugging\n     * process\n     */\n    explore(opt_debugPort) {\n        let debuggerClientPath = __dirname + '/debugger/clients/explorer.js';\n        let onStartFn = (firstTime) => {\n            logger.info();\n            if (firstTime) {\n                logger.info('------- Element Explorer -------');\n                logger.info('Starting WebDriver debugger in a child process. Element ' +\n                    'Explorer is still beta, please report issues at ' +\n                    'github.com/angular/protractor');\n                logger.info();\n                logger.info('Type <tab> to see a list of locator strategies.');\n                logger.info('Use the `list` helper function to find elements by strategy:');\n                logger.info('  e.g., list(by.binding(\\'\\')) gets all bindings.');\n                logger.info();\n            }\n        };\n        this.debugHelper.initBlocking(debuggerClientPath, onStartFn, opt_debugPort);\n    }\n    /**\n     * Beta (unstable) pause function for debugging webdriver tests. Use\n     * browser.pause() in your test to enter the protractor debugger from that\n     * point in the control flow.\n     * Does not require changes to the command line (no need to add 'debug').\n     * Note, if you are wrapping your own instance of Protractor, you must\n     * expose globals 'browser' and 'protractor' for pause to work.\n     *\n     * @example\n     * element(by.id('foo')).click();\n     * browser.pause();\n     * // Execution will stop before the next click action.\n     * element(by.id('bar')).click();\n     *\n     * @param {number=} opt_debugPort Optional port to use for the debugging\n     * process\n     */\n    pause(opt_debugPort) {\n        if (this.debugHelper.isAttached()) {\n            logger.info('Encountered browser.pause(), but debugger already attached.');\n            return selenium_webdriver_1.promise.when(true);\n        }\n        let debuggerClientPath = __dirname + '/debugger/clients/wddebugger.js';\n        let onStartFn = (firstTime) => {\n            logger.info();\n            logger.info('Encountered browser.pause(). Attaching debugger...');\n            if (firstTime) {\n                logger.info();\n                logger.info('------- WebDriver Debugger -------');\n                logger.info('Starting WebDriver debugger in a child process. Pause is ' +\n                    'still beta, please report issues at github.com/angular/protractor');\n                logger.info();\n                logger.info('press c to continue to the next webdriver command');\n                logger.info('press ^D to detach debugger and resume code execution');\n                logger.info();\n            }\n        };\n        this.debugHelper.init(debuggerClientPath, onStartFn, opt_debugPort);\n    }\n    /**\n     * Determine if the control flow is enabled.\n     *\n     * @returns true if the control flow is enabled, false otherwise.\n     */\n    controlFlowIsEnabled() {\n        if (selenium_webdriver_1.promise.USE_PROMISE_MANAGER !== undefined) {\n            return selenium_webdriver_1.promise.USE_PROMISE_MANAGER;\n        }\n        else {\n            // True for old versions of `selenium-webdriver`, probably false in >=5.0.0\n            return !!selenium_webdriver_1.promise.ControlFlow;\n        }\n    }\n}\n/**\n * @type {ProtractorBy}\n */\nProtractorBrowser.By = new locators_1.ProtractorBy();\nexports.ProtractorBrowser = ProtractorBrowser;\n//# sourceMappingURL=browser.js.map","/home/travis/build/npmtest/node-npmtest-protractor/protractor/built/debugger.js":"\"use strict\";\nconst net = require('net');\nconst selenium_webdriver_1 = require('selenium-webdriver');\nconst util = require('util');\nconst logger_1 = require('./logger');\nlet breakpointHook = require('./breakpointhook.js');\nlet logger = new logger_1.Logger('protractor');\nclass DebugHelper {\n    constructor(browserUnderDebug_) {\n        this.browserUnderDebug_ = browserUnderDebug_;\n    }\n    initBlocking(debuggerClientPath, onStartFn, opt_debugPort) {\n        this.init_(debuggerClientPath, true, onStartFn, opt_debugPort);\n    }\n    init(debuggerClientPath, onStartFn, opt_debugPort) {\n        this.init_(debuggerClientPath, false, onStartFn, opt_debugPort);\n    }\n    /**\n     *  1) Set up helper functions for debugger clients to call on (e.g.\n     *     execute code, get autocompletion).\n     *  2) Enter process into debugger mode. (i.e. process._debugProcess).\n     *  3) Invoke the debugger client specified by debuggerClientPath.\n     *\n     * @param {string} debuggerClientPath Absolute path of debugger client to use.\n     * @param {boolean} blockUntilExit Whether to block the flow until process exit or resume\n     *     immediately.\n     * @param {Function} onStartFn Function to call when the debugger starts. The\n     *     function takes a single parameter, which represents whether this is the\n     *     first time that the debugger is called.\n     * @param {number=} opt_debugPort Optional port to use for the debugging\n     *     process.\n     *\n     * @return {Promise} If blockUntilExit, a promise resolved when the debugger process\n     *     exits. Otherwise, resolved when the debugger process is ready to begin.\n     */\n    init_(debuggerClientPath, blockUntilExit, onStartFn, opt_debugPort) {\n        const vm_ = require('vm');\n        let flow = selenium_webdriver_1.promise.controlFlow();\n        let context = { require: require };\n        global.list = (locator) => {\n            return global.protractor.browser.findElements(locator).then((arr) => {\n                let found = [];\n                for (let i = 0; i < arr.length; ++i) {\n                    arr[i].getText().then((text) => {\n                        found.push(text);\n                    });\n                }\n                return found;\n            });\n        };\n        for (let key in global) {\n            context[key] = global[key];\n        }\n        let sandbox = vm_.createContext(context);\n        let debuggingDone = selenium_webdriver_1.promise.defer();\n        // We run one flow.execute block for the debugging session. All\n        // subcommands should be scheduled under this task.\n        let executePromise = flow.execute(() => {\n            process['debugPort'] = opt_debugPort || process['debugPort'];\n            this.validatePortAvailability_(process['debugPort']).then((firstTime) => {\n                onStartFn(firstTime);\n                let args = [process.pid, process['debugPort']];\n                if (this.browserUnderDebug_.debuggerServerPort) {\n                    args.push(this.browserUnderDebug_.debuggerServerPort);\n                }\n                let nodedebug = require('child_process').fork(debuggerClientPath, args);\n                process.on('exit', function () {\n                    nodedebug.kill('SIGTERM');\n                });\n                nodedebug\n                    .on('message', (m) => {\n                    if (m === 'ready') {\n                        breakpointHook();\n                        if (!blockUntilExit) {\n                            debuggingDone.fulfill();\n                        }\n                    }\n                })\n                    .on('exit', () => {\n                    // Clear this so that we know it's ok to attach a debugger\n                    // again.\n                    this.dbgCodeExecutor = null;\n                    debuggingDone.fulfill();\n                });\n            });\n            return debuggingDone.promise;\n        }, 'debugging tasks');\n        // Helper used only by debuggers at './debugger/modes/*.js' to insert code\n        // into the control flow, via debugger 'evaluate' protocol.\n        // In order to achieve this, we maintain a task at the top of the control\n        // flow, so that we can insert frames into it.\n        // To be able to simulate callback/asynchronous code, we poll this object\n        // whenever `breakpointHook` is called.\n        this.dbgCodeExecutor = {\n            execPromise_: undefined,\n            execPromiseResult_: undefined,\n            execPromiseError_: undefined,\n            // A dummy repl server to make use of its completion function.\n            replServer_: require('repl').start({\n                input: { on: function () { }, resume: function () { } },\n                // dummy readable stream\n                output: { write: function () { } },\n                useGlobal: true\n            }),\n            // Execute a function, which could yield a value or a promise,\n            // and allow its result to be accessed synchronously\n            execute_: function (execFn_) {\n                this.execPromiseResult_ = this.execPromiseError_ = undefined;\n                this.execPromise_ = execFn_();\n                // Note: This needs to be added after setting execPromise to execFn,\n                // or else we cause this.execPromise_ to get stuck in pending mode\n                // at our next breakpoint.\n                this.execPromise_.then((result) => {\n                    this.execPromiseResult_ = result;\n                    breakpointHook();\n                }, (err) => {\n                    this.execPromiseError_ = err;\n                    breakpointHook();\n                });\n            },\n            // Execute a piece of code.\n            // Result is a string representation of the evaluation.\n            execute: function (code) {\n                let execFn_ = () => {\n                    // Run code through vm so that we can maintain a local scope which is\n                    // isolated from the rest of the execution.\n                    let res;\n                    try {\n                        res = vm_.runInContext(code, sandbox);\n                    }\n                    catch (e) {\n                        res = selenium_webdriver_1.promise.when('Error while evaluating command: ' + e);\n                    }\n                    if (!selenium_webdriver_1.promise.isPromise(res)) {\n                        res = selenium_webdriver_1.promise.when(res);\n                    }\n                    return res.then((res) => {\n                        if (res === undefined) {\n                            return undefined;\n                        }\n                        else {\n                            // The '' forces res to be expanded into a string instead of just\n                            // '[Object]'. Then we remove the extra space caused by the ''\n                            // using substring.\n                            return util.format.apply(this, ['', res]).substring(1);\n                        }\n                    });\n                };\n                this.execute_(execFn_);\n            },\n            // Autocomplete for a line.\n            // Result is a JSON representation of the autocomplete response.\n            complete: function (line) {\n                let execFn_ = () => {\n                    let deferred = selenium_webdriver_1.promise.defer();\n                    this.replServer_.complete(line, (err, res) => {\n                        if (err) {\n                            deferred.reject(err);\n                        }\n                        else {\n                            deferred.fulfill(JSON.stringify(res));\n                        }\n                    });\n                    return deferred.promise;\n                };\n                this.execute_(execFn_);\n            },\n            // Code finished executing.\n            resultReady: function () {\n                return !(this.execPromise_.state_ === 'pending');\n            },\n            // Get asynchronous results synchronously.\n            // This will throw if result is not ready.\n            getResult: function () {\n                if (!this.resultReady()) {\n                    throw new Error('Result not ready');\n                }\n                if (this.execPromiseError_) {\n                    throw this.execPromiseError_;\n                }\n                return this.execPromiseResult_;\n            }\n        };\n        return executePromise;\n    }\n    /**\n     * Validates that the port is free to use. This will only validate the first\n     * time it is called. The reason is that on subsequent calls, the port will\n     * already be bound to the debugger, so it will not be available, but that is\n     * okay.\n     *\n     * @returns {Promise<boolean>} A promise that becomes ready when the\n     * validation\n     *     is done. The promise will resolve to a boolean which represents whether\n     *     this is the first time that the debugger is called.\n     */\n    validatePortAvailability_(port) {\n        if (this.debuggerValidated_) {\n            return selenium_webdriver_1.promise.when(false);\n        }\n        let doneDeferred = selenium_webdriver_1.promise.defer();\n        // Resolve doneDeferred if port is available.\n        let tester = net.connect({ port: port }, () => {\n            doneDeferred.reject('Port ' + port + ' is already in use. Please specify ' +\n                'another port to debug.');\n        });\n        tester.once('error', (err) => {\n            if (err.code === 'ECONNREFUSED') {\n                tester\n                    .once('close', () => {\n                    doneDeferred.fulfill(true);\n                })\n                    .end();\n            }\n            else {\n                doneDeferred.reject('Unexpected failure testing for port ' + port + ': ' + JSON.stringify(err));\n            }\n        });\n        return doneDeferred.promise.then((firstTime) => {\n            this.debuggerValidated_ = true;\n            return firstTime;\n        }, (err) => {\n            console.error(err);\n            process.exit(1);\n        });\n    }\n    isAttached() {\n        return !!this.dbgCodeExecutor;\n    }\n}\nexports.DebugHelper = DebugHelper;\n//# sourceMappingURL=debugger.js.map","/home/travis/build/npmtest/node-npmtest-protractor/protractor/built/logger.js":"\"use strict\";\nconst fs = require('fs');\nconst path = require('path');\n// Will use chalk if chalk is available to add color to console logging\nlet chalk;\nlet printRed;\nlet printYellow;\nlet printGray;\ntry {\n    chalk = require('chalk');\n    printRed = chalk.red;\n    printYellow = chalk.yellow;\n    printGray = chalk.gray;\n}\ncatch (e) {\n    printRed = printYellow = printGray = (msg) => {\n        return msg;\n    };\n}\n(function (LogLevel) {\n    LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n    LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"DEBUG\"] = 3] = \"DEBUG\";\n})(exports.LogLevel || (exports.LogLevel = {}));\nvar LogLevel = exports.LogLevel;\n(function (WriteTo) {\n    WriteTo[WriteTo[\"CONSOLE\"] = 0] = \"CONSOLE\";\n    WriteTo[WriteTo[\"FILE\"] = 1] = \"FILE\";\n    WriteTo[WriteTo[\"BOTH\"] = 2] = \"BOTH\";\n    WriteTo[WriteTo[\"NONE\"] = 3] = \"NONE\";\n})(exports.WriteTo || (exports.WriteTo = {}));\nvar WriteTo = exports.WriteTo;\nlet logFile = 'protractor.log'; // the default log file name\n/**\n * Logger class adds timestamp output, log levels, and identifiers to help\n * when debugging. Also could write to console, file, both, or none.\n */\nclass Logger {\n    /**\n     * Creates a logger instance with an ID for the logger.\n     * @constructor\n     */\n    constructor(id) {\n        this.id = id;\n    }\n    /**\n     * Set up the logging configuration from the protractor configuration file.\n     * @param config The protractor configuration\n     */\n    static set(config) {\n        if (config.troubleshoot) {\n            Logger.logLevel = LogLevel.DEBUG;\n        }\n    }\n    /**\n     * Set up the write location. If writing to a file, get the file descriptor.\n     * @param writeTo The enum for where to write the logs.\n     * @param opt_logFile An optional parameter to override the log file location.\n     */\n    static setWrite(writeTo, opt_logFile) {\n        if (opt_logFile) {\n            logFile = opt_logFile;\n        }\n        Logger.writeTo = writeTo;\n        if (Logger.writeTo == WriteTo.FILE || Logger.writeTo == WriteTo.BOTH) {\n            Logger.fd = fs.openSync(path.resolve(logFile), 'a');\n            Logger.firstWrite = false;\n        }\n    }\n    /**\n     * Log INFO\n     * @param ...msgs multiple arguments to be logged.\n     */\n    info(...msgs) {\n        this.log_(LogLevel.INFO, msgs);\n    }\n    /**\n     * Log DEBUG\n     * @param ...msgs multiple arguments to be logged.\n     */\n    debug(...msgs) {\n        this.log_(LogLevel.DEBUG, msgs);\n    }\n    /**\n     * Log WARN\n     * @param ...msgs multiple arguments to be logged.\n     */\n    warn(...msgs) {\n        this.log_(LogLevel.WARN, msgs);\n    }\n    /**\n     * Log ERROR\n     * @param ...msgs multiple arguments to be logged.\n     */\n    error(...msgs) {\n        this.log_(LogLevel.ERROR, msgs);\n    }\n    /**\n     * For the log level set, check to see if the messages should be logged.\n     * @param logLevel The log level of the message.\n     * @param msgs The messages to be logged\n     */\n    log_(logLevel, msgs) {\n        switch (Logger.logLevel) {\n            case LogLevel.ERROR:\n                if (logLevel <= LogLevel.ERROR) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.WARN:\n                if (logLevel <= LogLevel.WARN) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.INFO:\n                if (logLevel <= LogLevel.INFO) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.DEBUG:\n                if (logLevel <= LogLevel.DEBUG) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            default:\n                throw new Error('Log level undefined');\n        }\n    }\n    /**\n     * Format with timestamp, log level, identifier, and message and log to\n     * specified medium (console, file, both, none).\n     * @param logLevel The log level of the message.\n     * @param msgs The messages to be logged.\n     */\n    print_(logLevel, msgs) {\n        let consoleLog = '';\n        let fileLog = '';\n        if (Logger.showTimestamp) {\n            consoleLog += Logger.timestamp_(WriteTo.CONSOLE);\n            fileLog += Logger.timestamp_(WriteTo.FILE);\n        }\n        consoleLog += Logger.level_(logLevel, this.id, WriteTo.CONSOLE);\n        fileLog += Logger.level_(logLevel, this.id, WriteTo.FILE);\n        if (Logger.showId) {\n            consoleLog += Logger.id_(logLevel, this.id, WriteTo.CONSOLE);\n            fileLog += Logger.id_(logLevel, this.id, WriteTo.FILE);\n        }\n        consoleLog += ' -';\n        fileLog += ' - ';\n        switch (Logger.writeTo) {\n            case WriteTo.CONSOLE:\n                msgs.unshift(consoleLog);\n                console.log.apply(console, msgs);\n                break;\n            case WriteTo.FILE:\n                // for the first line written to the file, add a space\n                if (!Logger.firstWrite) {\n                    fs.writeSync(Logger.fd, '\\n');\n                    Logger.firstWrite = true;\n                }\n                fileLog += ' ' + Logger.msgToFile_(msgs);\n                fs.writeSync(Logger.fd, fileLog + '\\n');\n                break;\n            case WriteTo.BOTH:\n                // for the first line written to the file, add a space\n                if (!Logger.firstWrite) {\n                    fs.writeSync(Logger.fd, '\\n');\n                    Logger.firstWrite = true;\n                }\n                fileLog += ' ' + Logger.msgToFile_(msgs);\n                fs.writeSync(Logger.fd, fileLog + '\\n');\n                msgs.unshift(consoleLog);\n                console.log.apply(console, msgs);\n                break;\n            case WriteTo.NONE:\n                break;\n        }\n    }\n    /**\n     * Get a timestamp formatted with [hh:mm:ss]\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted timestamp\n     */\n    static timestamp_(writeTo) {\n        let d = new Date();\n        let ts = '[';\n        let hours = d.getHours() < 10 ? '0' + d.getHours() : d.getHours();\n        let minutes = d.getMinutes() < 10 ? '0' + d.getMinutes() : d.getMinutes();\n        let seconds = d.getSeconds() < 10 ? '0' + d.getSeconds() : d.getSeconds();\n        if (writeTo == WriteTo.CONSOLE) {\n            ts += printGray(hours + ':' + minutes + ':' + seconds) + ']';\n        }\n        else {\n            ts += hours + ':' + minutes + ':' + seconds + ']';\n        }\n        ts += ' ';\n        return ts;\n    }\n    /**\n     * Get the identifier of the logger as '/<id>'\n     * @param logLevel The log level of the message.\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted id\n     */\n    static id_(logLevel, id, writeTo) {\n        if (writeTo === WriteTo.FILE) {\n            return '/' + id;\n        }\n        else if (logLevel === LogLevel.ERROR) {\n            return printRed('/' + id);\n        }\n        else if (logLevel === LogLevel.WARN) {\n            return printYellow('/' + id);\n        }\n        else {\n            return '/' + id;\n        }\n    }\n    /**\n     * Get the log level formatted with the first letter. For info, it is I.\n     * @param logLevel The log level of the message.\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted log level\n     */\n    static level_(logLevel, id, writeTo) {\n        let level = LogLevel[logLevel].toString();\n        if (writeTo === WriteTo.FILE) {\n            return level[0];\n        }\n        else if (logLevel === LogLevel.ERROR) {\n            return printRed(level[0]);\n        }\n        else if (logLevel === LogLevel.WARN) {\n            return printYellow(level[0]);\n        }\n        else {\n            return level[0];\n        }\n    }\n    /**\n     * Convert the list of messages to a single string message.\n     * @param msgs The list of messages.\n     * @return The string of the formatted messages\n     */\n    static msgToFile_(msgs) {\n        let log = '';\n        for (let pos = 0; pos < msgs.length; pos++) {\n            let msg = msgs[pos];\n            let ret;\n            if (typeof msg === 'object') {\n                ret = JSON.stringify(msg);\n            }\n            else {\n                ret = msg;\n            }\n            if (pos !== msgs.length - 1) {\n                ret += ' ';\n            }\n            log += ret;\n        }\n        return log;\n    }\n}\nLogger.logLevel = LogLevel.INFO;\nLogger.showTimestamp = true;\nLogger.showId = true;\nLogger.writeTo = WriteTo.CONSOLE;\nLogger.firstWrite = false;\nexports.Logger = Logger;\n//# sourceMappingURL=logger.js.map","/home/travis/build/npmtest/node-npmtest-protractor/protractor/built/breakpointhook.js":"module.exports = function() {\n  return true;\n};\n\n/**\n * The reason this file exists is so that we can set a breakpoint via\n * script name, and then control when that breakpoint is set in\n * our library code by importing and calling this function. The\n * breakpoint will always be on line 2.\n */","/home/travis/build/npmtest/node-npmtest-protractor/protractor/built/element.js":"\"use strict\";\nconst selenium_webdriver_1 = require('selenium-webdriver');\nconst locators_1 = require('./locators');\nconst logger_1 = require('./logger');\nconst util_1 = require('./util');\nlet clientSideScripts = require('./clientsidescripts');\nlet logger = new logger_1.Logger('element');\nclass WebdriverWebElement {\n}\nexports.WebdriverWebElement = WebdriverWebElement;\nlet WEB_ELEMENT_FUNCTIONS = [\n    'click', 'sendKeys', 'getTagName', 'getCssValue', 'getAttribute', 'getText', 'getSize',\n    'getLocation', 'isEnabled', 'isSelected', 'submit', 'clear', 'isDisplayed', 'getId',\n    'takeScreenshot'\n];\n/**\n * ElementArrayFinder is used for operations on an array of elements (as opposed\n * to a single element).\n *\n * The ElementArrayFinder is used to set up a chain of conditions that identify\n * an array of elements. In particular, you can call all(locator) and\n * filter(filterFn) to return a new ElementArrayFinder modified by the\n * conditions, and you can call get(index) to return a single ElementFinder at\n * position 'index'.\n *\n * Similar to jquery, ElementArrayFinder will search all branches of the DOM\n * to find the elements that satisfy the conditions (i.e. all, filter, get).\n * However, an ElementArrayFinder will not actually retrieve the elements until\n * an action is called, which means it can be set up in helper files (i.e.\n * page objects) before the page is available, and reused as the page changes.\n *\n * You can treat an ElementArrayFinder as an array of WebElements for most\n * purposes, in particular, you may perform actions (i.e. click, getText) on\n * them as you would an array of WebElements. The action will apply to\n * every element identified by the ElementArrayFinder. ElementArrayFinder\n * extends Promise, and once an action is performed on an ElementArrayFinder,\n * the latest result can be accessed using then, and will be returned as an\n * array of the results; the array has length equal to the length of the\n * elements found by the ElementArrayFinder and each result represents the\n * result of performing the action on the element. Unlike a WebElement, an\n * ElementArrayFinder will wait for the angular app to settle before\n * performing finds or actions.\n *\n * @alias element.all(locator)\n * @view\n * <ul class=\"items\">\n *   <li>First</li>\n *   <li>Second</li>\n *   <li>Third</li>\n * </ul>\n *\n * @example\n * element.all(by.css('.items li')).then(function(items) {\n *   expect(items.length).toBe(3);\n *   expect(items[0].getText()).toBe('First');\n * });\n *\n * // Or using the shortcut $$() notation instead of element.all(by.css()):\n *\n * $$('.items li').then(function(items) {\n *   expect(items.length).toBe(3);\n *   expect(items[0].getText()).toBe('First');\n * });\n *\n * @constructor\n * @param {ProtractorBrowser} browser A browser instance.\n * @param {function(): Array.<webdriver.WebElement>} getWebElements A function\n *    that returns a list of the underlying Web Elements.\n * @param {webdriver.Locator} locator The most relevant locator. It is only\n *    used for error reporting and ElementArrayFinder.locator.\n * @param {Array.<webdriver.promise.Promise>} opt_actionResults An array\n *    of promises which will be retrieved with then. Resolves to the latest\n *    action result, or null if no action has been called.\n * @returns {ElementArrayFinder}\n */\nclass ElementArrayFinder extends WebdriverWebElement {\n    constructor(browser_, getWebElements = null, locator_, actionResults_ = null) {\n        super();\n        this.browser_ = browser_;\n        this.getWebElements = getWebElements;\n        this.locator_ = locator_;\n        this.actionResults_ = actionResults_;\n        // TODO(juliemr): might it be easier to combine this with our docs and just\n        // wrap each one explicity with its own documentation?\n        WEB_ELEMENT_FUNCTIONS.forEach((fnName) => {\n            this[fnName] = (...args) => {\n                let actionFn = (webElem) => {\n                    return webElem[fnName].apply(webElem, args);\n                };\n                return this.applyAction_(actionFn);\n            };\n        });\n    }\n    /**\n     * Create a shallow copy of ElementArrayFinder.\n     *\n     * @returns {!ElementArrayFinder} A shallow copy of this.\n     */\n    clone() {\n        // A shallow copy is all we need since the underlying fields can never be\n        // modified. (Locator can be modified by the user, but that should\n        // rarely/never happen and it doesn't affect functionalities).\n        return new ElementArrayFinder(this.browser_, this.getWebElements, this.locator_, this.actionResults_);\n    }\n    /**\n     * Calls to ElementArrayFinder may be chained to find an array of elements\n     * using the current elements in this ElementArrayFinder as the starting\n     * point. This function returns a new ElementArrayFinder which would contain\n     * the children elements found (and could also be empty).\n     *\n     * @alias element.all(locator).all(locator)\n     * @view\n     * <div id='id1' class=\"parent\">\n     *   <ul>\n     *     <li class=\"foo\">1a</li>\n     *     <li class=\"baz\">1b</li>\n     *   </ul>\n     * </div>\n     * <div id='id2' class=\"parent\">\n     *   <ul>\n     *     <li class=\"foo\">2a</li>\n     *     <li class=\"bar\">2b</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let foo = element.all(by.css('.parent')).all(by.css('.foo'));\n     * expect(foo.getText()).toEqual(['1a', '2a']);\n     * let baz = element.all(by.css('.parent')).all(by.css('.baz'));\n     * expect(baz.getText()).toEqual(['1b']);\n     * let nonexistent = element.all(by.css('.parent'))\n     *   .all(by.css('.NONEXISTENT'));\n     * expect(nonexistent.getText()).toEqual(['']);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let foo = $$('.parent').$$('.foo');\n     * expect(foo.getText()).toEqual(['1a', '2a']);\n     * let baz = $$('.parent').$$('.baz');\n     * expect(baz.getText()).toEqual(['1b']);\n     * let nonexistent = $$('.parent').$$('.NONEXISTENT');\n     * expect(nonexistent.getText()).toEqual(['']);\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementArrayFinder}\n     */\n    all(locator) {\n        let ptor = this.browser_;\n        let getWebElements = () => {\n            if (this.getWebElements === null) {\n                // This is the first time we are looking for an element\n                return ptor.waitForAngular('Locator: ' + locator)\n                    .then(() => {\n                    if (locators_1.isProtractorLocator(locator)) {\n                        return locator.findElementsOverride(ptor.driver, null, ptor.rootEl);\n                    }\n                    else {\n                        return ptor.driver.findElements(locator);\n                    }\n                });\n            }\n            else {\n                return this.getWebElements().then((parentWebElements) => {\n                    // For each parent web element, find their children and construct\n                    // a list of Promise<List<child_web_element>>\n                    let childrenPromiseList = parentWebElements.map((parentWebElement) => {\n                        return locators_1.isProtractorLocator(locator) ?\n                            locator.findElementsOverride(ptor.driver, parentWebElement, ptor.rootEl) :\n                            parentWebElement.findElements(locator);\n                    });\n                    // Resolve the list of Promise<List<child_web_elements>> and merge\n                    // into a single list\n                    return selenium_webdriver_1.promise.all(childrenPromiseList)\n                        .then((resolved) => {\n                        return resolved.reduce((childrenList, resolvedE) => {\n                            return childrenList.concat(resolvedE);\n                        }, []);\n                    });\n                });\n            }\n        };\n        return new ElementArrayFinder(this.browser_, getWebElements, locator);\n    }\n    /**\n     * Apply a filter function to each element within the ElementArrayFinder.\n     * Returns a new ElementArrayFinder with all elements that pass the filter\n     * function. The filter function receives the ElementFinder as the first\n     * argument and the index as a second arg. This does not actually retrieve\n     * the underlying list of elements, so it can be used in page objects.\n     *\n     * @alias element.all(locator).filter(filterFn)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).filter(function(elem, index) {\n     *   return elem.getText().then(function(text) {\n     *     return text === 'Third';\n     *   });\n     * }).first().click();\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').filter(function(elem, index) {\n     *   return elem.getText().then(function(text) {\n     *     return text === 'Third';\n     *   });\n     * }).first().click();\n     *\n     * @param {function(ElementFinder, number): webdriver.WebElement.Promise}\n     * filterFn\n     *     Filter function that will test if an element should be returned.\n     *     filterFn can either return a boolean or a promise that resolves to a\n     * boolean\n     * @returns {!ElementArrayFinder} A ElementArrayFinder that represents an\n     * array\n     *     of element that satisfy the filter function.\n     */\n    filter(filterFn) {\n        let getWebElements = () => {\n            return this.getWebElements().then((parentWebElements) => {\n                let list = parentWebElements.map((parentWebElement, index) => {\n                    let elementFinder = ElementFinder.fromWebElement_(this.browser_, parentWebElement, this.locator_);\n                    return filterFn(elementFinder, index);\n                });\n                return selenium_webdriver_1.promise.all(list).then((resolvedList) => {\n                    return parentWebElements.filter((parentWebElement, index) => {\n                        return resolvedList[index];\n                    });\n                });\n            });\n        };\n        return new ElementArrayFinder(this.browser_, getWebElements, this.locator_);\n    }\n    /**\n     * Get an element within the ElementArrayFinder by index. The index starts at\n     * 0\\. Negative indices are wrapped (i.e. -i means ith element from last)\n     * This does not actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).get(index)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let list = element.all(by.css('.items li'));\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.items li');\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * @param {number|webdriver.promise.Promise} index Element index.\n     * @returns {ElementFinder} finder representing element at the given index.\n     */\n    get(index) {\n        let getWebElements = () => {\n            return selenium_webdriver_1.promise.all([index, this.getWebElements()]).then(([i, parentWebElements]) => {\n                if (i < 0) {\n                    i += parentWebElements.length;\n                }\n                if (i < 0 || i >= parentWebElements.length) {\n                    throw new selenium_webdriver_1.error.NoSuchElementError('Index out of bound. Trying to access element at index: ' + index +\n                        ', but there are only ' + parentWebElements.length + ' elements that match ' +\n                        'locator ' + this.locator_.toString());\n                }\n                return [parentWebElements[i]];\n            });\n        };\n        return new ElementArrayFinder(this.browser_, getWebElements, this.locator_).toElementFinder_();\n    }\n    /**\n     * Get the first matching element for the ElementArrayFinder. This does not\n     * actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).first()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let first = element.all(by.css('.items li')).first();\n     * expect(first.getText()).toBe('First');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let first = $$('.items li').first();\n     * expect(first.getText()).toBe('First');\n     *\n     * @returns {ElementFinder} finder representing the first matching element\n     */\n    first() {\n        return this.get(0);\n    }\n    ;\n    /**\n     * Get the last matching element for the ElementArrayFinder. This does not\n     * actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).last()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let last = element.all(by.css('.items li')).last();\n     * expect(last.getText()).toBe('Third');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let last = $$('.items li').last();\n     * expect(last.getText()).toBe('Third');\n     *\n     * @returns {ElementFinder} finder representing the last matching element\n     */\n    last() {\n        return this.get(-1);\n    }\n    /**\n     * Shorthand function for finding arrays of elements by css.\n     * `element.all(by.css('.abc'))` is equivalent to `$$('.abc')`\n     *\n     * @alias $$(cssSelector)\n     * @view\n     * <div class=\"count\">\n     *   <span class=\"one\">First</span>\n     *   <span class=\"two\">Second</span>\n     * </div>\n     *\n     * @example\n     * // The following two blocks of code are equivalent.\n     * let list = element.all(by.css('.count span'));\n     * expect(list.count()).toBe(2);\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.count span');\n     * expect(list.count()).toBe(2);\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * @param {string} selector a css selector\n     * @returns {ElementArrayFinder} which identifies the\n     *     array of the located {@link webdriver.WebElement}s.\n     */\n    $$(selector) {\n        return this.all(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Returns an ElementFinder representation of ElementArrayFinder. It ensures\n     * that the ElementArrayFinder resolves to one and only one underlying\n     * element.\n     *\n     * @returns {ElementFinder} An ElementFinder representation\n     * @private\n     */\n    toElementFinder_() {\n        return new ElementFinder(this.browser_, this);\n    }\n    /**\n     * Count the number of elements represented by the ElementArrayFinder.\n     *\n     * @alias element.all(locator).count()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let list = element.all(by.css('.items li'));\n     * expect(list.count()).toBe(3);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.items li');\n     * expect(list.count()).toBe(3);\n     *\n     * @returns {!webdriver.promise.Promise} A promise which resolves to the\n     *     number of elements matching the locator.\n     */\n    count() {\n        return this.getWebElements().then((arr) => {\n            return arr.length;\n        }, (err) => {\n            if (err instanceof selenium_webdriver_1.error.NoSuchElementError) {\n                return 0;\n            }\n            else {\n                throw err;\n            }\n        });\n    }\n    /**\n     * Returns true if there are any elements present that match the finder.\n     *\n     * @alias element.all(locator).isPresent()\n     *\n     * @example\n     * expect($('.item').isPresent()).toBeTruthy();\n     *\n     * @returns {Promise<boolean>}\n     */\n    isPresent() {\n        return this.count().then((count) => {\n            return count > 0;\n        });\n    }\n    /**\n     * Returns the most relevant locator.\n     *\n     * @example\n     * // returns by.css('#ID1')\n     * $('#ID1').locator();\n     *\n     * // returns by.css('#ID2')\n     * $('#ID1').$('#ID2').locator();\n     *\n     * // returns by.css('#ID1')\n     * $$('#ID1').filter(filterFn).get(0).click().locator();\n     *\n     * @returns {webdriver.Locator}\n     */\n    locator() {\n        return this.locator_;\n    }\n    /**\n     * Apply an action function to every element in the ElementArrayFinder,\n     * and return a new ElementArrayFinder that contains the results of the\n     * actions.\n     *\n     * @param {function(ElementFinder)} actionFn\n     *\n     * @returns {ElementArrayFinder}\n     * @private\n     */\n    // map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\n    applyAction_(actionFn) {\n        let callerError = new Error();\n        let actionResults = this.getWebElements()\n            .then((arr) => selenium_webdriver_1.promise.all(arr.map(actionFn)))\n            .then((value) => {\n            return { passed: true, value: value };\n        }, (error) => {\n            return { passed: false, value: error };\n        });\n        let getWebElements = () => actionResults.then(() => this.getWebElements());\n        actionResults = actionResults.then((result) => {\n            if (result.passed) {\n                return result.value;\n            }\n            else {\n                let noSuchErr;\n                if (result.value instanceof Error) {\n                    noSuchErr = result.value;\n                    noSuchErr.stack = noSuchErr.stack + callerError.stack;\n                }\n                else {\n                    noSuchErr = new Error(result.value);\n                    noSuchErr.stack = callerError.stack;\n                }\n                throw noSuchErr;\n            }\n        });\n        return new ElementArrayFinder(this.browser_, getWebElements, this.locator_, actionResults);\n    }\n    /**\n     * Represents the ElementArrayFinder as an array of ElementFinders.\n     *\n     * @returns {Array.<ElementFinder>} Return a promise, which resolves to a list\n     *     of ElementFinders specified by the locator.\n     */\n    asElementFinders_() {\n        return this.getWebElements().then((arr) => {\n            return arr.map((webElem) => {\n                return ElementFinder.fromWebElement_(this.browser_, webElem, this.locator_);\n            });\n        });\n    }\n    /**\n     * Retrieve the elements represented by the ElementArrayFinder. The input\n     * function is passed to the resulting promise, which resolves to an\n     * array of ElementFinders.\n     *\n     * @alias element.all(locator).then(thenFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).then(function(arr) {\n     *   expect(arr.length).toEqual(3);\n     * });\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').then(function(arr) {\n     *   expect(arr.length).toEqual(3);\n     * });\n     *\n     * @param {function(Array.<ElementFinder>)} fn\n     * @param {function(Error)} errorFn\n     *\n     * @returns {!webdriver.promise.Promise} A promise which will resolve to\n     *     an array of ElementFinders represented by the ElementArrayFinder.\n     */\n    then(fn, errorFn) {\n        if (this.actionResults_) {\n            return this.actionResults_.then(fn, errorFn);\n        }\n        else {\n            return this.asElementFinders_().then(fn, errorFn);\n        }\n    }\n    /**\n     * Calls the input function on each ElementFinder represented by the\n     * ElementArrayFinder.\n     *\n     * @alias element.all(locator).each(eachFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).each(function(element, index) {\n     *   // Will print 0 First, 1 Second, 2 Third.\n     *   element.getText().then(function (text) {\n     *     console.log(index, text);\n     *   });\n     * });\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').each(function(element, index) {\n     *   // Will print 0 First, 1 Second, 2 Third.\n     *   element.getText().then(function (text) {\n     *     console.log(index, text);\n     *   });\n     * });\n     *\n     * @param {function(ElementFinder)} fn Input function\n     *\n     * @returns {!webdriver.promise.Promise} A promise that will resolve when the\n     *     function has been called on all the ElementFinders. The promise will\n     *     resolve to null.\n     */\n    each(fn) {\n        return this.map(fn).then(() => {\n            return null;\n        });\n    }\n    /**\n     * Apply a map function to each element within the ElementArrayFinder. The\n     * callback receives the ElementFinder as the first argument and the index as\n     * a second arg.\n     *\n     * @alias element.all(locator).map(mapFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * let items = element.all(by.css('.items li')).map(function(elm, index) {\n     *   return {\n     *     index: index,\n     *     text: elm.getText(),\n     *     class: elm.getAttribute('class')\n     *   };\n     * });\n     * expect(items).toEqual([\n     *   {index: 0, text: 'First', class: 'one'},\n     *   {index: 1, text: 'Second', class: 'two'},\n     *   {index: 2, text: 'Third', class: 'three'}\n     * ]);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let items = $$('.items li').map(function(elm, index) {\n     *   return {\n     *     index: index,\n     *     text: elm.getText(),\n     *     class: elm.getAttribute('class')\n     *   };\n     * });\n     * expect(items).toEqual([\n     *   {index: 0, text: 'First', class: 'one'},\n     *   {index: 1, text: 'Second', class: 'two'},\n     *   {index: 2, text: 'Third', class: 'three'}\n     * ]);\n     *\n     * @param {function(ElementFinder, number)} mapFn Map function that\n     *     will be applied to each element.\n     * @returns {!webdriver.promise.Promise} A promise that resolves to an array\n     *     of values returned by the map function.\n     */\n    map(mapFn) {\n        return this.asElementFinders_().then((arr) => {\n            let list = arr.map((elementFinder, index) => {\n                let mapResult = mapFn(elementFinder, index);\n                // All nested arrays and objects will also be fully resolved.\n                return selenium_webdriver_1.promise.fullyResolved(mapResult);\n            });\n            return selenium_webdriver_1.promise.all(list);\n        });\n    }\n    ;\n    /**\n     * Apply a reduce function against an accumulator and every element found\n     * using the locator (from left-to-right). The reduce function has to reduce\n     * every element into a single value (the accumulator). Returns promise of\n     * the accumulator. The reduce function receives the accumulator, current\n     * ElementFinder, the index, and the entire array of ElementFinders,\n     * respectively.\n     *\n     * @alias element.all(locator).reduce(reduceFn)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * let value = element.all(by.css('.items li')).reduce(function(acc, elem) {\n     *   return elem.getText().then(function(text) {\n     *     return acc + text + ' ';\n     *   });\n     * }, '');\n     *\n     * expect(value).toEqual('First Second Third ');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let value = $$('.items li').reduce(function(acc, elem) {\n     *   return elem.getText().then(function(text) {\n     *     return acc + text + ' ';\n     *   });\n     * }, '');\n     *\n     * expect(value).toEqual('First Second Third ');\n     *\n     * @param {function(number, ElementFinder, number, Array.<ElementFinder>)}\n     *     reduceFn Reduce function that reduces every element into a single\n     * value.\n     * @param {*} initialValue Initial value of the accumulator.\n     * @returns {!webdriver.promise.Promise} A promise that resolves to the final\n     *     value of the accumulator.\n     */\n    reduce(reduceFn, initialValue) {\n        let valuePromise = selenium_webdriver_1.promise.when(initialValue);\n        return this.asElementFinders_().then((arr) => {\n            return arr.reduce((valuePromise, elementFinder, index) => {\n                return valuePromise.then((value) => {\n                    return reduceFn(value, elementFinder, index, arr);\n                });\n            }, valuePromise);\n        });\n    }\n    /**\n     * Evaluates the input as if it were on the scope of the current underlying\n     * elements.\n     *\n     * @view\n     * <span class=\"foo\">{{letiableInScope}}</span>\n     *\n     * @example\n     * let value = element.all(by.css('.foo')).evaluate('letiableInScope');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let value = $$('.foo').evaluate('letiableInScope');\n     *\n     * @param {string} expression\n     *\n     * @returns {ElementArrayFinder} which resolves to the\n     *     evaluated expression for each underlying element.\n     *     The result will be resolved as in\n     *     {@link webdriver.WebDriver.executeScript}. In summary - primitives will\n     *     be resolved as is, functions will be converted to string, and elements\n     *     will be returned as a WebElement.\n     */\n    evaluate(expression) {\n        let evaluationFn = (webElem) => {\n            return webElem.getDriver().executeScript(clientSideScripts.evaluate, webElem, expression);\n        };\n        return this.applyAction_(evaluationFn);\n    }\n    /**\n     * Determine if animation is allowed on the current underlying elements.\n     * @param {string} value\n     *\n     * @example\n     * // Turns off ng-animate animations for all elements in the <body>\n     * element(by.css('body')).allowAnimations(false);\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * $('body').allowAnimations(false);\n     *\n     * @returns {ElementArrayFinder} which resolves to whether animation is\n     * allowed.\n     */\n    allowAnimations(value) {\n        let allowAnimationsTestFn = (webElem) => {\n            return webElem.getDriver().executeScript(clientSideScripts.allowAnimations, webElem, value);\n        };\n        return this.applyAction_(allowAnimationsTestFn);\n    }\n}\nexports.ElementArrayFinder = ElementArrayFinder;\n/**\n * The ElementFinder simply represents a single element of an\n * ElementArrayFinder (and is more like a convenience object). As a result,\n * anything that can be done with an ElementFinder, can also be done using\n * an ElementArrayFinder.\n *\n * The ElementFinder can be treated as a WebElement for most purposes, in\n * particular, you may perform actions (i.e. click, getText) on them as you\n * would a WebElement. Once an action is performed on an ElementFinder, the\n * latest result from the chain can be accessed using the then method.\n * Unlike a WebElement, an ElementFinder will wait for angular to settle before\n * performing finds or actions.\n *\n * ElementFinder can be used to build a chain of locators that is used to find\n * an element. An ElementFinder does not actually attempt to find the element\n * until an action is called, which means they can be set up in helper files\n * before the page is available.\n *\n * @alias element(locator)\n * @view\n * <span>{{person.name}}</span>\n * <span ng-bind=\"person.email\"></span>\n * <input type=\"text\" ng-model=\"person.name\"/>\n *\n * @example\n * // Find element with {{scopelet}} syntax.\n * element(by.binding('person.name')).getText().then(function(name) {\n *   expect(name).toBe('Foo');\n * });\n *\n * // Find element with ng-bind=\"scopelet\" syntax.\n * expect(element(by.binding('person.email')).getText()).toBe('foo@bar.com');\n *\n * // Find by model.\n * let input = element(by.model('person.name'));\n * input.sendKeys('123');\n * expect(input.getAttribute('value')).toBe('Foo123');\n *\n * @constructor\n * @extends {webdriver.WebElement}\n * @param {ProtractorBrowser} browser_ A browser instance.\n * @param {ElementArrayFinder} elementArrayFinder The ElementArrayFinder\n *     that this is branched from.\n * @returns {ElementFinder}\n */\nclass ElementFinder extends WebdriverWebElement {\n    constructor(browser_, elementArrayFinder) {\n        super();\n        this.browser_ = browser_;\n        this.then = null;\n        if (!elementArrayFinder) {\n            throw new Error('BUG: elementArrayFinder cannot be empty');\n        }\n        this.parentElementArrayFinder = elementArrayFinder;\n        // Only have a `then` method if the parent element array finder\n        // has action results.\n        if (this.parentElementArrayFinder.actionResults_) {\n            // Access the underlying actionResult of ElementFinder.\n            this.then =\n                    (fn, errorFn) => {\n                    return this.elementArrayFinder_.then((actionResults) => {\n                        if (!fn) {\n                            return actionResults[0];\n                        }\n                        return fn(actionResults[0]);\n                    }, errorFn);\n                };\n        }\n        // This filter verifies that there is only 1 element returned by the\n        // elementArrayFinder. It will warn if there are more than 1 element and\n        // throw an error if there are no elements.\n        let getWebElements = () => {\n            return elementArrayFinder.getWebElements().then((webElements) => {\n                if (webElements.length === 0) {\n                    throw new selenium_webdriver_1.error.NoSuchElementError('No element found using locator: ' + elementArrayFinder.locator().toString());\n                }\n                else {\n                    if (webElements.length > 1) {\n                        logger.warn('more than one element found for locator ' +\n                            elementArrayFinder.locator().toString() + ' - the first result will be used');\n                    }\n                    return [webElements[0]];\n                }\n            });\n        };\n        // Store a copy of the underlying elementArrayFinder, but with the more\n        // restrictive getWebElements (which checks that there is only 1 element).\n        this.elementArrayFinder_ = new ElementArrayFinder(this.browser_, getWebElements, elementArrayFinder.locator(), elementArrayFinder.actionResults_);\n        WEB_ELEMENT_FUNCTIONS.forEach((fnName) => {\n            (this)[fnName] = (...args) => {\n                return (this.elementArrayFinder_)[fnName]\n                    .apply(this.elementArrayFinder_, args)\n                    .toElementFinder_();\n            };\n        });\n    }\n    static fromWebElement_(browser, webElem, locator) {\n        let getWebElements = () => {\n            return selenium_webdriver_1.promise.when([webElem]);\n        };\n        return new ElementArrayFinder(browser, getWebElements, locator).toElementFinder_();\n    }\n    /**\n     * Create a shallow copy of ElementFinder.\n     *\n     * @returns {!ElementFinder} A shallow copy of this.\n     */\n    clone() {\n        // A shallow copy is all we need since the underlying fields can never be\n        // modified\n        return new ElementFinder(this.browser_, this.parentElementArrayFinder);\n    }\n    /**\n     * @see ElementArrayFinder.prototype.locator\n     *\n     * @returns {webdriver.Locator}\n     */\n    locator() {\n        return this.elementArrayFinder_.locator();\n    }\n    /**\n     * Returns the WebElement represented by this ElementFinder.\n     * Throws the WebDriver error if the element doesn't exist.\n     *\n     * @alias element(locator).getWebElement()\n     * @view\n     * <div class=\"parent\">\n     *   some text\n     * </div>\n     *\n     * @example\n     * // The following four expressions are equivalent.\n     * $('.parent').getWebElement();\n     * element(by.css('.parent')).getWebElement();\n     * browser.driver.findElement(by.css('.parent'));\n     * browser.findElement(by.css('.parent'));\n     *\n     * @returns {webdriver.WebElementPromise}\n     */\n    getWebElement() {\n        let id = this.elementArrayFinder_.getWebElements().then((parentWebElements) => {\n            return parentWebElements[0];\n        });\n        return new selenium_webdriver_1.WebElementPromise(this.browser_.driver, id);\n    }\n    /**\n     * Calls to {@code all} may be chained to find an array of elements within a\n     * parent.\n     *\n     * @alias element(locator).all(locator)\n     * @view\n     * <div class=\"parent\">\n     *   <ul>\n     *     <li class=\"one\">First</li>\n     *     <li class=\"two\">Second</li>\n     *     <li class=\"three\">Third</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let items = element(by.css('.parent')).all(by.tagName('li'));\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * let items = $('.parent').all(by.tagName('li'));\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementArrayFinder}\n     */\n    all(subLocator) {\n        return this.elementArrayFinder_.all(subLocator);\n    }\n    /**\n     * Calls to {@code element} may be chained to find elements within a parent.\n     *\n     * @alias element(locator).element(locator)\n     * @view\n     * <div class=\"parent\">\n     *   <div class=\"child\">\n     *     Child text\n     *     <div>{{person.phone}}</div>\n     *   </div>\n     * </div>\n     *\n     * @example\n     * // Chain 2 element calls.\n     * let child = element(by.css('.parent')).\n     *     element(by.css('.child'));\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = element(by.css('.parent')).\n     *     element(by.css('.child')).\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * // Chain 2 element calls.\n     * let child = $('.parent').$('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = $('.parent').$('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementFinder}\n     */\n    element(subLocator) {\n        return this.all(subLocator).toElementFinder_();\n    }\n    /**\n     * Calls to {@code $$} may be chained to find an array of elements within a\n     * parent.\n     *\n     * @alias element(locator).all(selector)\n     * @view\n     * <div class=\"parent\">\n     *   <ul>\n     *     <li class=\"one\">First</li>\n     *     <li class=\"two\">Second</li>\n     *     <li class=\"three\">Third</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let items = element(by.css('.parent')).$$('li');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * let items = $('.parent').$$('li');\n     *\n     * @param {string} selector a css selector\n     * @returns {ElementArrayFinder}\n     */\n    $$(selector) {\n        return this.all(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Calls to {@code $} may be chained to find elements within a parent.\n     *\n     * @alias element(locator).$(selector)\n     * @view\n     * <div class=\"parent\">\n     *   <div class=\"child\">\n     *     Child text\n     *     <div>{{person.phone}}</div>\n     *   </div>\n     * </div>\n     *\n     * @example\n     * // Chain 2 element calls.\n     * let child = element(by.css('.parent')).\n     *     $('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = element(by.css('.parent')).\n     *     $('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * // Chain 2 element calls.\n     * let child = $('.parent').$('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = $('.parent').$('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * @param {string} selector A css selector\n     * @returns {ElementFinder}\n     */\n    $(selector) {\n        return this.element(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Determine whether the element is present on the page.\n     *\n     * @view\n     * <span>{{person.name}}</span>\n     *\n     * @example\n     * // Element exists.\n     * expect(element(by.binding('person.name')).isPresent()).toBe(true);\n     *\n     * // Element not present.\n     * expect(element(by.binding('notPresent')).isPresent()).toBe(false);\n     *\n     * @returns {webdriver.promise.Promise<boolean>} which resolves to whether\n     *     the element is present on the page.\n     */\n    isPresent() {\n        return this.parentElementArrayFinder.getWebElements().then((arr) => {\n            if (arr.length === 0) {\n                return false;\n            }\n            return arr[0].isEnabled().then(() => {\n                return true; // is present, whether it is enabled or not\n            }, util_1.falseIfMissing);\n        }, util_1.falseIfMissing);\n    }\n    /**\n     * Same as ElementFinder.isPresent(), except this checks whether the element\n     * identified by the subLocator is present, rather than the current element\n     * finder. i.e. `element(by.css('#abc')).element(by.css('#def')).isPresent()`\n     * is identical to `element(by.css('#abc')).isElementPresent(by.css('#def'))`.\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * `$('#abc').$('#def').isPresent()` is identical to\n     * `$('#abc').isElementPresent($('#def'))`.\n     *\n     * @see ElementFinder.isPresent\n     *\n     * @param {webdriver.Locator} subLocator Locator for element to look for.\n     * @returns {webdriver.promise.Promise<boolean>} which resolves to whether\n     *     the subelement is present on the page.\n     */\n    isElementPresent(subLocator) {\n        if (!subLocator) {\n            throw new Error('SubLocator is not supplied as a parameter to ' +\n                '`isElementPresent(subLocator)`. You are probably looking for the ' +\n                'function `isPresent()`.');\n        }\n        return this.element(subLocator).isPresent();\n    }\n    /**\n     * Evaluates the input as if it were on the scope of the current element.\n     * @see ElementArrayFinder.prototype.evaluate\n     *\n     * @view\n     * <span id=\"foo\">{{letiableInScope}}</span>\n     *\n     * @example\n     * let value = element(by.id('foo')).evaluate('letiableInScope');\n     *\n     * @param {string} expression\n     *\n     * @returns {ElementFinder} which resolves to the evaluated expression.\n     */\n    evaluate(expression) {\n        return this.elementArrayFinder_.evaluate(expression).toElementFinder_();\n    }\n    /**\n     * @see ElementArrayFinder.prototype.allowAnimations.\n     * @param {string} value\n     *\n     * @returns {ElementFinder} which resolves to whether animation is allowed.\n     */\n    allowAnimations(value) {\n        return this.elementArrayFinder_.allowAnimations(value).toElementFinder_();\n    }\n    /**\n     * Compares an element to this one for equality.\n     *\n     * @param {!ElementFinder|!webdriver.WebElement} The element to compare to.\n     *\n     * @returns {!webdriver.promise.Promise.<boolean>} A promise that will be\n     *     resolved to whether the two WebElements are equal.\n     */\n    equals(element) {\n        return selenium_webdriver_1.WebElement.equals(this.getWebElement(), element.getWebElement ? element.getWebElement() :\n            element);\n    }\n}\nexports.ElementFinder = ElementFinder;\n/**\n * Shortcut for querying the document directly with css.\n * `element(by.css('.abc'))` is equivalent to `$('.abc')`\n *\n * @alias $(cssSelector)\n * @view\n * <div class=\"count\">\n *   <span class=\"one\">First</span>\n *   <span class=\"two\">Second</span>\n * </div>\n *\n * @example\n * let item = $('.count .two');\n * expect(item.getText()).toBe('Second');\n *\n * @param {string} selector A css selector\n * @returns {ElementFinder} which identifies the located\n *     {@link webdriver.WebElement}\n */\nexports.build$ = (element, by) => {\n    return (selector) => {\n        return element(by.css(selector));\n    };\n};\n/**\n * Shortcut for querying the document directly with css.\n * `element.all(by.css('.abc'))` is equivalent to `$$('.abc')`\n *\n * @alias $$(cssSelector)\n * @view\n * <div class=\"count\">\n *   <span class=\"one\">First</span>\n *   <span class=\"two\">Second</span>\n * </div>\n *\n * @example\n * // The following protractor expressions are equivalent.\n * let list = element.all(by.css('.count span'));\n * expect(list.count()).toBe(2);\n *\n * list = $$('.count span');\n * expect(list.count()).toBe(2);\n * expect(list.get(0).getText()).toBe('First');\n * expect(list.get(1).getText()).toBe('Second');\n *\n * @param {string} selector a css selector\n * @returns {ElementArrayFinder} which identifies the\n *     array of the located {@link webdriver.WebElement}s.\n */\nexports.build$$ = (element, by) => {\n    return (selector) => {\n        return element.all(by.css(selector));\n    };\n};\n//# sourceMappingURL=element.js.map","/home/travis/build/npmtest/node-npmtest-protractor/protractor/built/locators.js":"\"use strict\";\nconst selenium_webdriver_1 = require('selenium-webdriver');\nlet clientSideScripts = require('./clientsidescripts');\n// Explicitly define webdriver.By.\n// We do this because we want to inherit the static methods of webdriver.By, as opposed to\n// inheriting from the webdriver.By class itself, which is actually analogous to ProtractorLocator.\nclass WebdriverBy {\n    constructor() {\n        this.className = selenium_webdriver_1.By.className;\n        this.css = selenium_webdriver_1.By.css;\n        this.id = selenium_webdriver_1.By.id;\n        this.linkText = selenium_webdriver_1.By.linkText;\n        this.js = selenium_webdriver_1.By.js;\n        this.name = selenium_webdriver_1.By.name;\n        this.partialLinkText = selenium_webdriver_1.By.partialLinkText;\n        this.tagName = selenium_webdriver_1.By.tagName;\n        this.xpath = selenium_webdriver_1.By.xpath;\n    }\n}\nexports.WebdriverBy = WebdriverBy;\nfunction isProtractorLocator(x) {\n    return x && (typeof x.findElementsOverride === 'function');\n}\nexports.isProtractorLocator = isProtractorLocator;\n/**\n * The Protractor Locators. These provide ways of finding elements in\n * Angular applications by binding, model, etc.\n *\n * @alias by\n * @extends {webdriver.By}\n */\nclass ProtractorBy extends WebdriverBy {\n    /**\n     * Add a locator to this instance of ProtractorBy. This locator can then be\n     * used with element(by.locatorName(args)).\n     *\n     * @view\n     * <button ng-click=\"doAddition()\">Go!</button>\n     *\n     * @example\n     * // Add the custom locator.\n     * by.addLocator('buttonTextSimple',\n     *     function(buttonText, opt_parentElement, opt_rootSelector) {\n     *   // This function will be serialized as a string and will execute in the\n     *   // browser. The first argument is the text for the button. The second\n     *   // argument is the parent element, if any.\n     *   var using = opt_parentElement || document,\n     *       buttons = using.querySelectorAll('button');\n     *\n     *   // Return an array of buttons with the text.\n     *   return Array.prototype.filter.call(buttons, function(button) {\n     *     return button.textContent === buttonText;\n     *   });\n     * });\n     *\n     * // Use the custom locator.\n     * element(by.buttonTextSimple('Go!')).click();\n     *\n     * @alias by.addLocator(locatorName, functionOrScript)\n     * @param {string} name The name of the new locator.\n     * @param {Function|string} script A script to be run in the context of\n     *     the browser. This script will be passed an array of arguments\n     *     that contains any args passed into the locator followed by the\n     *     element scoping the search and the css selector for the root angular\n     *     element. It should return an array of elements.\n     */\n    addLocator(name, script) {\n        this[name] = (...args) => {\n            let locatorArguments = args;\n            return {\n                findElementsOverride: (driver, using, rootSelector) => {\n                    let findElementArguments = [script];\n                    for (let i = 0; i < locatorArguments.length; i++) {\n                        findElementArguments.push(locatorArguments[i]);\n                    }\n                    findElementArguments.push(using);\n                    findElementArguments.push(rootSelector);\n                    return driver.findElements(selenium_webdriver_1.By.js.apply(selenium_webdriver_1.By, findElementArguments));\n                },\n                toString: () => {\n                    return 'by.' + name + '(\"' + Array.prototype.join.call(locatorArguments, '\", \"') + '\")';\n                }\n            };\n        };\n    }\n    ;\n    /**\n     * Find an element by text binding. Does a partial match, so any elements\n     * bound to variables containing the input string will be returned.\n     *\n     * Note: For AngularJS version 1.2, the interpolation brackets, (usually\n     * {{}}), are optionally allowed in the binding description string. For\n     * Angular version 1.3+, they are not allowed, and no elements will be found\n     * if they are used.\n     *\n     * @view\n     * <span>{{person.name}}</span>\n     * <span ng-bind=\"person.email\"></span>\n     *\n     * @example\n     * var span1 = element(by.binding('person.name'));\n     * expect(span1.getText()).toBe('Foo');\n     *\n     * var span2 = element(by.binding('person.email'));\n     * expect(span2.getText()).toBe('foo@bar.com');\n     *\n     * // You can also use a substring for a partial match\n     * var span1alt = element(by.binding('name'));\n     * expect(span1alt.getText()).toBe('Foo');\n     *\n     * // This works for sites using Angular 1.2 but NOT 1.3\n     * var deprecatedSyntax = element(by.binding('{{person.name}}'));\n     *\n     * @param {string} bindingDescriptor\n     * @returns {ProtractorLocator} location strategy\n     */\n    binding(bindingDescriptor) {\n        return {\n            findElementsOverride: (driver, using, rootSelector) => {\n                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findBindings, bindingDescriptor, false, using, rootSelector));\n            },\n            toString: () => {\n                return 'by.binding(\"' + bindingDescriptor + '\")';\n            }\n        };\n    }\n    ;\n    /**\n     * Find an element by exact binding.\n     *\n     * @view\n     * <span>{{ person.name }}</span>\n     * <span ng-bind=\"person-email\"></span>\n     * <span>{{person_phone|uppercase}}</span>\n     *\n     * @example\n     * expect(element(by.exactBinding('person.name')).isPresent()).toBe(true);\n     * expect(element(by.exactBinding('person-email')).isPresent()).toBe(true);\n     * expect(element(by.exactBinding('person')).isPresent()).toBe(false);\n     * expect(element(by.exactBinding('person_phone')).isPresent()).toBe(true);\n     * expect(element(by.exactBinding('person_phone|uppercase')).isPresent()).toBe(true);\n     * expect(element(by.exactBinding('phone')).isPresent()).toBe(false);\n     *\n     * @param {string} bindingDescriptor\n     * @returns {ProtractorLocator} location strategy\n     */\n    exactBinding(bindingDescriptor) {\n        return {\n            findElementsOverride: (driver, using, rootSelector) => {\n                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findBindings, bindingDescriptor, true, using, rootSelector));\n            },\n            toString: () => {\n                return 'by.exactBinding(\"' + bindingDescriptor + '\")';\n            }\n        };\n    }\n    ;\n    /**\n     * Find an element by ng-model expression.\n     *\n     * @alias by.model(modelName)\n     * @view\n     * <input type=\"text\" ng-model=\"person.name\">\n     *\n     * @example\n     * var input = element(by.model('person.name'));\n     * input.sendKeys('123');\n     * expect(input.getAttribute('value')).toBe('Foo123');\n     *\n     * @param {string} model ng-model expression.\n     * @returns {ProtractorLocator} location strategy\n     */\n    model(model) {\n        return {\n            findElementsOverride: (driver, using, rootSelector) => {\n                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findByModel, model, using, rootSelector));\n            },\n            toString: () => {\n                return 'by.model(\"' + model + '\")';\n            }\n        };\n    }\n    ;\n    /**\n     * Find a button by text.\n     *\n     * @view\n     * <button>Save</button>\n     *\n     * @example\n     * element(by.buttonText('Save'));\n     *\n     * @param {string} searchText\n     * @returns {ProtractorLocator} location strategy\n     */\n    buttonText(searchText) {\n        return {\n            findElementsOverride: (driver, using, rootSelector) => {\n                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findByButtonText, searchText, using, rootSelector));\n            },\n            toString: () => {\n                return 'by.buttonText(\"' + searchText + '\")';\n            }\n        };\n    }\n    ;\n    /**\n     * Find a button by partial text.\n     *\n     * @view\n     * <button>Save my file</button>\n     *\n     * @example\n     * element(by.partialButtonText('Save'));\n     *\n     * @param {string} searchText\n     * @returns {ProtractorLocator} location strategy\n     */\n    partialButtonText(searchText) {\n        return {\n            findElementsOverride: (driver, using, rootSelector) => {\n                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findByPartialButtonText, searchText, using, rootSelector));\n            },\n            toString: () => {\n                return 'by.partialButtonText(\"' + searchText + '\")';\n            }\n        };\n    }\n    ;\n    // Generate either by.repeater or by.exactRepeater\n    byRepeaterInner(exact, repeatDescriptor) {\n        let name = 'by.' + (exact ? 'exactR' : 'r') + 'epeater';\n        return {\n            findElementsOverride: (driver, using, rootSelector) => {\n                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findAllRepeaterRows, repeatDescriptor, exact, using, rootSelector));\n            },\n            toString: () => {\n                return name + '(\"' + repeatDescriptor + '\")';\n            },\n            row: (index) => {\n                return {\n                    findElementsOverride: (driver, using, rootSelector) => {\n                        return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findRepeaterRows, repeatDescriptor, exact, index, using, rootSelector));\n                    },\n                    toString: () => {\n                        return name + '(' + repeatDescriptor + '\").row(\"' + index + '\")\"';\n                    },\n                    column: (binding) => {\n                        return {\n                            findElementsOverride: (driver, using, rootSelector) => {\n                                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findRepeaterElement, repeatDescriptor, exact, index, binding, using, rootSelector));\n                            },\n                            toString: () => {\n                                return name + '(\"' + repeatDescriptor + '\").row(\"' + index + '\").column(\"' +\n                                    binding + '\")';\n                            }\n                        };\n                    }\n                };\n            },\n            column: (binding) => {\n                return {\n                    findElementsOverride: (driver, using, rootSelector) => {\n                        return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findRepeaterColumn, repeatDescriptor, exact, binding, using, rootSelector));\n                    },\n                    toString: () => {\n                        return name + '(\"' + repeatDescriptor + '\").column(\"' + binding + '\")';\n                    },\n                    row: (index) => {\n                        return {\n                            findElementsOverride: (driver, using, rootSelector) => {\n                                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findRepeaterElement, repeatDescriptor, exact, index, binding, using, rootSelector));\n                            },\n                            toString: () => {\n                                return name + '(\"' + repeatDescriptor + '\").column(\"' + binding + '\").row(\"' +\n                                    index + '\")';\n                            }\n                        };\n                    }\n                };\n            }\n        };\n    }\n    /**\n     * Find elements inside an ng-repeat.\n     *\n     * @view\n     * <div ng-repeat=\"cat in pets\">\n     *   <span>{{cat.name}}</span>\n     *   <span>{{cat.age}}</span>\n     * </div>\n     *\n     * <div class=\"book-img\" ng-repeat-start=\"book in library\">\n     *   <span>{{$index}}</span>\n     * </div>\n     * <div class=\"book-info\" ng-repeat-end>\n     *   <h4>{{book.name}}</h4>\n     *   <p>{{book.blurb}}</p>\n     * </div>\n     *\n     * @example\n     * // Returns the DIV for the second cat.\n     * var secondCat = element(by.repeater('cat in pets').row(1));\n     *\n     * // Returns the SPAN for the first cat's name.\n     * var firstCatName = element(by.repeater('cat in pets').\n     *     row(0).column('cat.name'));\n     *\n     * // Returns a promise that resolves to an array of WebElements from a column\n     * var ages = element.all(\n     *     by.repeater('cat in pets').column('cat.age'));\n     *\n     * // Returns a promise that resolves to an array of WebElements containing\n     * // all top level elements repeated by the repeater. For 2 pets rows\n     * // resolves to an array of 2 elements.\n     * var rows = element.all(by.repeater('cat in pets'));\n     *\n     * // Returns a promise that resolves to an array of WebElements containing\n     * // all the elements with a binding to the book's name.\n     * var divs = element.all(by.repeater('book in library').column('book.name'));\n     *\n     * // Returns a promise that resolves to an array of WebElements containing\n     * // the DIVs for the second book.\n     * var bookInfo = element.all(by.repeater('book in library').row(1));\n     *\n     * // Returns the H4 for the first book's name.\n     * var firstBookName = element(by.repeater('book in library').\n     *     row(0).column('book.name'));\n     *\n     * // Returns a promise that resolves to an array of WebElements containing\n     * // all top level elements repeated by the repeater. For 2 books divs\n     * // resolves to an array of 4 elements.\n     * var divs = element.all(by.repeater('book in library'));\n     *\n     * @param {string} repeatDescriptor\n     * @returns {ProtractorLocator} location strategy\n     */\n    repeater(repeatDescriptor) {\n        return this.byRepeaterInner(false, repeatDescriptor);\n    }\n    /**\n     * Find an element by exact repeater.\n     *\n     * @view\n     * <li ng-repeat=\"person in peopleWithRedHair\"></li>\n     * <li ng-repeat=\"car in cars | orderBy:year\"></li>\n     *\n     * @example\n     * expect(element(by.exactRepeater('person in\n     * peopleWithRedHair')).isPresent())\n     *     .toBe(true);\n     * expect(element(by.exactRepeater('person in\n     * people')).isPresent()).toBe(false);\n     * expect(element(by.exactRepeater('car in cars')).isPresent()).toBe(true);\n     *\n     * @param {string} repeatDescriptor\n     * @returns {ProtractorLocator} location strategy\n     */\n    exactRepeater(repeatDescriptor) {\n        return this.byRepeaterInner(true, repeatDescriptor);\n    }\n    /**\n     * Find elements by CSS which contain a certain string.\n     *\n     * @view\n     * <ul>\n     *   <li class=\"pet\">Dog</li>\n     *   <li class=\"pet\">Cat</li>\n     * </ul>\n     *\n     * @example\n     * // Returns the li for the dog, but not cat.\n     * var dog = element(by.cssContainingText('.pet', 'Dog'));\n     *\n     * @param {string} cssSelector css selector\n     * @param {string} searchString text search\n     * @returns {ProtractorLocator} location strategy\n     */\n    cssContainingText(cssSelector, searchText) {\n        return {\n            findElementsOverride: (driver, using, rootSelector) => {\n                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findByCssContainingText, cssSelector, searchText, using, rootSelector));\n            },\n            toString: () => {\n                return 'by.cssContainingText(\"' + cssSelector + '\", \"' + searchText + '\")';\n            }\n        };\n    }\n    ;\n    /**\n     * Find an element by ng-options expression.\n     *\n     * @alias by.options(optionsDescriptor)\n     * @view\n     * <select ng-model=\"color\" ng-options=\"c for c in colors\">\n     *   <option value=\"0\" selected=\"selected\">red</option>\n     *   <option value=\"1\">green</option>\n     * </select>\n     *\n     * @example\n     * var allOptions = element.all(by.options('c for c in colors'));\n     * expect(allOptions.count()).toEqual(2);\n     * var firstOption = allOptions.first();\n     * expect(firstOption.getText()).toEqual('red');\n     *\n     * @param {string} optionsDescriptor ng-options expression.\n     * @returns {ProtractorLocator} location strategy\n     */\n    options(optionsDescriptor) {\n        return {\n            findElementsOverride: (driver, using, rootSelector) => {\n                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findByOptions, optionsDescriptor, using, rootSelector));\n            },\n            toString: () => {\n                return 'by.option(\"' + optionsDescriptor + '\")';\n            }\n        };\n    }\n    ;\n    /**\n     * Find an element by css selector within the Shadow DOM.\n     *\n     * @alias by.deepCss(selector)\n     * @view\n     * <div>\n     *   <span id=\"outerspan\">\n     *   <\"shadow tree\">\n     *     <span id=\"span1\"></span>\n     *     <\"shadow tree\">\n     *       <span id=\"span2\"></span>\n     *     </>\n     *   </>\n     * </div>\n     * @example\n     * var spans = element.all(by.deepCss('span'));\n     * expect(spans.count()).toEqual(3);\n     *\n     * @param {string} selector a css selector within the Shadow DOM.\n     * @returns {Locator} location strategy\n     */\n    deepCss(selector) {\n        // TODO(julie): syntax will change from /deep/ to >>> at some point.\n        // When that is supported, switch it here.\n        return selenium_webdriver_1.By.css('* /deep/ ' + selector);\n    }\n    ;\n}\nexports.ProtractorBy = ProtractorBy;\n//# sourceMappingURL=locators.js.map","/home/travis/build/npmtest/node-npmtest-protractor/protractor/built/clientsidescripts.js":"/**\n * All scripts to be run on the client via executeAsyncScript or\n * executeScript should be put here.\n *\n * NOTE: These scripts are transmitted over the wire as JavaScript text\n * constructed using their toString representation, and *cannot*\n * reference external variables.\n *\n * Some implementations seem to have issues with // comments, so use star-style\n * inside scripts.  (TODO: add issue number / example implementations\n * that caused the switch to avoid the // comments.)\n */\n\n// jshint browser: true\n// jshint shadow: true\n/* global angular */\nvar functions = {};\n\n///////////////////////////////////////////////////////\n////                                               ////\n////                    HELPERS                    ////\n////                                               ////\n///////////////////////////////////////////////////////\n\n\n/* Wraps a function up into a string with its helper functions so that it can\n * call those helper functions client side\n *\n * @param {function} fun The function to wrap up with its helpers\n * @param {...function} The helper functions.  Each function must be named\n *\n * @return {string} The string which, when executed, will invoke fun in such a\n *   way that it has access to its helper functions\n */\nfunction wrapWithHelpers(fun) {\n  var helpers = Array.prototype.slice.call(arguments, 1);\n  if (!helpers.length) {\n    return fun;\n  }\n  var FunClass = Function; // Get the linter to allow this eval\n  return new FunClass(\n      helpers.join(';') + String.fromCharCode(59) +\n      '  return (' + fun.toString() + ').apply(this, arguments);');\n}\n\n/* Tests if an ngRepeat matches a repeater\n *\n * @param {string} ngRepeat The ngRepeat to test\n * @param {string} repeater The repeater to test against\n * @param {boolean} exact If the ngRepeat expression needs to match the whole\n *   repeater (not counting any `track by ...` modifier) or if it just needs to\n *   match a substring\n * @return {boolean} If the ngRepeat matched the repeater\n */\nfunction repeaterMatch(ngRepeat, repeater, exact) {\n  if (exact) {\n    return ngRepeat.split(' track by ')[0].split(' as ')[0].split('|')[0].\n        split('=')[0].trim() == repeater;\n  } else {\n    return ngRepeat.indexOf(repeater) != -1;\n  }\n}\n\n/* Tries to find $$testability and possibly $injector for an ng1 app\n *\n * By default, doesn't care about $injector if it finds $$testability.  However,\n * these priorities can be reversed.\n *\n * @param {string=} selector The selector for the element with the injector.  If\n *   falsy, tries a variety of methods to find an injector\n * @param {boolean=} injectorPlease Prioritize finding an injector\n * @return {$$testability?: Testability, $injector?: Injector} Returns whatever\n *   ng1 app hooks it finds\n */\nfunction getNg1Hooks(selector, injectorPlease) {\n  function tryEl(el) {\n    try {\n      if (!injectorPlease && angular.getTestability) {\n        var $$testability = angular.getTestability(el);\n        if ($$testability) {\n          return {$$testability: $$testability};\n        }\n      } else {\n        var $injector = angular.element(el).injector();\n        if ($injector) {\n          return {$injector: $injector};\n        }\n      }\n    } catch(err) {} \n  }\n  function trySelector(selector) {\n    var els = document.querySelectorAll(selector);\n    for (var i = 0; i < els.length; i++) {\n      var elHooks = tryEl(els[i]);\n      if (elHooks) {\n        return elHooks;\n      }\n    }\n  }\n\n  if (selector) {\n    return trySelector(selector);\n  } else if (window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__) {\n    var $injector = window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__;\n    var $$testability = null;\n    try {\n      $$testability = $injector.get('$$testability');\n    } catch (e) {}\n    return {$injector: $injector, $$testability: $$testability};\n  } else {\n    return tryEl(document.body) ||\n        trySelector('[ng-app]') || trySelector('[ng\\\\:app]') ||\n        trySelector('[ng-controller]') || trySelector('[ng\\\\:controller]');\n  }\n}\n\n///////////////////////////////////////////////////////\n////                                               ////\n////                    SCRIPTS                    ////\n////                                               ////\n///////////////////////////////////////////////////////\n\n\n/**\n * Wait until Angular has finished rendering and has\n * no outstanding $http calls before continuing. The specific Angular app\n * is determined by the rootSelector.\n *\n * Asynchronous.\n *\n * @param {string} rootSelector The selector housing an ng-app\n * @param {function(string)} callback callback. If a failure occurs, it will\n *     be passed as a parameter.\n */\nfunctions.waitForAngular = function(rootSelector, callback) {\n  try {\n    if (window.angular && !(window.angular.version &&\n          window.angular.version.major > 1)) {\n      /* ng1 */\n      var hooks = getNg1Hooks(rootSelector);\n      if (hooks.$$testability) {\n        hooks.$$testability.whenStable(callback);\n      } else if (hooks.$injector) {\n        hooks.$injector.get('$browser').\n            notifyWhenNoOutstandingRequests(callback);\n      } else if (!!rootSelector) {\n        throw new Error('Could not automatically find injector on page: \"' +\n            window.location.toString() + '\".  Consider using config.rootEl');\n      } else {\n        throw new Error('root element (' + rootSelector + ') has no injector.' +\n           ' this may mean it is not inside ng-app.');\n      }\n    } else if (rootSelector && window.getAngularTestability) {\n      var el = document.querySelector(rootSelector);\n      window.getAngularTestability(el).whenStable(callback);\n    } else if (window.getAllAngularTestabilities) {\n      var testabilities = window.getAllAngularTestabilities();\n      var count = testabilities.length;\n      var decrement = function() {\n        count--;\n        if (count === 0) {\n          callback();\n        }\n      };\n      testabilities.forEach(function(testability) {\n        testability.whenStable(decrement);\n      });\n    } else if (!window.angular) {\n      throw new Error('window.angular is undefined.  This could be either ' +\n          'because this is a non-angular page or because your test involves ' +\n          'client-side navigation, which can interfere with Protractor\\'s ' +\n          'bootstrapping.  See http://git.io/v4gXM for details');\n    } else if (window.angular.version >= 2) {\n      throw new Error('You appear to be using angular, but window.' +\n          'getAngularTestability was never set.  This may be due to bad ' +\n          'obfuscation.');\n    } else {\n      throw new Error('Cannot get testability API for unknown angular ' +\n          'version \"' + window.angular.version + '\"');\n    }\n  } catch (err) {\n    callback(err.message);\n  }\n};\n\n/**\n * Find a list of elements in the page by their angular binding.\n *\n * @param {string} binding The binding, e.g. {{cat.name}}.\n * @param {boolean} exactMatch Whether the binding needs to be matched exactly\n * @param {Element} using The scope of the search.\n * @param {string} rootSelector The selector to use for the root app element.\n *\n * @return {Array.<Element>} The elements containing the binding.\n */\nfunctions.findBindings = function(binding, exactMatch, using, rootSelector) {\n  using = using || document;\n  if (angular.getTestability) {\n    return getNg1Hooks(rootSelector).$$testability.\n        findBindings(using, binding, exactMatch);\n  }\n  var bindings = using.getElementsByClassName('ng-binding');\n  var matches = [];\n  for (var i = 0; i < bindings.length; ++i) {\n    var dataBinding = angular.element(bindings[i]).data('$binding');\n    if (dataBinding) {\n      var bindingName = dataBinding.exp || dataBinding[0].exp || dataBinding;\n      if (exactMatch) {\n        var matcher = new RegExp('({|\\\\s|^|\\\\|)' +\n            /* See http://stackoverflow.com/q/3561711 */\n            binding.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&') +\n            '(}|\\\\s|$|\\\\|)');\n        if (matcher.test(bindingName)) {\n          matches.push(bindings[i]);\n        }\n      } else {\n        if (bindingName.indexOf(binding) != -1) {\n          matches.push(bindings[i]);\n        }\n      }\n\n    }\n  }\n  return matches; /* Return the whole array for webdriver.findElements. */\n};\n\n/**\n * Find an array of elements matching a row within an ng-repeat.\n * Always returns an array of only one element for plain old ng-repeat.\n * Returns an array of all the elements in one segment for ng-repeat-start.\n *\n * @param {string} repeater The text of the repeater, e.g. 'cat in cats'.\n * @param {boolean} exact Whether the repeater needs to be matched exactly\n * @param {number} index The row index.\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} The row of the repeater, or an array of elements\n *     in the first row in the case of ng-repeat-start.\n */\nfunction findRepeaterRows(repeater, exact, index, using) {\n  using = using || document;\n\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n  var rows = [];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        rows.push(repeatElems[i]);\n      }\n    }\n  }\n  /* multiRows is an array of arrays, where each inner array contains\n     one row of elements. */\n  var multiRows = [];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat-start';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        var elem = repeatElems[i];\n        var row = [];\n        while (elem.nodeType != 8 ||\n            !repeaterMatch(elem.nodeValue, repeater)) {\n          if (elem.nodeType == 1) {\n            row.push(elem);\n          }\n          elem = elem.nextSibling;\n        }\n        multiRows.push(row);\n      }\n    }\n  }\n  var row = rows[index] || [], multiRow = multiRows[index] || [];\n  return [].concat(row, multiRow);\n}\nfunctions.findRepeaterRows = wrapWithHelpers(findRepeaterRows, repeaterMatch); \n\n /**\n * Find all rows of an ng-repeat.\n *\n * @param {string} repeater The text of the repeater, e.g. 'cat in cats'.\n * @param {boolean} exact Whether the repeater needs to be matched exactly\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} All rows of the repeater.\n */\nfunction findAllRepeaterRows(repeater, exact, using) {\n  using = using || document;\n\n  var rows = [];\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        rows.push(repeatElems[i]);\n      }\n    }\n  }\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat-start';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        var elem = repeatElems[i];\n        while (elem.nodeType != 8 ||\n            !repeaterMatch(elem.nodeValue, repeater)) {\n          if (elem.nodeType == 1) {\n            rows.push(elem);\n          }\n          elem = elem.nextSibling;\n        }\n      }\n    }\n  }\n  return rows;\n}\nfunctions.findAllRepeaterRows = wrapWithHelpers(findAllRepeaterRows, repeaterMatch);\n\n/**\n * Find an element within an ng-repeat by its row and column.\n *\n * @param {string} repeater The text of the repeater, e.g. 'cat in cats'.\n * @param {boolean} exact Whether the repeater needs to be matched exactly\n * @param {number} index The row index.\n * @param {string} binding The column binding, e.g. '{{cat.name}}'.\n * @param {Element} using The scope of the search.\n * @param {string} rootSelector The selector to use for the root app element.\n *\n * @return {Array.<Element>} The element in an array.\n */\nfunction findRepeaterElement(repeater, exact, index, binding, using, rootSelector) {\n  var matches = [];\n  using = using || document;\n\n  var rows = [];\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        rows.push(repeatElems[i]);\n      }\n    }\n  }\n  /* multiRows is an array of arrays, where each inner array contains\n     one row of elements. */\n  var multiRows = [];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat-start';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        var elem = repeatElems[i];\n        var row = [];\n        while (elem.nodeType != 8 || (elem.nodeValue &&\n            !repeaterMatch(elem.nodeValue, repeater))) {\n          if (elem.nodeType == 1) {\n            row.push(elem);\n          }\n          elem = elem.nextSibling;\n        }\n        multiRows.push(row);\n      }\n    }\n  }\n  var row = rows[index];\n  var multiRow = multiRows[index];\n  var bindings = [];\n  if (row) {\n    if (angular.getTestability) {\n      matches.push.apply(\n          matches,\n          getNg1Hooks(rootSelector).$$testability.findBindings(row, binding));\n    } else {\n      if (row.className.indexOf('ng-binding') != -1) {\n        bindings.push(row);\n      }\n      var childBindings = row.getElementsByClassName('ng-binding');\n      for (var i = 0; i < childBindings.length; ++i) {\n        bindings.push(childBindings[i]);\n      }\n    }\n  }\n  if (multiRow) {\n    for (var i = 0; i < multiRow.length; ++i) {\n      var rowElem = multiRow[i];\n      if (angular.getTestability) {\n        matches.push.apply(\n            matches,\n            getNg1Hooks(rootSelector).$$testability.findBindings(rowElem,\n                binding));\n      } else {\n        if (rowElem.className.indexOf('ng-binding') != -1) {\n          bindings.push(rowElem);\n        }\n        var childBindings = rowElem.getElementsByClassName('ng-binding');\n        for (var j = 0; j < childBindings.length; ++j) {\n          bindings.push(childBindings[j]);\n        }\n      }\n    }\n  }\n  for (var i = 0; i < bindings.length; ++i) {\n    var dataBinding = angular.element(bindings[i]).data('$binding');\n    if (dataBinding) {\n      var bindingName = dataBinding.exp || dataBinding[0].exp || dataBinding;\n      if (bindingName.indexOf(binding) != -1) {\n        matches.push(bindings[i]);\n      }\n    }\n  }\n  return matches;\n}\nfunctions.findRepeaterElement =\n    wrapWithHelpers(findRepeaterElement, repeaterMatch, getNg1Hooks);\n\n/**\n * Find the elements in a column of an ng-repeat.\n *\n * @param {string} repeater The text of the repeater, e.g. 'cat in cats'.\n * @param {boolean} exact Whether the repeater needs to be matched exactly\n * @param {string} binding The column binding, e.g. '{{cat.name}}'.\n * @param {Element} using The scope of the search.\n * @param {string} rootSelector The selector to use for the root app element.\n *\n * @return {Array.<Element>} The elements in the column.\n */\nfunction findRepeaterColumn(repeater, exact, binding, using, rootSelector) {\n  var matches = [];\n  using = using || document;\n\n  var rows = [];\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        rows.push(repeatElems[i]);\n      }\n    }\n  }\n  /* multiRows is an array of arrays, where each inner array contains\n     one row of elements. */\n  var multiRows = [];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat-start';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        var elem = repeatElems[i];\n        var row = [];\n        while (elem.nodeType != 8 || (elem.nodeValue &&\n            !repeaterMatch(elem.nodeValue, repeater))) {\n          if (elem.nodeType == 1) {\n            row.push(elem);\n          }\n          elem = elem.nextSibling;\n        }\n        multiRows.push(row);\n      }\n    }\n  }\n  var bindings = [];\n  for (var i = 0; i < rows.length; ++i) {\n    if (angular.getTestability) {\n      matches.push.apply(\n          matches,\n          getNg1Hooks(rootSelector).$$testability.findBindings(rows[i],\n              binding));\n    } else {\n      if (rows[i].className.indexOf('ng-binding') != -1) {\n        bindings.push(rows[i]);\n      }\n      var childBindings = rows[i].getElementsByClassName('ng-binding');\n      for (var k = 0; k < childBindings.length; ++k) {\n        bindings.push(childBindings[k]);\n      }\n    }\n  }\n  for (var i = 0; i < multiRows.length; ++i) {\n    for (var j = 0; j < multiRows[i].length; ++j) {\n      if (angular.getTestability) {\n        matches.push.apply(\n            matches,\n            getNg1Hooks(rootSelector).$$testability.findBindings(\n                multiRows[i][j], binding));\n      } else {\n        var elem = multiRows[i][j];\n        if (elem.className.indexOf('ng-binding') != -1) {\n          bindings.push(elem);\n        }\n        var childBindings = elem.getElementsByClassName('ng-binding');\n        for (var k = 0; k < childBindings.length; ++k) {\n          bindings.push(childBindings[k]);\n        }\n      }\n    }\n  }\n  for (var j = 0; j < bindings.length; ++j) {\n    var dataBinding = angular.element(bindings[j]).data('$binding');\n    if (dataBinding) {\n      var bindingName = dataBinding.exp || dataBinding[0].exp || dataBinding;\n      if (bindingName.indexOf(binding) != -1) {\n        matches.push(bindings[j]);\n      }\n    }\n  }\n  return matches;\n}\nfunctions.findRepeaterColumn =\n    wrapWithHelpers(findRepeaterColumn, repeaterMatch, getNg1Hooks);\n\n/**\n * Find elements by model name.\n *\n * @param {string} model The model name.\n * @param {Element} using The scope of the search.\n * @param {string} rootSelector The selector to use for the root app element.\n *\n * @return {Array.<Element>} The matching elements.\n */\nfunctions.findByModel = function(model, using, rootSelector) {\n  using = using || document;\n\n  if (angular.getTestability) {\n    return getNg1Hooks(rootSelector).$$testability.\n        findModels(using, model, true);\n  }\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var selector = '[' + prefixes[p] + 'model=\"' + model + '\"]';\n    var elements = using.querySelectorAll(selector);\n    if (elements.length) {\n      return elements;\n    }\n  }\n};\n\n/**\n * Find elements by options.\n *\n * @param {string} optionsDescriptor The descriptor for the option\n *     (i.e. fruit for fruit in fruits).\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} The matching elements.\n */\nfunctions.findByOptions = function(optionsDescriptor, using) {\n  using = using || document;\n\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var selector = '[' + prefixes[p] + 'options=\"' + optionsDescriptor + '\"] option';\n    var elements = using.querySelectorAll(selector);\n    if (elements.length) {\n      return elements;\n    }\n  }\n};\n\n/**\n * Find buttons by textual content.\n *\n * @param {string} searchText The exact text to match.\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} The matching elements.\n */\nfunctions.findByButtonText = function(searchText, using) {\n  using = using || document;\n\n  var elements = using.querySelectorAll('button, input[type=\"button\"], input[type=\"submit\"]');\n  var matches = [];\n  for (var i = 0; i < elements.length; ++i) {\n    var element = elements[i];\n    var elementText;\n    if (element.tagName.toLowerCase() == 'button') {\n      elementText = element.textContent || element.innerText || '';\n    } else {\n      elementText = element.value;\n    }\n    if (elementText.trim() === searchText) {\n      matches.push(element);\n    }\n  }\n\n  return matches;\n};\n\n/**\n * Find buttons by textual content.\n *\n * @param {string} searchText The exact text to match.\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} The matching elements.\n */\nfunctions.findByPartialButtonText = function(searchText, using) {\n  using = using || document;\n\n  var elements = using.querySelectorAll('button, input[type=\"button\"], input[type=\"submit\"]');\n  var matches = [];\n  for (var i = 0; i < elements.length; ++i) {\n    var element = elements[i];\n    var elementText;\n    if (element.tagName.toLowerCase() == 'button') {\n      elementText = element.textContent || element.innerText || '';\n    } else {\n      elementText = element.value;\n    }\n    if (elementText.indexOf(searchText) > -1) {\n      matches.push(element);\n    }\n  }\n\n  return matches;\n};\n\n/**\n * Find elements by css selector and textual content.\n *\n * @param {string} cssSelector The css selector to match.\n * @param {string} searchText The exact text to match.\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} An array of matching elements.\n */\nfunctions.findByCssContainingText = function(cssSelector, searchText, using) {\n  using = using || document;\n\n  var elements = using.querySelectorAll(cssSelector);\n  var matches = [];\n  for (var i = 0; i < elements.length; ++i) {\n    var element = elements[i];\n    var elementText = element.textContent || element.innerText || '';\n    if (elementText.indexOf(searchText) > -1) {\n      matches.push(element);\n    }\n  }\n  return matches;\n};\n\n/**\n * Tests whether the angular global variable is present on a page. Retries\n * in case the page is just loading slowly.\n *\n * Asynchronous.\n *\n * @param {number} attempts Number of times to retry.\n * @param {boolean} ng12Hybrid Flag set if app is a hybrid of angular 1 and 2\n * @param {function({version: ?number, message: ?string})} asyncCallback callback\n *\n */\nfunctions.testForAngular = function(attempts, ng12Hybrid, asyncCallback) {\n  var callback = function(args) {\n    setTimeout(function() {\n      asyncCallback(args);\n    }, 0);\n  };\n  var definitelyNg1 = !!ng12Hybrid;\n  var definitelyNg2OrNewer = false;\n  var check = function(n) {\n    try {\n      /* Figure out which version of angular we're waiting on */\n      if (!definitelyNg1 && !definitelyNg2OrNewer) {\n        if (window.angular && !(window.angular.version && window.angular.version.major > 1)) {\n          definitelyNg1 = true;\n        } else if (window.getAllAngularTestabilities) {\n          definitelyNg2OrNewer = true;\n        }\n      }\n      /* See if our version of angular is ready */\n      if (definitelyNg1) {\n        if (window.angular && window.angular.resumeBootstrap) {\n          return callback({ver: 1});\n        }\n      } else if (definitelyNg2OrNewer) {\n        if (true /* ng2 has no resumeBootstrap() */) {\n          return callback({ver: 2});\n        }\n      }\n      /* Try again (or fail) */\n      if (n < 1) {\n        if (definitelyNg1 && window.angular) {\n          callback({message: 'angular never provided resumeBootstrap'});\n        } else if (ng12Hybrid && !window.angular) { \n          callback({message: 'angular 1 never loaded' +\n              window.getAllAngularTestabilities ? ' (are you sure this app ' +\n              'uses ngUpgrade?  Try un-setting ng12Hybrid)' : ''});\n        } else {\n          callback({message: 'retries looking for angular exceeded'});\n        }\n      } else {\n        window.setTimeout(function() {check(n - 1);}, 1000);\n      }\n    } catch (e) {\n      callback({message: e});\n    }\n  };\n  check(attempts);\n};\n\n/**\n * Evalute an Angular expression in the context of a given element.\n *\n * @param {Element} element The element in whose scope to evaluate.\n * @param {string} expression The expression to evaluate.\n *\n * @return {?Object} The result of the evaluation.\n */\nfunctions.evaluate = function(element, expression) {\n  return angular.element(element).scope().$eval(expression);\n};\n\nfunctions.allowAnimations = function(element, value) {\n  var ngElement = angular.element(element);\n  if (ngElement.allowAnimations) {\n    // AngularDart: $testability API.\n    return ngElement.allowAnimations(value);\n  } else {\n    // AngularJS\n    var enabledFn = ngElement.injector().get('$animate').enabled;\n    return (value == null) ? enabledFn() : enabledFn(value);\n  }\n};\n\n/**\n * Return the current url using $location.absUrl().\n *\n * @param {string} selector The selector housing an ng-app\n */\nfunctions.getLocationAbsUrl = function(selector) {\n  var hooks = getNg1Hooks(selector);\n  if (angular.getTestability) {\n    return hooks.$$testability.getLocation();\n  }\n  return hooks.$injector.get('$location').absUrl();\n};\n\n/**\n * Browse to another page using in-page navigation.\n *\n * @param {string} selector The selector housing an ng-app\n * @param {string} url In page URL using the same syntax as $location.url(),\n *     /path?search=a&b=c#hash\n */\nfunctions.setLocation = function(selector, url) {\n  var hooks = getNg1Hooks(selector);\n  if (angular.getTestability) {\n    return hooks.$$testability.setLocation(url);\n  }\n  var $injector = hooks.$injector;\n  var $location = $injector.get('$location');\n  var $rootScope = $injector.get('$rootScope');\n\n  if (url !== $location.url()) {\n    $location.url(url);\n    $rootScope.$digest();\n  }\n};\n\n/**\n * Retrieve the pending $http requests.\n *\n * @param {string} selector The selector housing an ng-app\n * @return {!Array<!Object>} An array of pending http requests.\n */\nfunctions.getPendingHttpRequests = function(selector) {\n  var hooks = getNg1Hooks(selector, true);\n  var $http = hooks.$injector.get('$http');\n  return $http.pendingRequests;\n};\n\n['waitForAngular', 'findBindings', 'findByModel', 'getLocationAbsUrl',\n  'setLocation', 'getPendingHttpRequests'].forEach(function(funName) {\n    functions[funName] = wrapWithHelpers(functions[funName], getNg1Hooks);\n});\n\n/* Publish all the functions as strings to pass to WebDriver's\n * exec[Async]Script.  In addition, also include a script that will\n * install all the functions on window (for debugging.)\n *\n * We also wrap any exceptions thrown by a clientSideScripts function\n * that is not an instance of the Error type into an Error type.  If we\n * don't do so, then the resulting stack trace is completely unhelpful\n * and the exception message is just \"unknown error.\"  These types of\n * exceptions are the common case for dart2js code.  This wrapping gives\n * us the Dart stack trace and exception message.\n */\nvar util = require('util');\nvar scriptsList = [];\nvar scriptFmt = (\n    'try { return (%s).apply(this, arguments); }\\n' +\n    'catch(e) { throw (e instanceof Error) ? e : new Error(e); }');\nfor (var fnName in functions) {\n  if (functions.hasOwnProperty(fnName)) {\n    exports[fnName] = util.format(scriptFmt, functions[fnName]);\n    scriptsList.push(util.format('%s: %s', fnName, functions[fnName]));\n  }\n}\n\nexports.installInBrowser = (util.format(\n    'window.clientSideScripts = {%s};', scriptsList.join(', ')));\n\n/**\n * Automatically installed by Protractor when a page is loaded, this\n * default mock module decorates $timeout to keep track of any\n * outstanding timeouts.\n *\n * @param {boolean} trackOutstandingTimeouts\n */\nexports.protractorBaseModuleFn = function(trackOutstandingTimeouts) {\n  var ngMod = angular.module('protractorBaseModule_', []).config([\n    '$compileProvider',\n    function($compileProvider) {\n      if ($compileProvider.debugInfoEnabled) {\n        $compileProvider.debugInfoEnabled(true);\n      }\n    }\n  ]);\n  if (trackOutstandingTimeouts) {\n    ngMod.config([\n      '$provide',\n      function ($provide) {\n        $provide.decorator('$timeout', [\n          '$delegate',\n          function ($delegate) {\n            var $timeout = $delegate;\n\n            var taskId = 0;\n\n            if (!window['NG_PENDING_TIMEOUTS']) {\n              window['NG_PENDING_TIMEOUTS'] = {};\n            }\n\n            var extendedTimeout= function() {\n              var args = Array.prototype.slice.call(arguments);\n              if (typeof(args[0]) !== 'function') {\n                return $timeout.apply(null, args);\n              }\n\n              taskId++;\n              var fn = args[0];\n              window['NG_PENDING_TIMEOUTS'][taskId] =\n                  fn.toString();\n              var wrappedFn = (function(taskId_) {\n                return function() {\n                  delete window['NG_PENDING_TIMEOUTS'][taskId_];\n                  return fn.apply(null, arguments);\n                };\n              })(taskId);\n              args[0] = wrappedFn;\n\n              var promise = $timeout.apply(null, args);\n              promise.ptorTaskId_ = taskId;\n              return promise;\n            };\n\n            extendedTimeout.cancel = function() {\n              var taskId_ = arguments[0] && arguments[0].ptorTaskId_;\n              if (taskId_) {\n                delete window['NG_PENDING_TIMEOUTS'][taskId_];\n              }\n              return $timeout.cancel.apply($timeout, arguments);\n            };\n\n            return extendedTimeout;\n          }\n        ]);\n      }\n    ]);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-protractor/protractor/built/util.js":"\"use strict\";\nconst path_1 = require('path');\nconst q_1 = require('q');\nconst selenium_webdriver_1 = require('selenium-webdriver');\nlet STACK_SUBSTRINGS_TO_FILTER = [\n    'node_modules/jasmine/', 'node_modules/selenium-webdriver', 'at Module.', 'at Object.Module.',\n    'at Function.Module', '(timers.js:', 'jasminewd2/index.js', 'protractor/lib/'\n];\n/**\n * Utility function that filters a stack trace to be more readable. It removes\n * Jasmine test frames and webdriver promise resolution.\n * @param {string} text Original stack trace.\n * @return {string}\n */\nfunction filterStackTrace(text) {\n    if (!text) {\n        return text;\n    }\n    let lines = text.split(/\\n/).filter((line) => {\n        for (let filter of STACK_SUBSTRINGS_TO_FILTER) {\n            if (line.indexOf(filter) !== -1) {\n                return false;\n            }\n        }\n        return true;\n    });\n    return lines.join('\\n');\n}\nexports.filterStackTrace = filterStackTrace;\n/**\n * Internal helper for abstraction of polymorphic filenameOrFn properties.\n * @param {object} filenameOrFn The filename or function that we will execute.\n * @param {Array.<object>}} args The args to pass into filenameOrFn.\n * @return {q.Promise} A promise that will resolve when filenameOrFn completes.\n */\nfunction runFilenameOrFn_(configDir, filenameOrFn, args) {\n    return q_1.Promise((resolvePromise) => {\n        if (filenameOrFn && !(typeof filenameOrFn === 'string' || typeof filenameOrFn === 'function')) {\n            throw new Error('filenameOrFn must be a string or function');\n        }\n        if (typeof filenameOrFn === 'string') {\n            filenameOrFn = require(path_1.resolve(configDir, filenameOrFn));\n        }\n        if (typeof filenameOrFn === 'function') {\n            let results = q_1.when(filenameOrFn.apply(null, args), null, (err) => {\n                if (typeof err === 'string') {\n                    err = new Error(err);\n                }\n                else {\n                    err = err;\n                    if (!err.stack) {\n                        err.stack = new Error().stack;\n                    }\n                }\n                err.stack = exports.filterStackTrace(err.stack);\n                throw err;\n            });\n            resolvePromise(results);\n        }\n        else {\n            resolvePromise(undefined);\n        }\n    });\n}\nexports.runFilenameOrFn_ = runFilenameOrFn_;\n/**\n * Joins two logs of test results, each following the format of <framework>.run\n * @param {object} log1\n * @param {object} log2\n * @return {object} The joined log\n */\nfunction joinTestLogs(log1, log2) {\n    return {\n        failedCount: log1.failedCount + log2.failedCount,\n        specResults: (log1.specResults || []).concat(log2.specResults || [])\n    };\n}\nexports.joinTestLogs = joinTestLogs;\n/**\n * Returns false if an error indicates a missing or stale element, re-throws\n * the error otherwise\n *\n * @param {*} The error to check\n * @throws {*} The error it was passed if it doesn't indicate a missing or stale\n *   element\n * @return {boolean} false, if it doesn't re-throw the error\n */\nfunction falseIfMissing(error) {\n    if ((error instanceof selenium_webdriver_1.error.NoSuchElementError) ||\n        (error instanceof selenium_webdriver_1.error.StaleElementReferenceError)) {\n        return false;\n    }\n    else {\n        throw error;\n    }\n}\nexports.falseIfMissing = falseIfMissing;\n/**\n * Return a boolean given boolean value.\n *\n * @param {boolean} value\n * @returns {boolean} given value\n */\nfunction passBoolean(value) {\n    return value;\n}\nexports.passBoolean = passBoolean;\n//# sourceMappingURL=util.js.map","/home/travis/build/npmtest/node-npmtest-protractor/protractor/built/expectedConditions.js":"\"use strict\";\nconst selenium_webdriver_1 = require('selenium-webdriver');\nconst util_1 = require('./util');\n/**\n * Represents a library of canned expected conditions that are useful for\n * protractor, especially when dealing with non-angular apps.\n *\n * Each condition returns a function that evaluates to a promise. You may mix\n * multiple conditions using `and`, `or`, and/or `not`. You may also\n * mix these conditions with any other conditions that you write.\n *\n * See ExpectedCondition Class in Selenium WebDriver codebase.\n * http://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html\n *\n *\n * @example\n * var EC = protractor.ExpectedConditions;\n * var button = $('#xyz');\n * var isClickable = EC.elementToBeClickable(button);\n *\n * browser.get(URL);\n * browser.wait(isClickable, 5000); //wait for an element to become clickable\n * button.click();\n *\n * // You can define your own expected condition, which is a function that\n * // takes no parameter and evaluates to a promise of a boolean.\n * var urlChanged = function() {\n *   return browser.getCurrentUrl().then(function(url) {\n *     return url === 'http://www.angularjs.org';\n *   });\n * };\n *\n * // You can customize the conditions with EC.and, EC.or, and EC.not.\n * // Here's a condition to wait for url to change, $('abc') element to contain\n * // text 'bar', and button becomes clickable.\n * var condition = EC.and(urlChanged, EC.textToBePresentInElement($('abc'),\n * 'bar'), isClickable);\n * browser.get(URL);\n * browser.wait(condition, 5000); //wait for condition to be true.\n * button.click();\n *\n * @alias ExpectedConditions\n * @constructor\n */\nclass ProtractorExpectedConditions {\n    constructor(browser) {\n        this.browser = browser;\n    }\n    ;\n    /**\n     * Negates the result of a promise.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * var titleIsNotFoo = EC.not(EC.titleIs('Foo'));\n     * // Waits for title to become something besides 'foo'.\n     * browser.wait(titleIsNotFoo, 5000);\n     *\n     * @alias ExpectedConditions.not\n     * @param {!function} expectedCondition\n     *\n     * @returns {!function} An expected condition that returns the negated value.\n     */\n    not(expectedCondition) {\n        return () => {\n            return expectedCondition().then((bool) => {\n                return !bool;\n            });\n        };\n    }\n    /**\n     * Helper function that is equivalent to the logical_and if defaultRet==true,\n     * or logical_or if defaultRet==false\n     *\n     * @private\n     * @param {boolean} defaultRet\n     * @param {Array.<Function>} fns An array of expected conditions to chain.\n     *\n     * @returns {!function} An expected condition that returns a promise which\n     *     evaluates to the result of the logical chain.\n     */\n    logicalChain_(defaultRet, fns) {\n        let self = this;\n        return () => {\n            if (fns.length === 0) {\n                return defaultRet;\n            }\n            let fn = fns[0];\n            return fn().then((bool) => {\n                if (bool === defaultRet) {\n                    return self.logicalChain_(defaultRet, fns.slice(1))();\n                }\n                else {\n                    return !defaultRet;\n                }\n            });\n        };\n    }\n    /**\n     * Chain a number of expected conditions using logical_and, short circuiting\n     * at the first expected condition that evaluates to false.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * var titleContainsFoo = EC.titleContains('Foo');\n     * var titleIsNotFooBar = EC.not(EC.titleIs('FooBar'));\n     * // Waits for title to contain 'Foo', but is not 'FooBar'\n     * browser.wait(EC.and(titleContainsFoo, titleIsNotFooBar), 5000);\n     *\n     * @alias ExpectedConditions.and\n     * @param {Array.<Function>} fns An array of expected conditions to 'and'\n     * together.\n     *\n     * @returns {!function} An expected condition that returns a promise which\n     *     evaluates to the result of the logical and.\n     */\n    and(...args) {\n        return this.logicalChain_(true, args);\n    }\n    /**\n     * Chain a number of expected conditions using logical_or, short circuiting\n     * at the first expected condition that evaluates to true.\n     *\n     * @alias ExpectedConditions.or\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * var titleContainsFoo = EC.titleContains('Foo');\n     * var titleContainsBar = EC.titleContains('Bar');\n     * // Waits for title to contain either 'Foo' or 'Bar'\n     * browser.wait(EC.or(titleContainsFoo, titleContainsBar), 5000);\n     *\n     * @param {Array.<Function>} fns An array of expected conditions to 'or'\n     * together.\n     *\n     * @returns {!function} An expected condition that returns a promise which\n     *     evaluates to the result of the logical or.\n     */\n    or(...args) {\n        return this.logicalChain_(false, args);\n    }\n    /**\n     * Expect an alert to be present.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for an alert pops up.\n     * browser.wait(EC.alertIsPresent(), 5000);\n     *\n     * @alias ExpectedConditions.alertIsPresent\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether an alert is present.\n     */\n    alertIsPresent() {\n        return () => {\n            return this.browser.driver.switchTo().alert().then(() => {\n                return true;\n            }, (err) => {\n                if (err instanceof selenium_webdriver_1.error.NoSuchAlertError) {\n                    return false;\n                }\n                else {\n                    throw err;\n                }\n            });\n        };\n    }\n    /**\n     * An Expectation for checking an element is visible and enabled such that you\n     * can click it.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to be clickable.\n     * browser.wait(EC.elementToBeClickable($('#abc')), 5000);\n     *\n     * @alias ExpectedConditions.elementToBeClickable\n     * @param {!ElementFinder} elementFinder The element to check\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the element is clickable.\n     */\n    elementToBeClickable(elementFinder) {\n        return this.and(this.visibilityOf(elementFinder), () => {\n            return elementFinder.isEnabled().then(util_1.passBoolean, util_1.falseIfMissing);\n        });\n    }\n    /**\n     * An expectation for checking if the given text is present in the\n     * element. Returns false if the elementFinder does not find an element.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to contain the text 'foo'.\n     * browser.wait(EC.textToBePresentInElement($('#abc'), 'foo'), 5000);\n     *\n     * @alias ExpectedConditions.textToBePresentInElement\n     * @param {!ElementFinder} elementFinder The element to check\n     * @param {!string} text The text to verify against\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the text is present in the element.\n     */\n    textToBePresentInElement(elementFinder, text) {\n        let hasText = () => {\n            return elementFinder.getText().then((actualText) => {\n                // MSEdge does not properly remove newlines, which causes false\n                // negatives\n                return actualText.replace(/\\r?\\n|\\r/g, '').indexOf(text) > -1;\n            }, util_1.falseIfMissing);\n        };\n        return this.and(this.presenceOf(elementFinder), hasText);\n    }\n    /**\n     * An expectation for checking if the given text is present in the element’s\n     * value. Returns false if the elementFinder does not find an element.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'myInput' to contain the input 'foo'.\n     * browser.wait(EC.textToBePresentInElementValue($('#myInput'), 'foo'), 5000);\n     *\n     * @alias ExpectedConditions.textToBePresentInElement\n     * @param {!ElementFinder} elementFinder The element to check\n     * @param {!string} text The text to verify against\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the text is present in the element's value.\n     */\n    textToBePresentInElementValue(elementFinder, text) {\n        let hasText = () => {\n            return elementFinder.getAttribute('value').then((actualText) => {\n                return actualText.indexOf(text) > -1;\n            }, util_1.falseIfMissing);\n        };\n        return this.and(this.presenceOf(elementFinder), hasText);\n    }\n    /**\n     * An expectation for checking that the title contains a case-sensitive\n     * substring.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the title to contain 'foo'.\n     * browser.wait(EC.titleContains('foo'), 5000);\n     *\n     * @alias ExpectedConditions.titleContains\n     * @param {!string} title The fragment of title expected\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the title contains the string.\n     */\n    titleContains(title) {\n        return () => {\n            return this.browser.driver.getTitle().then((actualTitle) => {\n                return actualTitle.indexOf(title) > -1;\n            });\n        };\n    }\n    /**\n     * An expectation for checking the title of a page.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the title to be 'foo'.\n     * browser.wait(EC.titleIs('foo'), 5000);\n     *\n     * @alias ExpectedConditions.titleIs\n     * @param {!string} title The expected title, which must be an exact match.\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the title equals the string.\n     */\n    titleIs(title) {\n        return () => {\n            return this.browser.driver.getTitle().then((actualTitle) => {\n                return actualTitle === title;\n            });\n        };\n    }\n    /**\n     * An expectation for checking that the URL contains a case-sensitive\n     * substring.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the URL to contain 'foo'.\n     * browser.wait(EC.urlContains('foo'), 5000);\n     *\n     * @alias ExpectedConditions.urlContains\n     * @param {!string} url The fragment of URL expected\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the URL contains the string.\n     */\n    urlContains(url) {\n        return () => {\n            return this.browser.driver.getCurrentUrl().then((actualUrl) => {\n                return actualUrl.indexOf(url) > -1;\n            });\n        };\n    }\n    /**\n     * An expectation for checking the URL of a page.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the URL to be 'foo'.\n     * browser.wait(EC.urlIs('foo'), 5000);\n     *\n     * @alias ExpectedConditions.urlIs\n     * @param {!string} url The expected URL, which must be an exact match.\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the url equals the string.\n     */\n    urlIs(url) {\n        return () => {\n            return this.browser.driver.getCurrentUrl().then((actualUrl) => {\n                return actualUrl === url;\n            });\n        };\n    }\n    /**\n     * An expectation for checking that an element is present on the DOM\n     * of a page. This does not necessarily mean that the element is visible.\n     * This is the opposite of 'stalenessOf'.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to be present on the dom.\n     * browser.wait(EC.presenceOf($('#abc')), 5000);\n     *\n     * @alias ExpectedConditions.presenceOf\n     * @param {!ElementFinder} elementFinder The element to check\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the element is present.\n     */\n    presenceOf(elementFinder) {\n        return elementFinder.isPresent.bind(elementFinder);\n    }\n    ;\n    /**\n     * An expectation for checking that an element is not attached to the DOM\n     * of a page. This is the opposite of 'presenceOf'.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to be no longer present on the dom.\n     * browser.wait(EC.stalenessOf($('#abc')), 5000);\n     *\n     * @alias ExpectedConditions.stalenessOf\n     * @param {!ElementFinder} elementFinder The element to check\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the element is stale.\n     */\n    stalenessOf(elementFinder) {\n        return this.not(this.presenceOf(elementFinder));\n    }\n    /**\n     * An expectation for checking that an element is present on the DOM of a\n     * page and visible. Visibility means that the element is not only displayed\n     * but also has a height and width that is greater than 0. This is the\n     * opposite\n     * of 'invisibilityOf'.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to be visible on the dom.\n     * browser.wait(EC.visibilityOf($('#abc')), 5000);\n     *\n     * @alias ExpectedConditions.visibilityOf\n     * @param {!ElementFinder} elementFinder The element to check\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the element is visible.\n     */\n    visibilityOf(elementFinder) {\n        return this.and(this.presenceOf(elementFinder), () => {\n            return elementFinder.isDisplayed().then(util_1.passBoolean, util_1.falseIfMissing);\n        });\n    }\n    /**\n     * An expectation for checking that an element is either invisible or not\n     * present on the DOM. This is the opposite of 'visibilityOf'.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to be no longer visible on the dom.\n     * browser.wait(EC.invisibilityOf($('#abc')), 5000);\n     *\n     * @alias ExpectedConditions.invisibilityOf\n     * @param {!ElementFinder} elementFinder The element to check\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the element is invisible.\n     */\n    invisibilityOf(elementFinder) {\n        return this.not(this.visibilityOf(elementFinder));\n    }\n    /**\n   * An expectation for checking the selection is selected.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'myCheckbox' to be selected.\n   * browser.wait(EC.elementToBeSelected($('#myCheckbox')), 5000);\n   *\n   * @alias ExpectedConditions.elementToBeSelected\n   * @param {!ElementFinder} elementFinder The element to check\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the element is selected.\n   */\n    elementToBeSelected(elementFinder) {\n        return this.and(this.presenceOf(elementFinder), () => {\n            return elementFinder.isSelected().then(util_1.passBoolean, util_1.falseIfMissing);\n        });\n    }\n}\nexports.ProtractorExpectedConditions = ProtractorExpectedConditions;\n//# sourceMappingURL=expectedConditions.js.map","/home/travis/build/npmtest/node-npmtest-protractor/protractor/built/ptor.js":"\"use strict\";\nconst webdriver = require('selenium-webdriver');\nconst chrome = require('selenium-webdriver/chrome');\nconst firefox = require('selenium-webdriver/firefox');\nconst http = require('selenium-webdriver/http');\nconst remote = require('selenium-webdriver/remote');\nclass Ptor {\n    constructor() {\n        this.$ = function (search) {\n            return null;\n        };\n        this.$$ = function (search) {\n            return null;\n        };\n        // Export protractor classes.\n        this.ProtractorBrowser = require('./browser').ProtractorBrowser;\n        this.ElementFinder = require('./element').ElementFinder;\n        this.ElementArrayFinder = require('./element').ElementArrayFinder;\n        this.ProtractorBy = require('./locators').ProtractorBy;\n        this.ProtractorExpectedConditions = require('./expectedConditions').ProtractorExpectedConditions;\n        // Export selenium webdriver.\n        this.ActionSequence = webdriver.ActionSequence;\n        this.Browser = webdriver.Browser;\n        this.Builder = webdriver.Builder;\n        this.Button = webdriver.Button;\n        this.Capabilities = webdriver.Capabilities;\n        this.Capability = webdriver.Capability;\n        this.EventEmitter = webdriver.EventEmitter;\n        this.FileDetector = webdriver.FileDetector;\n        this.Key = webdriver.Key;\n        this.Session = webdriver.Session;\n        this.WebDriver = webdriver.WebDriver;\n        this.WebElement = webdriver.WebElement;\n        this.WebElementPromise = webdriver.WebElementPromise;\n        this.error = webdriver.error;\n        this.logging = webdriver.logging;\n        this.promise = webdriver.promise;\n        this.until = webdriver.until;\n        this.Command = require('selenium-webdriver/lib/command').Command;\n        this.CommandName = require('selenium-webdriver/lib/command').Name;\n        this.utils = { firefox: firefox, http: http, remote: remote, chrome: chrome };\n    }\n}\nexports.Ptor = Ptor;\nexports.protractor = new Ptor();\n//# sourceMappingURL=ptor.js.map"}
{"/home/travis/build/npmtest/node-npmtest-protractor/test.js":"/* istanbul instrument in package npmtest_protractor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-protractor/lib.npmtest_protractor.js":"/* istanbul instrument in package npmtest_protractor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_protractor = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_protractor = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-protractor/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-protractor && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_protractor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_protractor\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_protractor.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_protractor.rollup.js'] =\n            local.assetsDict['/assets.npmtest_protractor.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_protractor.__dirname +\n                    '/lib.npmtest_protractor.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/index.js":"\"use strict\";\n// Re-export selenium-webdriver types.\nvar selenium_webdriver_1 = require('selenium-webdriver');\nexports.ActionSequence = selenium_webdriver_1.ActionSequence;\nexports.Browser = selenium_webdriver_1.Browser;\nexports.Builder = selenium_webdriver_1.Builder;\nexports.Button = selenium_webdriver_1.Button;\nexports.Capabilities = selenium_webdriver_1.Capabilities;\nexports.Capability = selenium_webdriver_1.Capability;\nexports.error = selenium_webdriver_1.error;\nexports.EventEmitter = selenium_webdriver_1.EventEmitter;\nexports.FileDetector = selenium_webdriver_1.FileDetector;\nexports.Key = selenium_webdriver_1.Key;\nexports.logging = selenium_webdriver_1.logging;\nexports.promise = selenium_webdriver_1.promise;\nexports.Session = selenium_webdriver_1.Session;\nexports.until = selenium_webdriver_1.until;\nexports.WebDriver = selenium_webdriver_1.WebDriver;\nexports.WebElement = selenium_webdriver_1.WebElement;\nexports.WebElementPromise = selenium_webdriver_1.WebElementPromise;\n// Re-export public types.\nvar browser_1 = require('./browser');\nexports.ProtractorBrowser = browser_1.ProtractorBrowser;\nvar element_1 = require('./element');\nexports.ElementArrayFinder = element_1.ElementArrayFinder;\nexports.ElementFinder = element_1.ElementFinder;\nvar expectedConditions_1 = require('./expectedConditions');\nexports.ProtractorExpectedConditions = expectedConditions_1.ProtractorExpectedConditions;\nvar locators_1 = require('./locators');\nexports.ProtractorBy = locators_1.ProtractorBy;\nvar ptor_1 = require('./ptor');\nexports.Ptor = ptor_1.Ptor;\nexports.utils = {\n    firefox: require('selenium-webdriver/firefox'),\n    http: require('selenium-webdriver/http'),\n    remote: require('selenium-webdriver/remote')\n};\nexports.Command = require('selenium-webdriver/lib/command').Command;\nexports.CommandName = require('selenium-webdriver/lib/command').Name;\nObject.defineProperty(exports, 'protractor', { get: () => global['protractor'] });\nfunction registerGlobal(name) {\n    Object.defineProperty(exports, name, { get: () => exports.protractor ? exports.protractor[name] : undefined });\n}\nregisterGlobal('browser');\nregisterGlobal('$');\nregisterGlobal('$$');\nregisterGlobal('element');\nregisterGlobal('By');\nregisterGlobal('by');\nregisterGlobal('ExpectedConditions');\n//# sourceMappingURL=index.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/browser.js":"\"use strict\";\nconst blocking_proxy_1 = require('blocking-proxy');\nconst selenium_webdriver_1 = require('selenium-webdriver');\nconst url = require('url');\nconst webdriver_js_extender_1 = require('webdriver-js-extender');\nconst debugger_1 = require('./debugger');\nconst element_1 = require('./element');\nconst expectedConditions_1 = require('./expectedConditions');\nconst locators_1 = require('./locators');\nconst logger_1 = require('./logger');\nconst clientSideScripts = require('./clientsidescripts');\n// TODO: fix the typings for selenium-webdriver/lib/command\nconst Command = require('selenium-webdriver/lib/command').Command;\nconst CommandName = require('selenium-webdriver/lib/command').Name;\n// jshint browser: true\nconst DEFER_LABEL = 'NG_DEFER_BOOTSTRAP!';\nconst DEFAULT_RESET_URL = 'data:text/html,<html></html>';\nconst DEFAULT_GET_PAGE_TIMEOUT = 10000;\nlet logger = new logger_1.Logger('protractor');\n// TODO(cnishina): either remove for loop entirely since this does not export anything\n// the user might need since everything is composed (with caveat that this could be a\n// potential breaking change) or export the types with `export * from 'selenium-webdriver'`;\n/*\n * Mix in other webdriver functionality to be accessible via protractor.\n */\nfor (let foo in require('selenium-webdriver')) {\n    exports[foo] = require('selenium-webdriver')[foo];\n}\n// Explicitly define types for webdriver.WebDriver and ExtendedWebDriver.\n// We do this because we use composition over inheritance to implement polymorphism, and therefore\n// we don't want to inherit WebDriver's constructor.\nclass AbstractWebDriver {\n}\nexports.AbstractWebDriver = AbstractWebDriver;\nclass AbstractExtendedWebDriver extends AbstractWebDriver {\n}\nexports.AbstractExtendedWebDriver = AbstractExtendedWebDriver;\n/**\n * Mix a function from one object onto another. The function will still be\n * called in the context of the original object.  Any arguments of type\n * `ElementFinder` will be unwrapped to their underlying `WebElement` instance\n *\n * @private\n * @param {Object} to\n * @param {Object} from\n * @param {string} fnName\n * @param {function=} setupFn\n */\nfunction ptorMixin(to, from, fnName, setupFn) {\n    to[fnName] = function () {\n        const args = arguments;\n        for (let i = 0; i < args.length; i++) {\n            if (args[i] instanceof element_1.ElementFinder) {\n                args[i] = args[i].getWebElement();\n            }\n        }\n        const run = () => {\n            return from[fnName].apply(from, args);\n        };\n        if (setupFn) {\n            const setupResult = setupFn();\n            if (setupResult && (typeof setupResult.then === 'function')) {\n                return setupResult.then(run);\n            }\n        }\n        return run();\n    };\n}\n;\n/**\n * Build the helper 'element' function for a given instance of Browser.\n *\n * @private\n * @param {Browser} browser A browser instance.\n * @returns {function(webdriver.Locator): ElementFinder}\n */\nfunction buildElementHelper(browser) {\n    let element = ((locator) => {\n        return new element_1.ElementArrayFinder(browser).all(locator).toElementFinder_();\n    });\n    element.all = (locator) => {\n        return new element_1.ElementArrayFinder(browser).all(locator);\n    };\n    return element;\n}\n;\n/**\n * @alias browser\n * @constructor\n * @extends {webdriver_extensions.ExtendedWebDriver}\n * @param {webdriver.WebDriver} webdriver\n * @param {string=} opt_baseUrl A base URL to run get requests against.\n * @param {string|webdriver.promise.Promise<string>=} opt_rootElement  Selector element that has an\n *     ng-app in scope.\n * @param {boolean=} opt_untrackOutstandingTimeouts Whether Protractor should\n *     stop tracking outstanding $timeouts.\n */\nclass ProtractorBrowser extends AbstractExtendedWebDriver {\n    constructor(webdriverInstance, opt_baseUrl, opt_rootElement, opt_untrackOutstandingTimeouts, opt_blockingProxyUrl) {\n        super();\n        // These functions should delegate to the webdriver instance, but should\n        // wait for Angular to sync up before performing the action. This does not\n        // include functions which are overridden by protractor below.\n        let methodsToSync = ['getCurrentUrl', 'getPageSource', 'getTitle'];\n        let extendWDInstance;\n        try {\n            extendWDInstance = webdriver_js_extender_1.extend(webdriverInstance);\n        }\n        catch (e) {\n            // Probably not a driver that can be extended (e.g. gotten using\n            // `directConnect: true` in the config)\n            extendWDInstance = webdriverInstance;\n        }\n        // Mix all other driver functionality into Protractor.\n        Object.getOwnPropertyNames(selenium_webdriver_1.WebDriver.prototype).forEach(method => {\n            if (!this[method] && typeof extendWDInstance[method] === 'function') {\n                if (methodsToSync.indexOf(method) !== -1) {\n                    ptorMixin(this, extendWDInstance, method, this.waitForAngular.bind(this));\n                }\n                else {\n                    ptorMixin(this, extendWDInstance, method);\n                }\n            }\n        });\n        this.driver = extendWDInstance;\n        if (opt_blockingProxyUrl) {\n            logger.info('Starting BP client for ' + opt_blockingProxyUrl);\n            this.bpClient = new blocking_proxy_1.BPClient(opt_blockingProxyUrl);\n        }\n        this.element = buildElementHelper(this);\n        this.$ = element_1.build$(this.element, selenium_webdriver_1.By);\n        this.$$ = element_1.build$$(this.element, selenium_webdriver_1.By);\n        this.baseUrl = opt_baseUrl || '';\n        this.getPageTimeout = DEFAULT_GET_PAGE_TIMEOUT;\n        this.params = {};\n        this.resetUrl = DEFAULT_RESET_URL;\n        this.debugHelper = new debugger_1.DebugHelper(this);\n        let ng12Hybrid_ = false;\n        Object.defineProperty(this, 'ng12Hybrid', {\n            get: function () {\n                return ng12Hybrid_;\n            },\n            set: function (ng12Hybrid) {\n                if (ng12Hybrid) {\n                    logger.warn('You have set ng12Hybrid.  As of Protractor 4.1.0, ' +\n                        'Protractor can automatically infer if you are using an ' +\n                        'ngUpgrade app (as long as ng1 is loaded before you call ' +\n                        'platformBrowserDynamic()), and this flag is no longer needed ' +\n                        'for most users');\n                }\n                ng12Hybrid_ = ng12Hybrid;\n            }\n        });\n        this.ready = this.angularAppRoot(opt_rootElement || '')\n            .then(() => {\n            return this.driver.getSession();\n        })\n            .then((session) => {\n            // Internet Explorer does not accept data URLs, which are the default\n            // reset URL for Protractor.\n            // Safari accepts data urls, but SafariDriver fails after one is used.\n            // PhantomJS produces a \"Detected a page unload event\" if we use data urls\n            let browserName = session.getCapabilities().get('browserName');\n            if (browserName === 'internet explorer' || browserName === 'safari' ||\n                browserName === 'phantomjs' || browserName === 'MicrosoftEdge') {\n                this.resetUrl = 'about:blank';\n            }\n            return this;\n        });\n        this.trackOutstandingTimeouts_ = !opt_untrackOutstandingTimeouts;\n        this.mockModules_ = [];\n        this.addBaseMockModules_();\n        // set up expected conditions\n        this.ExpectedConditions = new expectedConditions_1.ProtractorExpectedConditions(this);\n    }\n    /**\n     * The css selector for an element on which to find Angular. This is usually\n     * 'body' but if your ng-app is on a subsection of the page it may be\n     * a subelement.\n     *\n     * This property is deprecated - please use angularAppRoot() instead.\n     *\n     * @deprecated\n     * @type {string}\n     */\n    set rootEl(value) {\n        this.angularAppRoot(value);\n    }\n    get rootEl() {\n        return this.internalRootEl;\n    }\n    /**\n     * Set the css selector for an element on which to find Angular. This is usually\n     * 'body' but if your ng-app is on a subsection of the page it may be\n     * a subelement.\n     *\n     * The change will be made within WebDriver's control flow, so that commands after\n     * this method is called use the new app root. Pass nothing to get a promise that\n     * resolves to the value of the selector.\n     *\n     * @param {string|webdriver.promise.Promise<string>} value The new selector.\n     * @returns A promise that resolves with the value of the selector.\n     */\n    angularAppRoot(value = null) {\n        return this.driver.controlFlow().execute(() => {\n            if (value != null) {\n                return selenium_webdriver_1.promise.when(value).then((value) => {\n                    this.internalRootEl = value;\n                    if (this.bpClient) {\n                        const bpCommandPromise = this.bpClient.setWaitParams(value);\n                        // Convert to webdriver promise as best as possible\n                        return selenium_webdriver_1.promise.when(bpCommandPromise).then(() => this.internalRootEl);\n                    }\n                    return this.internalRootEl;\n                });\n            }\n        }, `Set angular root selector to ${value}`);\n    }\n    /**\n     * If true, Protractor will not attempt to synchronize with the page before\n     * performing actions. This can be harmful because Protractor will not wait\n     * until $timeouts and $http calls have been processed, which can cause\n     * tests to become flaky. This should be used only when necessary, such as\n     * when a page continuously polls an API using $timeout.\n     *\n     * Initialized to `false` by the runner.\n     *\n     * This property is deprecated - please use waitForAngularEnabled instead.\n     *\n     * @deprecated\n     * @type {boolean}\n     */\n    set ignoreSynchronization(value) {\n        this.waitForAngularEnabled(!value);\n    }\n    get ignoreSynchronization() {\n        return this.internalIgnoreSynchronization;\n    }\n    /**\n     * If set to false, Protractor will not wait for Angular $http and $timeout\n     * tasks to complete before interacting with the browser. This can cause\n     * flaky tests, but should be used if, for instance, your app continuously\n     * polls an API with $timeout.\n     *\n     * Call waitForAngularEnabled() without passing a value to read the current\n     * state without changing it.\n     */\n    waitForAngularEnabled(enabled = null) {\n        if (enabled != null) {\n            const ret = this.driver.controlFlow().execute(() => {\n                return selenium_webdriver_1.promise.when(enabled).then((enabled) => {\n                    if (this.bpClient) {\n                        logger.debug('Setting waitForAngular' + !enabled);\n                        const bpCommandPromise = this.bpClient.setWaitEnabled(enabled);\n                        // Convert to webdriver promise as best as possible\n                        return selenium_webdriver_1.promise.when(bpCommandPromise).then(() => enabled);\n                    }\n                });\n            }, `Set proxy synchronization enabled to ${enabled}`);\n            this.internalIgnoreSynchronization = !enabled;\n            return ret;\n        }\n        return selenium_webdriver_1.promise.when(!this.ignoreSynchronization);\n    }\n    /**\n     * Get the processed configuration object that is currently being run. This\n     * will contain the specs and capabilities properties of the current runner\n     * instance.\n     *\n     * Set by the runner.\n     *\n     * @returns {webdriver.promise.Promise} A promise which resolves to the\n     * capabilities object.\n     */\n    getProcessedConfig() {\n        return null;\n    }\n    /**\n     * Fork another instance of browser for use in interactive tests.\n     *\n     * @example\n     * // Running with control flow enabled\n     * var fork = browser.forkNewDriverInstance();\n     * fork.get('page1'); // 'page1' gotten by forked browser\n     *\n     * // Running with control flow disabled\n     * var forked = await browser.forkNewDriverInstance().ready;\n     * await forked.get('page1'); // 'page1' gotten by forked browser\n     *\n     * @param {boolean=} useSameUrl Whether to navigate to current url on creation\n     * @param {boolean=} copyMockModules Whether to apply same mock modules on creation\n     * @param {boolean=} copyConfigUpdates Whether to copy over changes to `baseUrl` and similar\n     *   properties initialized to values in the the config.  Defaults to `true`\n     *\n     * @returns {ProtractorBrowser} A browser instance.\n     */\n    forkNewDriverInstance(useSameUrl, copyMockModules, copyConfigUpdates = true) {\n        return null;\n    }\n    /**\n     * Restart the browser.  This is done by closing this browser instance and creating a new one.\n     * A promise resolving to the new instance is returned, and if this function was called on the\n     * global `browser` instance then Protractor will automatically overwrite the global `browser`\n     * variable.\n     *\n     * When restarting a forked browser, it is the caller's job to overwrite references to the old\n     * instance.\n     *\n     * This function behaves slightly differently depending on if the webdriver control flow is\n     * enabled.  If the control flow is enabled, the global `browser` object is synchronously\n     * replaced. If the control flow is disabled, the global `browser` is replaced asynchronously\n     * after the old driver quits.\n     *\n     * Set by the runner.\n     *\n     * @example\n     * // Running against global browser, with control flow enabled\n     * browser.get('page1');\n     * browser.restart();\n     * browser.get('page2'); // 'page2' gotten by restarted browser\n     *\n     * // Running against global browser, with control flow disabled\n     * await browser.get('page1');\n     * await browser.restart();\n     * await browser.get('page2'); // 'page2' gotten by restarted browser\n     *\n     * // Running against forked browsers, with the control flow enabled\n     * // In this case, you may prefer `restartSync` (documented below)\n     * var forked = browser.forkNewDriverInstance();\n     * fork.get('page1');\n     * fork.restart().then(function(fork) {\n     *   fork.get('page2'); // 'page2' gotten by restarted fork\n     * });\n     *\n     * // Running against forked browsers, with the control flow disabled\n     * var forked = await browser.forkNewDriverInstance().ready;\n     * await fork.get('page1');\n     * fork = await fork.restart();\n     * await fork.get('page2'); // 'page2' gotten by restarted fork\n     *\n     * // Unexpected behavior can occur if you save references to the global `browser`\n     * var savedBrowser = browser;\n     * browser.get('foo').then(function() {\n     *   console.log(browser === savedBrowser); // false\n     * });\n     * browser.restart();\n     *\n     * @returns {webdriver.promise.Promise<ProtractorBrowser>} A promise resolving to the restarted\n     *   browser\n     */\n    restart() {\n        return;\n    }\n    /**\n     * Like `restart`, but instead of returning a promise resolving to the new browser instance,\n     * returns the new browser instance directly.  Can only be used when the control flow is enabled.\n     *\n     * @example\n     * // Running against global browser\n     * browser.get('page1');\n     * browser.restartSync();\n     * browser.get('page2'); // 'page2' gotten by restarted browser\n     *\n     * // Running against forked browsers\n     * var forked = browser.forkNewDriverInstance();\n     * fork.get('page1');\n     * fork = fork.restartSync();\n     * fork.get('page2'); // 'page2' gotten by restarted fork\n     *\n     * @throws {TypeError} Will throw an error if the control flow is not enabled\n     * @returns {ProtractorBrowser} The restarted browser\n     */\n    restartSync() {\n        return;\n    }\n    /**\n     * Instead of using a single root element, search through all angular apps\n     * available on the page when finding elements or waiting for stability.\n     * Only compatible with Angular2.\n     */\n    useAllAngular2AppRoots() {\n        // The empty string is an invalid css selector, so we use it to easily\n        // signal to scripts to not find a root element.\n        this.angularAppRoot('');\n    }\n    /**\n     * The same as {@code webdriver.WebDriver.prototype.executeScript},\n     * but with a customized description for debugging.\n     *\n     * @private\n     * @param {!(string|Function)} script The script to execute.\n     * @param {string} description A description of the command for debugging.\n     * @param {...*} var_args The arguments to pass to the script.\n     * @returns {!webdriver.promise.Promise.<T>} A promise that will resolve to\n     * the scripts return value.\n     * @template T\n     */\n    executeScriptWithDescription(script, description, ...scriptArgs) {\n        if (typeof script === 'function') {\n            script = 'return (' + script + ').apply(null, arguments);';\n        }\n        return this.driver.schedule(new Command(CommandName.EXECUTE_SCRIPT)\n            .setParameter('script', script)\n            .setParameter('args', scriptArgs), description);\n    }\n    /**\n     * The same as {@code webdriver.WebDriver.prototype.executeAsyncScript},\n     * but with a customized description for debugging.\n     *\n     * @private\n     * @param {!(string|Function)} script The script to execute.\n     * @param {string} description A description for debugging purposes.\n     * @param {...*} var_args The arguments to pass to the script.\n     * @returns {!webdriver.promise.Promise.<T>} A promise that will resolve to\n     * the\n     *    scripts return value.\n     * @template T\n     */\n    executeAsyncScript_(script, description, ...scriptArgs) {\n        if (typeof script === 'function') {\n            script = 'return (' + script + ').apply(null, arguments);';\n        }\n        return this.driver.schedule(new Command(CommandName.EXECUTE_ASYNC_SCRIPT)\n            .setParameter('script', script)\n            .setParameter('args', scriptArgs), description);\n    }\n    /**\n     * Instruct webdriver to wait until Angular has finished rendering and has\n     * no outstanding $http or $timeout calls before continuing.\n     * Note that Protractor automatically applies this command before every\n     * WebDriver action.\n     *\n     * @param {string=} opt_description An optional description to be added\n     *     to webdriver logs.\n     * @returns {!webdriver.promise.Promise} A promise that will resolve to the\n     *    scripts return value.\n     */\n    waitForAngular(opt_description) {\n        let description = opt_description ? ' - ' + opt_description : '';\n        if (this.ignoreSynchronization) {\n            return this.driver.controlFlow().execute(() => {\n                return true;\n            }, 'Ignore Synchronization Protractor.waitForAngular()');\n        }\n        let runWaitForAngularScript = () => {\n            if (this.plugins_.skipAngularStability() || this.bpClient) {\n                return this.driver.controlFlow().execute(() => {\n                    return selenium_webdriver_1.promise.when(null);\n                }, 'bpClient or plugin stability override');\n            }\n            else {\n                // Need to wrap this so that we read rootEl in the control flow, not synchronously.\n                return this.angularAppRoot().then((rootEl) => {\n                    return this.executeAsyncScript_(clientSideScripts.waitForAngular, 'Protractor.waitForAngular()' + description, rootEl);\n                });\n            }\n        };\n        return runWaitForAngularScript()\n            .then((browserErr) => {\n            if (browserErr) {\n                throw new Error('Error while waiting for Protractor to ' +\n                    'sync with the page: ' + JSON.stringify(browserErr));\n            }\n        })\n            .then(() => {\n            return this.driver.controlFlow()\n                .execute(() => {\n                return this.plugins_.waitForPromise(this);\n            }, 'Plugins.waitForPromise()')\n                .then(() => {\n                return this.driver.wait(() => {\n                    return this.plugins_.waitForCondition(this).then((results) => {\n                        return results.reduce((x, y) => x && y, true);\n                    });\n                }, this.allScriptsTimeout, 'Plugins.waitForCondition()');\n            });\n        }, (err) => {\n            let timeout;\n            if (/asynchronous script timeout/.test(err.message)) {\n                // Timeout on Chrome\n                timeout = /-?[\\d\\.]*\\ seconds/.exec(err.message);\n            }\n            else if (/Timed out waiting for async script/.test(err.message)) {\n                // Timeout on Firefox\n                timeout = /-?[\\d\\.]*ms/.exec(err.message);\n            }\n            else if (/Timed out waiting for an asynchronous script/.test(err.message)) {\n                // Timeout on Safari\n                timeout = /-?[\\d\\.]*\\ ms/.exec(err.message);\n            }\n            if (timeout) {\n                let errMsg = `Timed out waiting for asynchronous Angular tasks to finish after ` +\n                    `${timeout}. This may be because the current page is not an Angular ` +\n                    `application. Please see the FAQ for more details: ` +\n                    `https://github.com/angular/protractor/blob/master/docs/timeouts.md#waiting-for-angular`;\n                if (description.indexOf(' - Locator: ') == 0) {\n                    errMsg += '\\nWhile waiting for element with locator' + description;\n                }\n                let pendingTimeoutsPromise;\n                if (this.trackOutstandingTimeouts_) {\n                    pendingTimeoutsPromise = this.executeScriptWithDescription('return window.NG_PENDING_TIMEOUTS', 'Protractor.waitForAngular() - getting pending timeouts' + description);\n                }\n                else {\n                    pendingTimeoutsPromise = selenium_webdriver_1.promise.when({});\n                }\n                let pendingHttpsPromise = this.executeScriptWithDescription(clientSideScripts.getPendingHttpRequests, 'Protractor.waitForAngular() - getting pending https' + description, this.internalRootEl);\n                return selenium_webdriver_1.promise.all([pendingTimeoutsPromise, pendingHttpsPromise])\n                    .then((arr) => {\n                    let pendingTimeouts = arr[0] || [];\n                    let pendingHttps = arr[1] || [];\n                    let key, pendingTasks = [];\n                    for (key in pendingTimeouts) {\n                        if (pendingTimeouts.hasOwnProperty(key)) {\n                            pendingTasks.push(' - $timeout: ' + pendingTimeouts[key]);\n                        }\n                    }\n                    for (key in pendingHttps) {\n                        pendingTasks.push(' - $http: ' + pendingHttps[key].url);\n                    }\n                    if (pendingTasks.length) {\n                        errMsg += '. \\nThe following tasks were pending:\\n';\n                        errMsg += pendingTasks.join('\\n');\n                    }\n                    err.message = errMsg;\n                    throw err;\n                }, () => {\n                    err.message = errMsg;\n                    throw err;\n                });\n            }\n            else {\n                throw err;\n            }\n        });\n    }\n    /**\n     * Waits for Angular to finish rendering before searching for elements.\n     * @see webdriver.WebDriver.findElement\n     * @returns {!webdriver.WebElementPromise} A promise that will be resolved to\n     *      the located {@link webdriver.WebElement}.\n     */\n    findElement(locator) {\n        return this.element(locator).getWebElement();\n    }\n    /**\n     * Waits for Angular to finish rendering before searching for elements.\n     * @see webdriver.WebDriver.findElements\n     * @returns {!webdriver.promise.Promise} A promise that will be resolved to an\n     *     array of the located {@link webdriver.WebElement}s.\n     */\n    findElements(locator) {\n        return this.element.all(locator).getWebElements();\n    }\n    /**\n     * Tests if an element is present on the page.\n     * @see webdriver.WebDriver.isElementPresent\n     * @returns {!webdriver.promise.Promise} A promise that will resolve to whether\n     *     the element is present on the page.\n     */\n    isElementPresent(locatorOrElement) {\n        let element;\n        if (locatorOrElement instanceof element_1.ElementFinder) {\n            element = locatorOrElement;\n        }\n        else if (locatorOrElement instanceof selenium_webdriver_1.WebElement) {\n            element = element_1.ElementFinder.fromWebElement_(this, locatorOrElement);\n        }\n        else {\n            element = this.element(locatorOrElement);\n        }\n        return element.isPresent();\n    }\n    /**\n     * Add a module to load before Angular whenever Protractor.get is called.\n     * Modules will be registered after existing modules already on the page,\n     * so any module registered here will override preexisting modules with the\n     * same name.\n     *\n     * @example\n     * browser.addMockModule('modName', function() {\n     *   angular.module('modName', []).value('foo', 'bar');\n     * });\n     *\n     * @param {!string} name The name of the module to load or override.\n     * @param {!string|Function} script The JavaScript to load the module.\n     *     Note that this will be executed in the browser context, so it cannot\n     *     access variables from outside its scope.\n     * @param {...*} varArgs Any additional arguments will be provided to\n     *     the script and may be referenced using the `arguments` object.\n     */\n    addMockModule(name, script, ...moduleArgs) {\n        this.mockModules_.push({ name: name, script: script, args: moduleArgs });\n    }\n    /**\n     * Clear the list of registered mock modules.\n     */\n    clearMockModules() {\n        this.mockModules_ = [];\n        this.addBaseMockModules_();\n    }\n    /**\n     * Remove a registered mock module.\n     *\n     * @example\n     * browser.removeMockModule('modName');\n     *\n     * @param {!string} name The name of the module to remove.\n     */\n    removeMockModule(name) {\n        for (let i = 0; i < this.mockModules_.length; ++i) {\n            if (this.mockModules_[i].name == name) {\n                this.mockModules_.splice(i--, 1);\n            }\n        }\n    }\n    /**\n     * Get a list of the current mock modules.\n     *\n     * @returns {Array.<!string|Function>} The list of mock modules.\n     */\n    getRegisteredMockModules() {\n        return this.mockModules_.map(module => module.script);\n    }\n    ;\n    /**\n     * Add the base mock modules used for all Protractor tests.\n     *\n     * @private\n     */\n    addBaseMockModules_() {\n        this.addMockModule('protractorBaseModule_', clientSideScripts.protractorBaseModuleFn, this.trackOutstandingTimeouts_);\n    }\n    /**\n     * @see webdriver.WebDriver.get\n     *\n     * Navigate to the given destination and loads mock modules before\n     * Angular. Assumes that the page being loaded uses Angular.\n     * If you need to access a page which does not have Angular on load, use\n     * the wrapped webdriver directly.\n     *\n     * @example\n     * browser.get('https://angularjs.org/');\n     * expect(browser.getCurrentUrl()).toBe('https://angularjs.org/');\n     *\n     * @param {string} destination Destination URL.\n     * @param {number=} opt_timeout Number of milliseconds to wait for Angular to\n     *     start.\n     */\n    get(destination, timeout = this.getPageTimeout) {\n        destination = this.baseUrl.indexOf('file://') === 0 ? this.baseUrl + destination :\n            url.resolve(this.baseUrl, destination);\n        if (this.ignoreSynchronization) {\n            return this.driver.get(destination)\n                .then(() => this.driver.controlFlow().execute(() => this.plugins_.onPageLoad(this)))\n                .then(() => null);\n        }\n        let msg = (str) => {\n            return 'Protractor.get(' + destination + ') - ' + str;\n        };\n        return this.driver.controlFlow()\n            .execute(() => {\n            return selenium_webdriver_1.promise.when(null);\n        })\n            .then(() => {\n            if (this.bpClient) {\n                return this.driver.controlFlow().execute(() => {\n                    return this.bpClient.setWaitEnabled(false);\n                });\n            }\n        })\n            .then(() => {\n            // Go to reset url\n            return this.driver.get(this.resetUrl);\n        })\n            .then(() => {\n            // Set defer label and navigate\n            return this.executeScriptWithDescription('window.name = \"' + DEFER_LABEL + '\" + window.name;' +\n                'window.location.replace(\"' + destination + '\");', msg('reset url'));\n        })\n            .then(() => {\n            // We need to make sure the new url has loaded before\n            // we try to execute any asynchronous scripts.\n            return this.driver.wait(() => {\n                return this.executeScriptWithDescription('return window.location.href;', msg('get url'))\n                    .then((url) => {\n                    return url !== this.resetUrl;\n                }, (err) => {\n                    if (err.code == 13) {\n                        // Ignore the error, and continue trying. This is\n                        // because IE driver sometimes (~1%) will throw an\n                        // unknown error from this execution. See\n                        // https://github.com/angular/protractor/issues/841\n                        // This shouldn't mask errors because it will fail\n                        // with the timeout anyway.\n                        return false;\n                    }\n                    else {\n                        throw err;\n                    }\n                });\n            }, timeout, 'waiting for page to load for ' + timeout + 'ms');\n        })\n            .then(() => {\n            // Run Plugins\n            return this.driver.controlFlow().execute(() => {\n                return this.plugins_.onPageLoad(this);\n            });\n        })\n            .then(() => {\n            // Make sure the page is an Angular page.\n            return this\n                .executeAsyncScript_(clientSideScripts.testForAngular, msg('test for angular'), Math.floor(timeout / 1000), this.ng12Hybrid)\n                .then((angularTestResult) => {\n                let angularVersion = angularTestResult.ver;\n                if (!angularVersion) {\n                    let message = angularTestResult.message;\n                    logger.error(`Could not find Angular on page ${destination} : ${message}`);\n                    throw new Error(`Angular could not be found on the page ${destination}.` +\n                        `If this is not an Angular application, you may need to turn off waiting for Angular.\n                          Please see \n                          https://github.com/angular/protractor/blob/master/docs/timeouts.md#waiting-for-angular-on-page-load`);\n                }\n                return angularVersion;\n            }, (err) => {\n                throw new Error('Error while running testForAngular: ' + err.message);\n            });\n        })\n            .then((angularVersion) => {\n            // Load Angular Mocks\n            if (angularVersion === 1) {\n                // At this point, Angular will pause for us until angular.resumeBootstrap is called.\n                let moduleNames = [];\n                let modulePromise = selenium_webdriver_1.promise.when(null);\n                for (const { name, script, args } of this.mockModules_) {\n                    moduleNames.push(name);\n                    let executeScriptArgs = [script, msg('add mock module ' + name), ...args];\n                    modulePromise = modulePromise.then(() => this.executeScriptWithDescription.apply(this, executeScriptArgs)\n                        .then(null, (err) => {\n                        throw new Error('Error while running module script ' + name + ': ' + err.message);\n                    }));\n                }\n                return modulePromise.then(() => this.executeScriptWithDescription('window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__ = ' +\n                    'angular.resumeBootstrap(arguments[0]);', msg('resume bootstrap'), moduleNames));\n            }\n            else {\n                // TODO: support mock modules in Angular2. For now, error if someone\n                // has tried to use one.\n                if (this.mockModules_.length > 1) {\n                    throw 'Trying to load mock modules on an Angular v2+ app is not yet supported.';\n                }\n            }\n        })\n            .then(() => {\n            // Reset bpClient sync\n            if (this.bpClient) {\n                return this.driver.controlFlow().execute(() => {\n                    return this.bpClient.setWaitEnabled(!this.internalIgnoreSynchronization);\n                });\n            }\n        })\n            .then(() => {\n            // Run Plugins\n            return this.driver.controlFlow().execute(() => {\n                return this.plugins_.onPageStable(this);\n            });\n        })\n            .then(() => null);\n    }\n    /**\n     * @see webdriver.WebDriver.refresh\n     *\n     * Makes a full reload of the current page and loads mock modules before\n     * Angular. Assumes that the page being loaded uses Angular.\n     * If you need to access a page which does not have Angular on load, use\n     * the wrapped webdriver directly.\n     *\n     * @param {number=} opt_timeout Number of milliseconds to wait for Angular to start.\n     */\n    refresh(opt_timeout) {\n        if (this.ignoreSynchronization) {\n            return this.driver.navigate().refresh();\n        }\n        return this\n            .executeScriptWithDescription('return window.location.href', 'Protractor.refresh() - getUrl')\n            .then((href) => {\n            return this.get(href, opt_timeout);\n        });\n    }\n    /**\n     * Mixin navigation methods back into the navigation object so that\n     * they are invoked as before, i.e. driver.navigate().refresh()\n     */\n    navigate() {\n        let nav = this.driver.navigate();\n        ptorMixin(nav, this, 'refresh');\n        return nav;\n    }\n    /**\n     * Browse to another page using in-page navigation.\n     *\n     * @example\n     * browser.get('http://angular.github.io/protractor/#/tutorial');\n     * browser.setLocation('api');\n     * expect(browser.getCurrentUrl())\n     *     .toBe('http://angular.github.io/protractor/#/api');\n     *\n     * @param {string} url In page URL using the same syntax as $location.url()\n     * @returns {!webdriver.promise.Promise} A promise that will resolve once\n     *    page has been changed.\n     */\n    setLocation(url) {\n        return this.waitForAngular()\n            .then(() => this.angularAppRoot())\n            .then((rootEl) => this.executeScriptWithDescription(clientSideScripts.setLocation, 'Protractor.setLocation()', rootEl, url)\n            .then((browserErr) => {\n            if (browserErr) {\n                throw 'Error while navigating to \\'' + url + '\\' : ' +\n                    JSON.stringify(browserErr);\n            }\n        }));\n    }\n    /**\n     * Deprecated, use `browser.getCurrentUrl()` instead.\n     *\n     * Despite its name, this function will generally return `$location.url()`, though in some\n     * cases it will return `$location.absUrl()` instead.  This function is only here for legacy\n     * users, and will probably be removed in Protractor 6.0.\n     *\n     * @deprecated Please use `browser.getCurrentUrl()`\n     * @example\n     * browser.get('http://angular.github.io/protractor/#/api');\n     * expect(browser.getLocationAbsUrl())\n     *     .toBe('http://angular.github.io/protractor/#/api');\n     * @returns {webdriver.promise.Promise<string>} The current absolute url from\n     * AngularJS.\n     */\n    getLocationAbsUrl() {\n        logger.warn('`browser.getLocationAbsUrl()` is deprecated, please use `browser.getCurrentUrl` instead.');\n        return this.waitForAngular()\n            .then(() => this.angularAppRoot())\n            .then((rootEl) => this.executeScriptWithDescription(clientSideScripts.getLocationAbsUrl, 'Protractor.getLocationAbsUrl()', rootEl));\n    }\n    /**\n     * Adds a task to the control flow to pause the test and inject helper\n     * functions\n     * into the browser, so that debugging may be done in the browser console.\n     *\n     * This should be used under node in debug mode, i.e. with\n     * protractor debug <configuration.js>\n     *\n     * @example\n     * While in the debugger, commands can be scheduled through webdriver by\n     * entering the repl:\n     *   debug> repl\n     *   > element(by.input('user')).sendKeys('Laura');\n     *   > browser.debugger();\n     *   Press Ctrl + c to leave debug repl\n     *   debug> c\n     *\n     * This will run the sendKeys command as the next task, then re-enter the\n     * debugger.\n     */\n    debugger() {\n        // jshint debug: true\n        return this.driver.executeScript(clientSideScripts.installInBrowser)\n            .then(() => selenium_webdriver_1.promise.controlFlow().execute(() => {\n            debugger;\n        }, 'add breakpoint to control flow'));\n    }\n    /**\n     * See browser.explore().\n     */\n    enterRepl(opt_debugPort) {\n        return this.explore(opt_debugPort);\n    }\n    /**\n     * Beta (unstable) explore function for entering the repl loop from\n     * any point in the control flow. Use browser.explore() in your test.\n     * Does not require changes to the command line (no need to add 'debug').\n     * Note, if you are wrapping your own instance of Protractor, you must\n     * expose globals 'browser' and 'protractor' for pause to work.\n     *\n     * @example\n     * element(by.id('foo')).click();\n     * browser.explore();\n     * // Execution will stop before the next click action.\n     * element(by.id('bar')).click();\n     *\n     * @param {number=} opt_debugPort Optional port to use for the debugging\n     * process\n     */\n    explore(opt_debugPort) {\n        let debuggerClientPath = __dirname + '/debugger/clients/explorer.js';\n        let onStartFn = (firstTime) => {\n            logger.info();\n            if (firstTime) {\n                logger.info('------- Element Explorer -------');\n                logger.info('Starting WebDriver debugger in a child process. Element ' +\n                    'Explorer is still beta, please report issues at ' +\n                    'github.com/angular/protractor');\n                logger.info();\n                logger.info('Type <tab> to see a list of locator strategies.');\n                logger.info('Use the `list` helper function to find elements by strategy:');\n                logger.info('  e.g., list(by.binding(\\'\\')) gets all bindings.');\n                logger.info();\n            }\n        };\n        this.debugHelper.initBlocking(debuggerClientPath, onStartFn, opt_debugPort);\n    }\n    /**\n     * Beta (unstable) pause function for debugging webdriver tests. Use\n     * browser.pause() in your test to enter the protractor debugger from that\n     * point in the control flow.\n     * Does not require changes to the command line (no need to add 'debug').\n     * Note, if you are wrapping your own instance of Protractor, you must\n     * expose globals 'browser' and 'protractor' for pause to work.\n     *\n     * @example\n     * element(by.id('foo')).click();\n     * browser.pause();\n     * // Execution will stop before the next click action.\n     * element(by.id('bar')).click();\n     *\n     * @param {number=} opt_debugPort Optional port to use for the debugging\n     * process\n     */\n    pause(opt_debugPort) {\n        if (this.debugHelper.isAttached()) {\n            logger.info('Encountered browser.pause(), but debugger already attached.');\n            return selenium_webdriver_1.promise.when(true);\n        }\n        let debuggerClientPath = __dirname + '/debugger/clients/wddebugger.js';\n        let onStartFn = (firstTime) => {\n            logger.info();\n            logger.info('Encountered browser.pause(). Attaching debugger...');\n            if (firstTime) {\n                logger.info();\n                logger.info('------- WebDriver Debugger -------');\n                logger.info('Starting WebDriver debugger in a child process. Pause is ' +\n                    'still beta, please report issues at github.com/angular/protractor');\n                logger.info();\n                logger.info('press c to continue to the next webdriver command');\n                logger.info('press ^D to detach debugger and resume code execution');\n                logger.info();\n            }\n        };\n        this.debugHelper.init(debuggerClientPath, onStartFn, opt_debugPort);\n    }\n    /**\n     * Determine if the control flow is enabled.\n     *\n     * @returns true if the control flow is enabled, false otherwise.\n     */\n    controlFlowIsEnabled() {\n        if (selenium_webdriver_1.promise.USE_PROMISE_MANAGER !== undefined) {\n            return selenium_webdriver_1.promise.USE_PROMISE_MANAGER;\n        }\n        else {\n            // True for old versions of `selenium-webdriver`, probably false in >=5.0.0\n            return !!selenium_webdriver_1.promise.ControlFlow;\n        }\n    }\n}\n/**\n * @type {ProtractorBy}\n */\nProtractorBrowser.By = new locators_1.ProtractorBy();\nexports.ProtractorBrowser = ProtractorBrowser;\n//# sourceMappingURL=browser.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/debugger.js":"\"use strict\";\nconst net = require('net');\nconst selenium_webdriver_1 = require('selenium-webdriver');\nconst util = require('util');\nconst logger_1 = require('./logger');\nlet breakpointHook = require('./breakpointhook.js');\nlet logger = new logger_1.Logger('protractor');\nclass DebugHelper {\n    constructor(browserUnderDebug_) {\n        this.browserUnderDebug_ = browserUnderDebug_;\n    }\n    initBlocking(debuggerClientPath, onStartFn, opt_debugPort) {\n        this.init_(debuggerClientPath, true, onStartFn, opt_debugPort);\n    }\n    init(debuggerClientPath, onStartFn, opt_debugPort) {\n        this.init_(debuggerClientPath, false, onStartFn, opt_debugPort);\n    }\n    /**\n     *  1) Set up helper functions for debugger clients to call on (e.g.\n     *     execute code, get autocompletion).\n     *  2) Enter process into debugger mode. (i.e. process._debugProcess).\n     *  3) Invoke the debugger client specified by debuggerClientPath.\n     *\n     * @param {string} debuggerClientPath Absolute path of debugger client to use.\n     * @param {boolean} blockUntilExit Whether to block the flow until process exit or resume\n     *     immediately.\n     * @param {Function} onStartFn Function to call when the debugger starts. The\n     *     function takes a single parameter, which represents whether this is the\n     *     first time that the debugger is called.\n     * @param {number=} opt_debugPort Optional port to use for the debugging\n     *     process.\n     *\n     * @return {Promise} If blockUntilExit, a promise resolved when the debugger process\n     *     exits. Otherwise, resolved when the debugger process is ready to begin.\n     */\n    init_(debuggerClientPath, blockUntilExit, onStartFn, opt_debugPort) {\n        const vm_ = require('vm');\n        let flow = selenium_webdriver_1.promise.controlFlow();\n        let context = { require: require };\n        global.list = (locator) => {\n            return global.protractor.browser.findElements(locator).then((arr) => {\n                let found = [];\n                for (let i = 0; i < arr.length; ++i) {\n                    arr[i].getText().then((text) => {\n                        found.push(text);\n                    });\n                }\n                return found;\n            });\n        };\n        for (let key in global) {\n            context[key] = global[key];\n        }\n        let sandbox = vm_.createContext(context);\n        let debuggingDone = selenium_webdriver_1.promise.defer();\n        // We run one flow.execute block for the debugging session. All\n        // subcommands should be scheduled under this task.\n        let executePromise = flow.execute(() => {\n            process['debugPort'] = opt_debugPort || process['debugPort'];\n            this.validatePortAvailability_(process['debugPort']).then((firstTime) => {\n                onStartFn(firstTime);\n                let args = [process.pid, process['debugPort']];\n                if (this.browserUnderDebug_.debuggerServerPort) {\n                    args.push(this.browserUnderDebug_.debuggerServerPort);\n                }\n                let nodedebug = require('child_process').fork(debuggerClientPath, args);\n                process.on('exit', function () {\n                    nodedebug.kill('SIGTERM');\n                });\n                nodedebug\n                    .on('message', (m) => {\n                    if (m === 'ready') {\n                        breakpointHook();\n                        if (!blockUntilExit) {\n                            debuggingDone.fulfill();\n                        }\n                    }\n                })\n                    .on('exit', () => {\n                    // Clear this so that we know it's ok to attach a debugger\n                    // again.\n                    this.dbgCodeExecutor = null;\n                    debuggingDone.fulfill();\n                });\n            });\n            return debuggingDone.promise;\n        }, 'debugging tasks');\n        // Helper used only by debuggers at './debugger/modes/*.js' to insert code\n        // into the control flow, via debugger 'evaluate' protocol.\n        // In order to achieve this, we maintain a task at the top of the control\n        // flow, so that we can insert frames into it.\n        // To be able to simulate callback/asynchronous code, we poll this object\n        // whenever `breakpointHook` is called.\n        this.dbgCodeExecutor = {\n            execPromise_: undefined,\n            execPromiseResult_: undefined,\n            execPromiseError_: undefined,\n            // A dummy repl server to make use of its completion function.\n            replServer_: require('repl').start({\n                input: { on: function () { }, resume: function () { } },\n                // dummy readable stream\n                output: { write: function () { } },\n                useGlobal: true\n            }),\n            // Execute a function, which could yield a value or a promise,\n            // and allow its result to be accessed synchronously\n            execute_: function (execFn_) {\n                this.execPromiseResult_ = this.execPromiseError_ = undefined;\n                this.execPromise_ = execFn_();\n                // Note: This needs to be added after setting execPromise to execFn,\n                // or else we cause this.execPromise_ to get stuck in pending mode\n                // at our next breakpoint.\n                this.execPromise_.then((result) => {\n                    this.execPromiseResult_ = result;\n                    breakpointHook();\n                }, (err) => {\n                    this.execPromiseError_ = err;\n                    breakpointHook();\n                });\n            },\n            // Execute a piece of code.\n            // Result is a string representation of the evaluation.\n            execute: function (code) {\n                let execFn_ = () => {\n                    // Run code through vm so that we can maintain a local scope which is\n                    // isolated from the rest of the execution.\n                    let res;\n                    try {\n                        res = vm_.runInContext(code, sandbox);\n                    }\n                    catch (e) {\n                        res = selenium_webdriver_1.promise.when('Error while evaluating command: ' + e);\n                    }\n                    if (!selenium_webdriver_1.promise.isPromise(res)) {\n                        res = selenium_webdriver_1.promise.when(res);\n                    }\n                    return res.then((res) => {\n                        if (res === undefined) {\n                            return undefined;\n                        }\n                        else {\n                            // The '' forces res to be expanded into a string instead of just\n                            // '[Object]'. Then we remove the extra space caused by the ''\n                            // using substring.\n                            return util.format.apply(this, ['', res]).substring(1);\n                        }\n                    });\n                };\n                this.execute_(execFn_);\n            },\n            // Autocomplete for a line.\n            // Result is a JSON representation of the autocomplete response.\n            complete: function (line) {\n                let execFn_ = () => {\n                    let deferred = selenium_webdriver_1.promise.defer();\n                    this.replServer_.complete(line, (err, res) => {\n                        if (err) {\n                            deferred.reject(err);\n                        }\n                        else {\n                            deferred.fulfill(JSON.stringify(res));\n                        }\n                    });\n                    return deferred.promise;\n                };\n                this.execute_(execFn_);\n            },\n            // Code finished executing.\n            resultReady: function () {\n                return !(this.execPromise_.state_ === 'pending');\n            },\n            // Get asynchronous results synchronously.\n            // This will throw if result is not ready.\n            getResult: function () {\n                if (!this.resultReady()) {\n                    throw new Error('Result not ready');\n                }\n                if (this.execPromiseError_) {\n                    throw this.execPromiseError_;\n                }\n                return this.execPromiseResult_;\n            }\n        };\n        return executePromise;\n    }\n    /**\n     * Validates that the port is free to use. This will only validate the first\n     * time it is called. The reason is that on subsequent calls, the port will\n     * already be bound to the debugger, so it will not be available, but that is\n     * okay.\n     *\n     * @returns {Promise<boolean>} A promise that becomes ready when the\n     * validation\n     *     is done. The promise will resolve to a boolean which represents whether\n     *     this is the first time that the debugger is called.\n     */\n    validatePortAvailability_(port) {\n        if (this.debuggerValidated_) {\n            return selenium_webdriver_1.promise.when(false);\n        }\n        let doneDeferred = selenium_webdriver_1.promise.defer();\n        // Resolve doneDeferred if port is available.\n        let tester = net.connect({ port: port }, () => {\n            doneDeferred.reject('Port ' + port + ' is already in use. Please specify ' +\n                'another port to debug.');\n        });\n        tester.once('error', (err) => {\n            if (err.code === 'ECONNREFUSED') {\n                tester\n                    .once('close', () => {\n                    doneDeferred.fulfill(true);\n                })\n                    .end();\n            }\n            else {\n                doneDeferred.reject('Unexpected failure testing for port ' + port + ': ' + JSON.stringify(err));\n            }\n        });\n        return doneDeferred.promise.then((firstTime) => {\n            this.debuggerValidated_ = true;\n            return firstTime;\n        }, (err) => {\n            console.error(err);\n            process.exit(1);\n        });\n    }\n    isAttached() {\n        return !!this.dbgCodeExecutor;\n    }\n}\nexports.DebugHelper = DebugHelper;\n//# sourceMappingURL=debugger.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/logger.js":"\"use strict\";\nconst fs = require('fs');\nconst path = require('path');\n// Will use chalk if chalk is available to add color to console logging\nlet chalk;\nlet printRed;\nlet printYellow;\nlet printGray;\ntry {\n    chalk = require('chalk');\n    printRed = chalk.red;\n    printYellow = chalk.yellow;\n    printGray = chalk.gray;\n}\ncatch (e) {\n    printRed = printYellow = printGray = (msg) => {\n        return msg;\n    };\n}\n(function (LogLevel) {\n    LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n    LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"DEBUG\"] = 3] = \"DEBUG\";\n})(exports.LogLevel || (exports.LogLevel = {}));\nvar LogLevel = exports.LogLevel;\n(function (WriteTo) {\n    WriteTo[WriteTo[\"CONSOLE\"] = 0] = \"CONSOLE\";\n    WriteTo[WriteTo[\"FILE\"] = 1] = \"FILE\";\n    WriteTo[WriteTo[\"BOTH\"] = 2] = \"BOTH\";\n    WriteTo[WriteTo[\"NONE\"] = 3] = \"NONE\";\n})(exports.WriteTo || (exports.WriteTo = {}));\nvar WriteTo = exports.WriteTo;\nlet logFile = 'protractor.log'; // the default log file name\n/**\n * Logger class adds timestamp output, log levels, and identifiers to help\n * when debugging. Also could write to console, file, both, or none.\n */\nclass Logger {\n    /**\n     * Creates a logger instance with an ID for the logger.\n     * @constructor\n     */\n    constructor(id) {\n        this.id = id;\n    }\n    /**\n     * Set up the logging configuration from the protractor configuration file.\n     * @param config The protractor configuration\n     */\n    static set(config) {\n        if (config.troubleshoot) {\n            Logger.logLevel = LogLevel.DEBUG;\n        }\n    }\n    /**\n     * Set up the write location. If writing to a file, get the file descriptor.\n     * @param writeTo The enum for where to write the logs.\n     * @param opt_logFile An optional parameter to override the log file location.\n     */\n    static setWrite(writeTo, opt_logFile) {\n        if (opt_logFile) {\n            logFile = opt_logFile;\n        }\n        Logger.writeTo = writeTo;\n        if (Logger.writeTo == WriteTo.FILE || Logger.writeTo == WriteTo.BOTH) {\n            Logger.fd = fs.openSync(path.resolve(logFile), 'a');\n            Logger.firstWrite = false;\n        }\n    }\n    /**\n     * Log INFO\n     * @param ...msgs multiple arguments to be logged.\n     */\n    info(...msgs) {\n        this.log_(LogLevel.INFO, msgs);\n    }\n    /**\n     * Log DEBUG\n     * @param ...msgs multiple arguments to be logged.\n     */\n    debug(...msgs) {\n        this.log_(LogLevel.DEBUG, msgs);\n    }\n    /**\n     * Log WARN\n     * @param ...msgs multiple arguments to be logged.\n     */\n    warn(...msgs) {\n        this.log_(LogLevel.WARN, msgs);\n    }\n    /**\n     * Log ERROR\n     * @param ...msgs multiple arguments to be logged.\n     */\n    error(...msgs) {\n        this.log_(LogLevel.ERROR, msgs);\n    }\n    /**\n     * For the log level set, check to see if the messages should be logged.\n     * @param logLevel The log level of the message.\n     * @param msgs The messages to be logged\n     */\n    log_(logLevel, msgs) {\n        switch (Logger.logLevel) {\n            case LogLevel.ERROR:\n                if (logLevel <= LogLevel.ERROR) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.WARN:\n                if (logLevel <= LogLevel.WARN) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.INFO:\n                if (logLevel <= LogLevel.INFO) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.DEBUG:\n                if (logLevel <= LogLevel.DEBUG) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            default:\n                throw new Error('Log level undefined');\n        }\n    }\n    /**\n     * Format with timestamp, log level, identifier, and message and log to\n     * specified medium (console, file, both, none).\n     * @param logLevel The log level of the message.\n     * @param msgs The messages to be logged.\n     */\n    print_(logLevel, msgs) {\n        let consoleLog = '';\n        let fileLog = '';\n        if (Logger.showTimestamp) {\n            consoleLog += Logger.timestamp_(WriteTo.CONSOLE);\n            fileLog += Logger.timestamp_(WriteTo.FILE);\n        }\n        consoleLog += Logger.level_(logLevel, this.id, WriteTo.CONSOLE);\n        fileLog += Logger.level_(logLevel, this.id, WriteTo.FILE);\n        if (Logger.showId) {\n            consoleLog += Logger.id_(logLevel, this.id, WriteTo.CONSOLE);\n            fileLog += Logger.id_(logLevel, this.id, WriteTo.FILE);\n        }\n        consoleLog += ' -';\n        fileLog += ' - ';\n        switch (Logger.writeTo) {\n            case WriteTo.CONSOLE:\n                msgs.unshift(consoleLog);\n                console.log.apply(console, msgs);\n                break;\n            case WriteTo.FILE:\n                // for the first line written to the file, add a space\n                if (!Logger.firstWrite) {\n                    fs.writeSync(Logger.fd, '\\n');\n                    Logger.firstWrite = true;\n                }\n                fileLog += ' ' + Logger.msgToFile_(msgs);\n                fs.writeSync(Logger.fd, fileLog + '\\n');\n                break;\n            case WriteTo.BOTH:\n                // for the first line written to the file, add a space\n                if (!Logger.firstWrite) {\n                    fs.writeSync(Logger.fd, '\\n');\n                    Logger.firstWrite = true;\n                }\n                fileLog += ' ' + Logger.msgToFile_(msgs);\n                fs.writeSync(Logger.fd, fileLog + '\\n');\n                msgs.unshift(consoleLog);\n                console.log.apply(console, msgs);\n                break;\n            case WriteTo.NONE:\n                break;\n        }\n    }\n    /**\n     * Get a timestamp formatted with [hh:mm:ss]\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted timestamp\n     */\n    static timestamp_(writeTo) {\n        let d = new Date();\n        let ts = '[';\n        let hours = d.getHours() < 10 ? '0' + d.getHours() : d.getHours();\n        let minutes = d.getMinutes() < 10 ? '0' + d.getMinutes() : d.getMinutes();\n        let seconds = d.getSeconds() < 10 ? '0' + d.getSeconds() : d.getSeconds();\n        if (writeTo == WriteTo.CONSOLE) {\n            ts += printGray(hours + ':' + minutes + ':' + seconds) + ']';\n        }\n        else {\n            ts += hours + ':' + minutes + ':' + seconds + ']';\n        }\n        ts += ' ';\n        return ts;\n    }\n    /**\n     * Get the identifier of the logger as '/<id>'\n     * @param logLevel The log level of the message.\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted id\n     */\n    static id_(logLevel, id, writeTo) {\n        if (writeTo === WriteTo.FILE) {\n            return '/' + id;\n        }\n        else if (logLevel === LogLevel.ERROR) {\n            return printRed('/' + id);\n        }\n        else if (logLevel === LogLevel.WARN) {\n            return printYellow('/' + id);\n        }\n        else {\n            return '/' + id;\n        }\n    }\n    /**\n     * Get the log level formatted with the first letter. For info, it is I.\n     * @param logLevel The log level of the message.\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted log level\n     */\n    static level_(logLevel, id, writeTo) {\n        let level = LogLevel[logLevel].toString();\n        if (writeTo === WriteTo.FILE) {\n            return level[0];\n        }\n        else if (logLevel === LogLevel.ERROR) {\n            return printRed(level[0]);\n        }\n        else if (logLevel === LogLevel.WARN) {\n            return printYellow(level[0]);\n        }\n        else {\n            return level[0];\n        }\n    }\n    /**\n     * Convert the list of messages to a single string message.\n     * @param msgs The list of messages.\n     * @return The string of the formatted messages\n     */\n    static msgToFile_(msgs) {\n        let log = '';\n        for (let pos = 0; pos < msgs.length; pos++) {\n            let msg = msgs[pos];\n            let ret;\n            if (typeof msg === 'object') {\n                ret = JSON.stringify(msg);\n            }\n            else {\n                ret = msg;\n            }\n            if (pos !== msgs.length - 1) {\n                ret += ' ';\n            }\n            log += ret;\n        }\n        return log;\n    }\n}\nLogger.logLevel = LogLevel.INFO;\nLogger.showTimestamp = true;\nLogger.showId = true;\nLogger.writeTo = WriteTo.CONSOLE;\nLogger.firstWrite = false;\nexports.Logger = Logger;\n//# sourceMappingURL=logger.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/breakpointhook.js":"module.exports = function() {\n  return true;\n};\n\n/**\n * The reason this file exists is so that we can set a breakpoint via\n * script name, and then control when that breakpoint is set in\n * our library code by importing and calling this function. The\n * breakpoint will always be on line 2.\n */","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/element.js":"\"use strict\";\nconst selenium_webdriver_1 = require('selenium-webdriver');\nconst locators_1 = require('./locators');\nconst logger_1 = require('./logger');\nconst util_1 = require('./util');\nlet clientSideScripts = require('./clientsidescripts');\nlet logger = new logger_1.Logger('element');\nclass WebdriverWebElement {\n}\nexports.WebdriverWebElement = WebdriverWebElement;\nlet WEB_ELEMENT_FUNCTIONS = [\n    'click', 'sendKeys', 'getTagName', 'getCssValue', 'getAttribute', 'getText', 'getSize',\n    'getLocation', 'isEnabled', 'isSelected', 'submit', 'clear', 'isDisplayed', 'getId',\n    'takeScreenshot'\n];\n/**\n * ElementArrayFinder is used for operations on an array of elements (as opposed\n * to a single element).\n *\n * The ElementArrayFinder is used to set up a chain of conditions that identify\n * an array of elements. In particular, you can call all(locator) and\n * filter(filterFn) to return a new ElementArrayFinder modified by the\n * conditions, and you can call get(index) to return a single ElementFinder at\n * position 'index'.\n *\n * Similar to jquery, ElementArrayFinder will search all branches of the DOM\n * to find the elements that satisfy the conditions (i.e. all, filter, get).\n * However, an ElementArrayFinder will not actually retrieve the elements until\n * an action is called, which means it can be set up in helper files (i.e.\n * page objects) before the page is available, and reused as the page changes.\n *\n * You can treat an ElementArrayFinder as an array of WebElements for most\n * purposes, in particular, you may perform actions (i.e. click, getText) on\n * them as you would an array of WebElements. The action will apply to\n * every element identified by the ElementArrayFinder. ElementArrayFinder\n * extends Promise, and once an action is performed on an ElementArrayFinder,\n * the latest result can be accessed using then, and will be returned as an\n * array of the results; the array has length equal to the length of the\n * elements found by the ElementArrayFinder and each result represents the\n * result of performing the action on the element. Unlike a WebElement, an\n * ElementArrayFinder will wait for the angular app to settle before\n * performing finds or actions.\n *\n * @alias element.all(locator)\n * @view\n * <ul class=\"items\">\n *   <li>First</li>\n *   <li>Second</li>\n *   <li>Third</li>\n * </ul>\n *\n * @example\n * element.all(by.css('.items li')).then(function(items) {\n *   expect(items.length).toBe(3);\n *   expect(items[0].getText()).toBe('First');\n * });\n *\n * // Or using the shortcut $$() notation instead of element.all(by.css()):\n *\n * $$('.items li').then(function(items) {\n *   expect(items.length).toBe(3);\n *   expect(items[0].getText()).toBe('First');\n * });\n *\n * @constructor\n * @param {ProtractorBrowser} browser A browser instance.\n * @param {function(): Array.<webdriver.WebElement>} getWebElements A function\n *    that returns a list of the underlying Web Elements.\n * @param {webdriver.Locator} locator The most relevant locator. It is only\n *    used for error reporting and ElementArrayFinder.locator.\n * @param {Array.<webdriver.promise.Promise>} opt_actionResults An array\n *    of promises which will be retrieved with then. Resolves to the latest\n *    action result, or null if no action has been called.\n * @returns {ElementArrayFinder}\n */\nclass ElementArrayFinder extends WebdriverWebElement {\n    constructor(browser_, getWebElements = null, locator_, actionResults_ = null) {\n        super();\n        this.browser_ = browser_;\n        this.getWebElements = getWebElements;\n        this.locator_ = locator_;\n        this.actionResults_ = actionResults_;\n        // TODO(juliemr): might it be easier to combine this with our docs and just\n        // wrap each one explicity with its own documentation?\n        WEB_ELEMENT_FUNCTIONS.forEach((fnName) => {\n            this[fnName] = (...args) => {\n                let actionFn = (webElem) => {\n                    return webElem[fnName].apply(webElem, args);\n                };\n                return this.applyAction_(actionFn);\n            };\n        });\n    }\n    /**\n     * Create a shallow copy of ElementArrayFinder.\n     *\n     * @returns {!ElementArrayFinder} A shallow copy of this.\n     */\n    clone() {\n        // A shallow copy is all we need since the underlying fields can never be\n        // modified. (Locator can be modified by the user, but that should\n        // rarely/never happen and it doesn't affect functionalities).\n        return new ElementArrayFinder(this.browser_, this.getWebElements, this.locator_, this.actionResults_);\n    }\n    /**\n     * Calls to ElementArrayFinder may be chained to find an array of elements\n     * using the current elements in this ElementArrayFinder as the starting\n     * point. This function returns a new ElementArrayFinder which would contain\n     * the children elements found (and could also be empty).\n     *\n     * @alias element.all(locator).all(locator)\n     * @view\n     * <div id='id1' class=\"parent\">\n     *   <ul>\n     *     <li class=\"foo\">1a</li>\n     *     <li class=\"baz\">1b</li>\n     *   </ul>\n     * </div>\n     * <div id='id2' class=\"parent\">\n     *   <ul>\n     *     <li class=\"foo\">2a</li>\n     *     <li class=\"bar\">2b</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let foo = element.all(by.css('.parent')).all(by.css('.foo'));\n     * expect(foo.getText()).toEqual(['1a', '2a']);\n     * let baz = element.all(by.css('.parent')).all(by.css('.baz'));\n     * expect(baz.getText()).toEqual(['1b']);\n     * let nonexistent = element.all(by.css('.parent'))\n     *   .all(by.css('.NONEXISTENT'));\n     * expect(nonexistent.getText()).toEqual(['']);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let foo = $$('.parent').$$('.foo');\n     * expect(foo.getText()).toEqual(['1a', '2a']);\n     * let baz = $$('.parent').$$('.baz');\n     * expect(baz.getText()).toEqual(['1b']);\n     * let nonexistent = $$('.parent').$$('.NONEXISTENT');\n     * expect(nonexistent.getText()).toEqual(['']);\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementArrayFinder}\n     */\n    all(locator) {\n        let ptor = this.browser_;\n        let getWebElements = () => {\n            if (this.getWebElements === null) {\n                // This is the first time we are looking for an element\n                return ptor.waitForAngular('Locator: ' + locator)\n                    .then(() => {\n                    if (locators_1.isProtractorLocator(locator)) {\n                        return locator.findElementsOverride(ptor.driver, null, ptor.rootEl);\n                    }\n                    else {\n                        return ptor.driver.findElements(locator);\n                    }\n                });\n            }\n            else {\n                return this.getWebElements().then((parentWebElements) => {\n                    // For each parent web element, find their children and construct\n                    // a list of Promise<List<child_web_element>>\n                    let childrenPromiseList = parentWebElements.map((parentWebElement) => {\n                        return locators_1.isProtractorLocator(locator) ?\n                            locator.findElementsOverride(ptor.driver, parentWebElement, ptor.rootEl) :\n                            parentWebElement.findElements(locator);\n                    });\n                    // Resolve the list of Promise<List<child_web_elements>> and merge\n                    // into a single list\n                    return selenium_webdriver_1.promise.all(childrenPromiseList)\n                        .then((resolved) => {\n                        return resolved.reduce((childrenList, resolvedE) => {\n                            return childrenList.concat(resolvedE);\n                        }, []);\n                    });\n                });\n            }\n        };\n        return new ElementArrayFinder(this.browser_, getWebElements, locator);\n    }\n    /**\n     * Apply a filter function to each element within the ElementArrayFinder.\n     * Returns a new ElementArrayFinder with all elements that pass the filter\n     * function. The filter function receives the ElementFinder as the first\n     * argument and the index as a second arg. This does not actually retrieve\n     * the underlying list of elements, so it can be used in page objects.\n     *\n     * @alias element.all(locator).filter(filterFn)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).filter(function(elem, index) {\n     *   return elem.getText().then(function(text) {\n     *     return text === 'Third';\n     *   });\n     * }).first().click();\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').filter(function(elem, index) {\n     *   return elem.getText().then(function(text) {\n     *     return text === 'Third';\n     *   });\n     * }).first().click();\n     *\n     * @param {function(ElementFinder, number): webdriver.WebElement.Promise}\n     * filterFn\n     *     Filter function that will test if an element should be returned.\n     *     filterFn can either return a boolean or a promise that resolves to a\n     * boolean\n     * @returns {!ElementArrayFinder} A ElementArrayFinder that represents an\n     * array\n     *     of element that satisfy the filter function.\n     */\n    filter(filterFn) {\n        let getWebElements = () => {\n            return this.getWebElements().then((parentWebElements) => {\n                let list = parentWebElements.map((parentWebElement, index) => {\n                    let elementFinder = ElementFinder.fromWebElement_(this.browser_, parentWebElement, this.locator_);\n                    return filterFn(elementFinder, index);\n                });\n                return selenium_webdriver_1.promise.all(list).then((resolvedList) => {\n                    return parentWebElements.filter((parentWebElement, index) => {\n                        return resolvedList[index];\n                    });\n                });\n            });\n        };\n        return new ElementArrayFinder(this.browser_, getWebElements, this.locator_);\n    }\n    /**\n     * Get an element within the ElementArrayFinder by index. The index starts at\n     * 0\\. Negative indices are wrapped (i.e. -i means ith element from last)\n     * This does not actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).get(index)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let list = element.all(by.css('.items li'));\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.items li');\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * @param {number|webdriver.promise.Promise} index Element index.\n     * @returns {ElementFinder} finder representing element at the given index.\n     */\n    get(index) {\n        let getWebElements = () => {\n            return selenium_webdriver_1.promise.all([index, this.getWebElements()]).then(([i, parentWebElements]) => {\n                if (i < 0) {\n                    i += parentWebElements.length;\n                }\n                if (i < 0 || i >= parentWebElements.length) {\n                    throw new selenium_webdriver_1.error.NoSuchElementError('Index out of bound. Trying to access element at index: ' + index +\n                        ', but there are only ' + parentWebElements.length + ' elements that match ' +\n                        'locator ' + this.locator_.toString());\n                }\n                return [parentWebElements[i]];\n            });\n        };\n        return new ElementArrayFinder(this.browser_, getWebElements, this.locator_).toElementFinder_();\n    }\n    /**\n     * Get the first matching element for the ElementArrayFinder. This does not\n     * actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).first()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let first = element.all(by.css('.items li')).first();\n     * expect(first.getText()).toBe('First');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let first = $$('.items li').first();\n     * expect(first.getText()).toBe('First');\n     *\n     * @returns {ElementFinder} finder representing the first matching element\n     */\n    first() {\n        return this.get(0);\n    }\n    ;\n    /**\n     * Get the last matching element for the ElementArrayFinder. This does not\n     * actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).last()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let last = element.all(by.css('.items li')).last();\n     * expect(last.getText()).toBe('Third');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let last = $$('.items li').last();\n     * expect(last.getText()).toBe('Third');\n     *\n     * @returns {ElementFinder} finder representing the last matching element\n     */\n    last() {\n        return this.get(-1);\n    }\n    /**\n     * Shorthand function for finding arrays of elements by css.\n     * `element.all(by.css('.abc'))` is equivalent to `$$('.abc')`\n     *\n     * @alias $$(cssSelector)\n     * @view\n     * <div class=\"count\">\n     *   <span class=\"one\">First</span>\n     *   <span class=\"two\">Second</span>\n     * </div>\n     *\n     * @example\n     * // The following two blocks of code are equivalent.\n     * let list = element.all(by.css('.count span'));\n     * expect(list.count()).toBe(2);\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.count span');\n     * expect(list.count()).toBe(2);\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * @param {string} selector a css selector\n     * @returns {ElementArrayFinder} which identifies the\n     *     array of the located {@link webdriver.WebElement}s.\n     */\n    $$(selector) {\n        return this.all(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Returns an ElementFinder representation of ElementArrayFinder. It ensures\n     * that the ElementArrayFinder resolves to one and only one underlying\n     * element.\n     *\n     * @returns {ElementFinder} An ElementFinder representation\n     * @private\n     */\n    toElementFinder_() {\n        return new ElementFinder(this.browser_, this);\n    }\n    /**\n     * Count the number of elements represented by the ElementArrayFinder.\n     *\n     * @alias element.all(locator).count()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let list = element.all(by.css('.items li'));\n     * expect(list.count()).toBe(3);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.items li');\n     * expect(list.count()).toBe(3);\n     *\n     * @returns {!webdriver.promise.Promise} A promise which resolves to the\n     *     number of elements matching the locator.\n     */\n    count() {\n        return this.getWebElements().then((arr) => {\n            return arr.length;\n        }, (err) => {\n            if (err instanceof selenium_webdriver_1.error.NoSuchElementError) {\n                return 0;\n            }\n            else {\n                throw err;\n            }\n        });\n    }\n    /**\n     * Returns true if there are any elements present that match the finder.\n     *\n     * @alias element.all(locator).isPresent()\n     *\n     * @example\n     * expect($('.item').isPresent()).toBeTruthy();\n     *\n     * @returns {Promise<boolean>}\n     */\n    isPresent() {\n        return this.count().then((count) => {\n            return count > 0;\n        });\n    }\n    /**\n     * Returns the most relevant locator.\n     *\n     * @example\n     * // returns by.css('#ID1')\n     * $('#ID1').locator();\n     *\n     * // returns by.css('#ID2')\n     * $('#ID1').$('#ID2').locator();\n     *\n     * // returns by.css('#ID1')\n     * $$('#ID1').filter(filterFn).get(0).click().locator();\n     *\n     * @returns {webdriver.Locator}\n     */\n    locator() {\n        return this.locator_;\n    }\n    /**\n     * Apply an action function to every element in the ElementArrayFinder,\n     * and return a new ElementArrayFinder that contains the results of the\n     * actions.\n     *\n     * @param {function(ElementFinder)} actionFn\n     *\n     * @returns {ElementArrayFinder}\n     * @private\n     */\n    // map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\n    applyAction_(actionFn) {\n        let callerError = new Error();\n        let actionResults = this.getWebElements()\n            .then((arr) => selenium_webdriver_1.promise.all(arr.map(actionFn)))\n            .then((value) => {\n            return { passed: true, value: value };\n        }, (error) => {\n            return { passed: false, value: error };\n        });\n        let getWebElements = () => actionResults.then(() => this.getWebElements());\n        actionResults = actionResults.then((result) => {\n            if (result.passed) {\n                return result.value;\n            }\n            else {\n                let noSuchErr;\n                if (result.value instanceof Error) {\n                    noSuchErr = result.value;\n                    noSuchErr.stack = noSuchErr.stack + callerError.stack;\n                }\n                else {\n                    noSuchErr = new Error(result.value);\n                    noSuchErr.stack = callerError.stack;\n                }\n                throw noSuchErr;\n            }\n        });\n        return new ElementArrayFinder(this.browser_, getWebElements, this.locator_, actionResults);\n    }\n    /**\n     * Represents the ElementArrayFinder as an array of ElementFinders.\n     *\n     * @returns {Array.<ElementFinder>} Return a promise, which resolves to a list\n     *     of ElementFinders specified by the locator.\n     */\n    asElementFinders_() {\n        return this.getWebElements().then((arr) => {\n            return arr.map((webElem) => {\n                return ElementFinder.fromWebElement_(this.browser_, webElem, this.locator_);\n            });\n        });\n    }\n    /**\n     * Retrieve the elements represented by the ElementArrayFinder. The input\n     * function is passed to the resulting promise, which resolves to an\n     * array of ElementFinders.\n     *\n     * @alias element.all(locator).then(thenFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).then(function(arr) {\n     *   expect(arr.length).toEqual(3);\n     * });\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').then(function(arr) {\n     *   expect(arr.length).toEqual(3);\n     * });\n     *\n     * @param {function(Array.<ElementFinder>)} fn\n     * @param {function(Error)} errorFn\n     *\n     * @returns {!webdriver.promise.Promise} A promise which will resolve to\n     *     an array of ElementFinders represented by the ElementArrayFinder.\n     */\n    then(fn, errorFn) {\n        if (this.actionResults_) {\n            return this.actionResults_.then(fn, errorFn);\n        }\n        else {\n            return this.asElementFinders_().then(fn, errorFn);\n        }\n    }\n    /**\n     * Calls the input function on each ElementFinder represented by the\n     * ElementArrayFinder.\n     *\n     * @alias element.all(locator).each(eachFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).each(function(element, index) {\n     *   // Will print 0 First, 1 Second, 2 Third.\n     *   element.getText().then(function (text) {\n     *     console.log(index, text);\n     *   });\n     * });\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').each(function(element, index) {\n     *   // Will print 0 First, 1 Second, 2 Third.\n     *   element.getText().then(function (text) {\n     *     console.log(index, text);\n     *   });\n     * });\n     *\n     * @param {function(ElementFinder)} fn Input function\n     *\n     * @returns {!webdriver.promise.Promise} A promise that will resolve when the\n     *     function has been called on all the ElementFinders. The promise will\n     *     resolve to null.\n     */\n    each(fn) {\n        return this.map(fn).then(() => {\n            return null;\n        });\n    }\n    /**\n     * Apply a map function to each element within the ElementArrayFinder. The\n     * callback receives the ElementFinder as the first argument and the index as\n     * a second arg.\n     *\n     * @alias element.all(locator).map(mapFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * let items = element.all(by.css('.items li')).map(function(elm, index) {\n     *   return {\n     *     index: index,\n     *     text: elm.getText(),\n     *     class: elm.getAttribute('class')\n     *   };\n     * });\n     * expect(items).toEqual([\n     *   {index: 0, text: 'First', class: 'one'},\n     *   {index: 1, text: 'Second', class: 'two'},\n     *   {index: 2, text: 'Third', class: 'three'}\n     * ]);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let items = $$('.items li').map(function(elm, index) {\n     *   return {\n     *     index: index,\n     *     text: elm.getText(),\n     *     class: elm.getAttribute('class')\n     *   };\n     * });\n     * expect(items).toEqual([\n     *   {index: 0, text: 'First', class: 'one'},\n     *   {index: 1, text: 'Second', class: 'two'},\n     *   {index: 2, text: 'Third', class: 'three'}\n     * ]);\n     *\n     * @param {function(ElementFinder, number)} mapFn Map function that\n     *     will be applied to each element.\n     * @returns {!webdriver.promise.Promise} A promise that resolves to an array\n     *     of values returned by the map function.\n     */\n    map(mapFn) {\n        return this.asElementFinders_().then((arr) => {\n            let list = arr.map((elementFinder, index) => {\n                let mapResult = mapFn(elementFinder, index);\n                // All nested arrays and objects will also be fully resolved.\n                return selenium_webdriver_1.promise.fullyResolved(mapResult);\n            });\n            return selenium_webdriver_1.promise.all(list);\n        });\n    }\n    ;\n    /**\n     * Apply a reduce function against an accumulator and every element found\n     * using the locator (from left-to-right). The reduce function has to reduce\n     * every element into a single value (the accumulator). Returns promise of\n     * the accumulator. The reduce function receives the accumulator, current\n     * ElementFinder, the index, and the entire array of ElementFinders,\n     * respectively.\n     *\n     * @alias element.all(locator).reduce(reduceFn)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * let value = element.all(by.css('.items li')).reduce(function(acc, elem) {\n     *   return elem.getText().then(function(text) {\n     *     return acc + text + ' ';\n     *   });\n     * }, '');\n     *\n     * expect(value).toEqual('First Second Third ');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let value = $$('.items li').reduce(function(acc, elem) {\n     *   return elem.getText().then(function(text) {\n     *     return acc + text + ' ';\n     *   });\n     * }, '');\n     *\n     * expect(value).toEqual('First Second Third ');\n     *\n     * @param {function(number, ElementFinder, number, Array.<ElementFinder>)}\n     *     reduceFn Reduce function that reduces every element into a single\n     * value.\n     * @param {*} initialValue Initial value of the accumulator.\n     * @returns {!webdriver.promise.Promise} A promise that resolves to the final\n     *     value of the accumulator.\n     */\n    reduce(reduceFn, initialValue) {\n        let valuePromise = selenium_webdriver_1.promise.when(initialValue);\n        return this.asElementFinders_().then((arr) => {\n            return arr.reduce((valuePromise, elementFinder, index) => {\n                return valuePromise.then((value) => {\n                    return reduceFn(value, elementFinder, index, arr);\n                });\n            }, valuePromise);\n        });\n    }\n    /**\n     * Evaluates the input as if it were on the scope of the current underlying\n     * elements.\n     *\n     * @view\n     * <span class=\"foo\">{{letiableInScope}}</span>\n     *\n     * @example\n     * let value = element.all(by.css('.foo')).evaluate('letiableInScope');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let value = $$('.foo').evaluate('letiableInScope');\n     *\n     * @param {string} expression\n     *\n     * @returns {ElementArrayFinder} which resolves to the\n     *     evaluated expression for each underlying element.\n     *     The result will be resolved as in\n     *     {@link webdriver.WebDriver.executeScript}. In summary - primitives will\n     *     be resolved as is, functions will be converted to string, and elements\n     *     will be returned as a WebElement.\n     */\n    evaluate(expression) {\n        let evaluationFn = (webElem) => {\n            return webElem.getDriver().executeScript(clientSideScripts.evaluate, webElem, expression);\n        };\n        return this.applyAction_(evaluationFn);\n    }\n    /**\n     * Determine if animation is allowed on the current underlying elements.\n     * @param {string} value\n     *\n     * @example\n     * // Turns off ng-animate animations for all elements in the <body>\n     * element(by.css('body')).allowAnimations(false);\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * $('body').allowAnimations(false);\n     *\n     * @returns {ElementArrayFinder} which resolves to whether animation is\n     * allowed.\n     */\n    allowAnimations(value) {\n        let allowAnimationsTestFn = (webElem) => {\n            return webElem.getDriver().executeScript(clientSideScripts.allowAnimations, webElem, value);\n        };\n        return this.applyAction_(allowAnimationsTestFn);\n    }\n}\nexports.ElementArrayFinder = ElementArrayFinder;\n/**\n * The ElementFinder simply represents a single element of an\n * ElementArrayFinder (and is more like a convenience object). As a result,\n * anything that can be done with an ElementFinder, can also be done using\n * an ElementArrayFinder.\n *\n * The ElementFinder can be treated as a WebElement for most purposes, in\n * particular, you may perform actions (i.e. click, getText) on them as you\n * would a WebElement. Once an action is performed on an ElementFinder, the\n * latest result from the chain can be accessed using the then method.\n * Unlike a WebElement, an ElementFinder will wait for angular to settle before\n * performing finds or actions.\n *\n * ElementFinder can be used to build a chain of locators that is used to find\n * an element. An ElementFinder does not actually attempt to find the element\n * until an action is called, which means they can be set up in helper files\n * before the page is available.\n *\n * @alias element(locator)\n * @view\n * <span>{{person.name}}</span>\n * <span ng-bind=\"person.email\"></span>\n * <input type=\"text\" ng-model=\"person.name\"/>\n *\n * @example\n * // Find element with {{scopelet}} syntax.\n * element(by.binding('person.name')).getText().then(function(name) {\n *   expect(name).toBe('Foo');\n * });\n *\n * // Find element with ng-bind=\"scopelet\" syntax.\n * expect(element(by.binding('person.email')).getText()).toBe('foo@bar.com');\n *\n * // Find by model.\n * let input = element(by.model('person.name'));\n * input.sendKeys('123');\n * expect(input.getAttribute('value')).toBe('Foo123');\n *\n * @constructor\n * @extends {webdriver.WebElement}\n * @param {ProtractorBrowser} browser_ A browser instance.\n * @param {ElementArrayFinder} elementArrayFinder The ElementArrayFinder\n *     that this is branched from.\n * @returns {ElementFinder}\n */\nclass ElementFinder extends WebdriverWebElement {\n    constructor(browser_, elementArrayFinder) {\n        super();\n        this.browser_ = browser_;\n        this.then = null;\n        if (!elementArrayFinder) {\n            throw new Error('BUG: elementArrayFinder cannot be empty');\n        }\n        this.parentElementArrayFinder = elementArrayFinder;\n        // Only have a `then` method if the parent element array finder\n        // has action results.\n        if (this.parentElementArrayFinder.actionResults_) {\n            // Access the underlying actionResult of ElementFinder.\n            this.then =\n                    (fn, errorFn) => {\n                    return this.elementArrayFinder_.then((actionResults) => {\n                        if (!fn) {\n                            return actionResults[0];\n                        }\n                        return fn(actionResults[0]);\n                    }, errorFn);\n                };\n        }\n        // This filter verifies that there is only 1 element returned by the\n        // elementArrayFinder. It will warn if there are more than 1 element and\n        // throw an error if there are no elements.\n        let getWebElements = () => {\n            return elementArrayFinder.getWebElements().then((webElements) => {\n                if (webElements.length === 0) {\n                    throw new selenium_webdriver_1.error.NoSuchElementError('No element found using locator: ' + elementArrayFinder.locator().toString());\n                }\n                else {\n                    if (webElements.length > 1) {\n                        logger.warn('more than one element found for locator ' +\n                            elementArrayFinder.locator().toString() + ' - the first result will be used');\n                    }\n                    return [webElements[0]];\n                }\n            });\n        };\n        // Store a copy of the underlying elementArrayFinder, but with the more\n        // restrictive getWebElements (which checks that there is only 1 element).\n        this.elementArrayFinder_ = new ElementArrayFinder(this.browser_, getWebElements, elementArrayFinder.locator(), elementArrayFinder.actionResults_);\n        WEB_ELEMENT_FUNCTIONS.forEach((fnName) => {\n            (this)[fnName] = (...args) => {\n                return (this.elementArrayFinder_)[fnName]\n                    .apply(this.elementArrayFinder_, args)\n                    .toElementFinder_();\n            };\n        });\n    }\n    static fromWebElement_(browser, webElem, locator) {\n        let getWebElements = () => {\n            return selenium_webdriver_1.promise.when([webElem]);\n        };\n        return new ElementArrayFinder(browser, getWebElements, locator).toElementFinder_();\n    }\n    /**\n     * Create a shallow copy of ElementFinder.\n     *\n     * @returns {!ElementFinder} A shallow copy of this.\n     */\n    clone() {\n        // A shallow copy is all we need since the underlying fields can never be\n        // modified\n        return new ElementFinder(this.browser_, this.parentElementArrayFinder);\n    }\n    /**\n     * @see ElementArrayFinder.prototype.locator\n     *\n     * @returns {webdriver.Locator}\n     */\n    locator() {\n        return this.elementArrayFinder_.locator();\n    }\n    /**\n     * Returns the WebElement represented by this ElementFinder.\n     * Throws the WebDriver error if the element doesn't exist.\n     *\n     * @alias element(locator).getWebElement()\n     * @view\n     * <div class=\"parent\">\n     *   some text\n     * </div>\n     *\n     * @example\n     * // The following four expressions are equivalent.\n     * $('.parent').getWebElement();\n     * element(by.css('.parent')).getWebElement();\n     * browser.driver.findElement(by.css('.parent'));\n     * browser.findElement(by.css('.parent'));\n     *\n     * @returns {webdriver.WebElementPromise}\n     */\n    getWebElement() {\n        let id = this.elementArrayFinder_.getWebElements().then((parentWebElements) => {\n            return parentWebElements[0];\n        });\n        return new selenium_webdriver_1.WebElementPromise(this.browser_.driver, id);\n    }\n    /**\n     * Calls to {@code all} may be chained to find an array of elements within a\n     * parent.\n     *\n     * @alias element(locator).all(locator)\n     * @view\n     * <div class=\"parent\">\n     *   <ul>\n     *     <li class=\"one\">First</li>\n     *     <li class=\"two\">Second</li>\n     *     <li class=\"three\">Third</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let items = element(by.css('.parent')).all(by.tagName('li'));\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * let items = $('.parent').all(by.tagName('li'));\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementArrayFinder}\n     */\n    all(subLocator) {\n        return this.elementArrayFinder_.all(subLocator);\n    }\n    /**\n     * Calls to {@code element} may be chained to find elements within a parent.\n     *\n     * @alias element(locator).element(locator)\n     * @view\n     * <div class=\"parent\">\n     *   <div class=\"child\">\n     *     Child text\n     *     <div>{{person.phone}}</div>\n     *   </div>\n     * </div>\n     *\n     * @example\n     * // Chain 2 element calls.\n     * let child = element(by.css('.parent')).\n     *     element(by.css('.child'));\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = element(by.css('.parent')).\n     *     element(by.css('.child')).\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * // Chain 2 element calls.\n     * let child = $('.parent').$('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = $('.parent').$('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementFinder}\n     */\n    element(subLocator) {\n        return this.all(subLocator).toElementFinder_();\n    }\n    /**\n     * Calls to {@code $$} may be chained to find an array of elements within a\n     * parent.\n     *\n     * @alias element(locator).all(selector)\n     * @view\n     * <div class=\"parent\">\n     *   <ul>\n     *     <li class=\"one\">First</li>\n     *     <li class=\"two\">Second</li>\n     *     <li class=\"three\">Third</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let items = element(by.css('.parent')).$$('li');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * let items = $('.parent').$$('li');\n     *\n     * @param {string} selector a css selector\n     * @returns {ElementArrayFinder}\n     */\n    $$(selector) {\n        return this.all(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Calls to {@code $} may be chained to find elements within a parent.\n     *\n     * @alias element(locator).$(selector)\n     * @view\n     * <div class=\"parent\">\n     *   <div class=\"child\">\n     *     Child text\n     *     <div>{{person.phone}}</div>\n     *   </div>\n     * </div>\n     *\n     * @example\n     * // Chain 2 element calls.\n     * let child = element(by.css('.parent')).\n     *     $('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = element(by.css('.parent')).\n     *     $('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * // Chain 2 element calls.\n     * let child = $('.parent').$('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = $('.parent').$('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * @param {string} selector A css selector\n     * @returns {ElementFinder}\n     */\n    $(selector) {\n        return this.element(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Determine whether the element is present on the page.\n     *\n     * @view\n     * <span>{{person.name}}</span>\n     *\n     * @example\n     * // Element exists.\n     * expect(element(by.binding('person.name')).isPresent()).toBe(true);\n     *\n     * // Element not present.\n     * expect(element(by.binding('notPresent')).isPresent()).toBe(false);\n     *\n     * @returns {webdriver.promise.Promise<boolean>} which resolves to whether\n     *     the element is present on the page.\n     */\n    isPresent() {\n        return this.parentElementArrayFinder.getWebElements().then((arr) => {\n            if (arr.length === 0) {\n                return false;\n            }\n            return arr[0].isEnabled().then(() => {\n                return true; // is present, whether it is enabled or not\n            }, util_1.falseIfMissing);\n        }, util_1.falseIfMissing);\n    }\n    /**\n     * Same as ElementFinder.isPresent(), except this checks whether the element\n     * identified by the subLocator is present, rather than the current element\n     * finder. i.e. `element(by.css('#abc')).element(by.css('#def')).isPresent()`\n     * is identical to `element(by.css('#abc')).isElementPresent(by.css('#def'))`.\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * `$('#abc').$('#def').isPresent()` is identical to\n     * `$('#abc').isElementPresent($('#def'))`.\n     *\n     * @see ElementFinder.isPresent\n     *\n     * @param {webdriver.Locator} subLocator Locator for element to look for.\n     * @returns {webdriver.promise.Promise<boolean>} which resolves to whether\n     *     the subelement is present on the page.\n     */\n    isElementPresent(subLocator) {\n        if (!subLocator) {\n            throw new Error('SubLocator is not supplied as a parameter to ' +\n                '`isElementPresent(subLocator)`. You are probably looking for the ' +\n                'function `isPresent()`.');\n        }\n        return this.element(subLocator).isPresent();\n    }\n    /**\n     * Evaluates the input as if it were on the scope of the current element.\n     * @see ElementArrayFinder.prototype.evaluate\n     *\n     * @view\n     * <span id=\"foo\">{{letiableInScope}}</span>\n     *\n     * @example\n     * let value = element(by.id('foo')).evaluate('letiableInScope');\n     *\n     * @param {string} expression\n     *\n     * @returns {ElementFinder} which resolves to the evaluated expression.\n     */\n    evaluate(expression) {\n        return this.elementArrayFinder_.evaluate(expression).toElementFinder_();\n    }\n    /**\n     * @see ElementArrayFinder.prototype.allowAnimations.\n     * @param {string} value\n     *\n     * @returns {ElementFinder} which resolves to whether animation is allowed.\n     */\n    allowAnimations(value) {\n        return this.elementArrayFinder_.allowAnimations(value).toElementFinder_();\n    }\n    /**\n     * Compares an element to this one for equality.\n     *\n     * @param {!ElementFinder|!webdriver.WebElement} The element to compare to.\n     *\n     * @returns {!webdriver.promise.Promise.<boolean>} A promise that will be\n     *     resolved to whether the two WebElements are equal.\n     */\n    equals(element) {\n        return selenium_webdriver_1.WebElement.equals(this.getWebElement(), element.getWebElement ? element.getWebElement() :\n            element);\n    }\n}\nexports.ElementFinder = ElementFinder;\n/**\n * Shortcut for querying the document directly with css.\n * `element(by.css('.abc'))` is equivalent to `$('.abc')`\n *\n * @alias $(cssSelector)\n * @view\n * <div class=\"count\">\n *   <span class=\"one\">First</span>\n *   <span class=\"two\">Second</span>\n * </div>\n *\n * @example\n * let item = $('.count .two');\n * expect(item.getText()).toBe('Second');\n *\n * @param {string} selector A css selector\n * @returns {ElementFinder} which identifies the located\n *     {@link webdriver.WebElement}\n */\nexports.build$ = (element, by) => {\n    return (selector) => {\n        return element(by.css(selector));\n    };\n};\n/**\n * Shortcut for querying the document directly with css.\n * `element.all(by.css('.abc'))` is equivalent to `$$('.abc')`\n *\n * @alias $$(cssSelector)\n * @view\n * <div class=\"count\">\n *   <span class=\"one\">First</span>\n *   <span class=\"two\">Second</span>\n * </div>\n *\n * @example\n * // The following protractor expressions are equivalent.\n * let list = element.all(by.css('.count span'));\n * expect(list.count()).toBe(2);\n *\n * list = $$('.count span');\n * expect(list.count()).toBe(2);\n * expect(list.get(0).getText()).toBe('First');\n * expect(list.get(1).getText()).toBe('Second');\n *\n * @param {string} selector a css selector\n * @returns {ElementArrayFinder} which identifies the\n *     array of the located {@link webdriver.WebElement}s.\n */\nexports.build$$ = (element, by) => {\n    return (selector) => {\n        return element.all(by.css(selector));\n    };\n};\n//# sourceMappingURL=element.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/locators.js":"\"use strict\";\nconst selenium_webdriver_1 = require('selenium-webdriver');\nlet clientSideScripts = require('./clientsidescripts');\n// Explicitly define webdriver.By.\n// We do this because we want to inherit the static methods of webdriver.By, as opposed to\n// inheriting from the webdriver.By class itself, which is actually analogous to ProtractorLocator.\nclass WebdriverBy {\n    constructor() {\n        this.className = selenium_webdriver_1.By.className;\n        this.css = selenium_webdriver_1.By.css;\n        this.id = selenium_webdriver_1.By.id;\n        this.linkText = selenium_webdriver_1.By.linkText;\n        this.js = selenium_webdriver_1.By.js;\n        this.name = selenium_webdriver_1.By.name;\n        this.partialLinkText = selenium_webdriver_1.By.partialLinkText;\n        this.tagName = selenium_webdriver_1.By.tagName;\n        this.xpath = selenium_webdriver_1.By.xpath;\n    }\n}\nexports.WebdriverBy = WebdriverBy;\nfunction isProtractorLocator(x) {\n    return x && (typeof x.findElementsOverride === 'function');\n}\nexports.isProtractorLocator = isProtractorLocator;\n/**\n * The Protractor Locators. These provide ways of finding elements in\n * Angular applications by binding, model, etc.\n *\n * @alias by\n * @extends {webdriver.By}\n */\nclass ProtractorBy extends WebdriverBy {\n    /**\n     * Add a locator to this instance of ProtractorBy. This locator can then be\n     * used with element(by.locatorName(args)).\n     *\n     * @view\n     * <button ng-click=\"doAddition()\">Go!</button>\n     *\n     * @example\n     * // Add the custom locator.\n     * by.addLocator('buttonTextSimple',\n     *     function(buttonText, opt_parentElement, opt_rootSelector) {\n     *   // This function will be serialized as a string and will execute in the\n     *   // browser. The first argument is the text for the button. The second\n     *   // argument is the parent element, if any.\n     *   var using = opt_parentElement || document,\n     *       buttons = using.querySelectorAll('button');\n     *\n     *   // Return an array of buttons with the text.\n     *   return Array.prototype.filter.call(buttons, function(button) {\n     *     return button.textContent === buttonText;\n     *   });\n     * });\n     *\n     * // Use the custom locator.\n     * element(by.buttonTextSimple('Go!')).click();\n     *\n     * @alias by.addLocator(locatorName, functionOrScript)\n     * @param {string} name The name of the new locator.\n     * @param {Function|string} script A script to be run in the context of\n     *     the browser. This script will be passed an array of arguments\n     *     that contains any args passed into the locator followed by the\n     *     element scoping the search and the css selector for the root angular\n     *     element. It should return an array of elements.\n     */\n    addLocator(name, script) {\n        this[name] = (...args) => {\n            let locatorArguments = args;\n            return {\n                findElementsOverride: (driver, using, rootSelector) => {\n                    let findElementArguments = [script];\n                    for (let i = 0; i < locatorArguments.length; i++) {\n                        findElementArguments.push(locatorArguments[i]);\n                    }\n                    findElementArguments.push(using);\n                    findElementArguments.push(rootSelector);\n                    return driver.findElements(selenium_webdriver_1.By.js.apply(selenium_webdriver_1.By, findElementArguments));\n                },\n                toString: () => {\n                    return 'by.' + name + '(\"' + Array.prototype.join.call(locatorArguments, '\", \"') + '\")';\n                }\n            };\n        };\n    }\n    ;\n    /**\n     * Find an element by text binding. Does a partial match, so any elements\n     * bound to variables containing the input string will be returned.\n     *\n     * Note: For AngularJS version 1.2, the interpolation brackets, (usually\n     * {{}}), are optionally allowed in the binding description string. For\n     * Angular version 1.3+, they are not allowed, and no elements will be found\n     * if they are used.\n     *\n     * @view\n     * <span>{{person.name}}</span>\n     * <span ng-bind=\"person.email\"></span>\n     *\n     * @example\n     * var span1 = element(by.binding('person.name'));\n     * expect(span1.getText()).toBe('Foo');\n     *\n     * var span2 = element(by.binding('person.email'));\n     * expect(span2.getText()).toBe('foo@bar.com');\n     *\n     * // You can also use a substring for a partial match\n     * var span1alt = element(by.binding('name'));\n     * expect(span1alt.getText()).toBe('Foo');\n     *\n     * // This works for sites using Angular 1.2 but NOT 1.3\n     * var deprecatedSyntax = element(by.binding('{{person.name}}'));\n     *\n     * @param {string} bindingDescriptor\n     * @returns {ProtractorLocator} location strategy\n     */\n    binding(bindingDescriptor) {\n        return {\n            findElementsOverride: (driver, using, rootSelector) => {\n                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findBindings, bindingDescriptor, false, using, rootSelector));\n            },\n            toString: () => {\n                return 'by.binding(\"' + bindingDescriptor + '\")';\n            }\n        };\n    }\n    ;\n    /**\n     * Find an element by exact binding.\n     *\n     * @view\n     * <span>{{ person.name }}</span>\n     * <span ng-bind=\"person-email\"></span>\n     * <span>{{person_phone|uppercase}}</span>\n     *\n     * @example\n     * expect(element(by.exactBinding('person.name')).isPresent()).toBe(true);\n     * expect(element(by.exactBinding('person-email')).isPresent()).toBe(true);\n     * expect(element(by.exactBinding('person')).isPresent()).toBe(false);\n     * expect(element(by.exactBinding('person_phone')).isPresent()).toBe(true);\n     * expect(element(by.exactBinding('person_phone|uppercase')).isPresent()).toBe(true);\n     * expect(element(by.exactBinding('phone')).isPresent()).toBe(false);\n     *\n     * @param {string} bindingDescriptor\n     * @returns {ProtractorLocator} location strategy\n     */\n    exactBinding(bindingDescriptor) {\n        return {\n            findElementsOverride: (driver, using, rootSelector) => {\n                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findBindings, bindingDescriptor, true, using, rootSelector));\n            },\n            toString: () => {\n                return 'by.exactBinding(\"' + bindingDescriptor + '\")';\n            }\n        };\n    }\n    ;\n    /**\n     * Find an element by ng-model expression.\n     *\n     * @alias by.model(modelName)\n     * @view\n     * <input type=\"text\" ng-model=\"person.name\">\n     *\n     * @example\n     * var input = element(by.model('person.name'));\n     * input.sendKeys('123');\n     * expect(input.getAttribute('value')).toBe('Foo123');\n     *\n     * @param {string} model ng-model expression.\n     * @returns {ProtractorLocator} location strategy\n     */\n    model(model) {\n        return {\n            findElementsOverride: (driver, using, rootSelector) => {\n                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findByModel, model, using, rootSelector));\n            },\n            toString: () => {\n                return 'by.model(\"' + model + '\")';\n            }\n        };\n    }\n    ;\n    /**\n     * Find a button by text.\n     *\n     * @view\n     * <button>Save</button>\n     *\n     * @example\n     * element(by.buttonText('Save'));\n     *\n     * @param {string} searchText\n     * @returns {ProtractorLocator} location strategy\n     */\n    buttonText(searchText) {\n        return {\n            findElementsOverride: (driver, using, rootSelector) => {\n                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findByButtonText, searchText, using, rootSelector));\n            },\n            toString: () => {\n                return 'by.buttonText(\"' + searchText + '\")';\n            }\n        };\n    }\n    ;\n    /**\n     * Find a button by partial text.\n     *\n     * @view\n     * <button>Save my file</button>\n     *\n     * @example\n     * element(by.partialButtonText('Save'));\n     *\n     * @param {string} searchText\n     * @returns {ProtractorLocator} location strategy\n     */\n    partialButtonText(searchText) {\n        return {\n            findElementsOverride: (driver, using, rootSelector) => {\n                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findByPartialButtonText, searchText, using, rootSelector));\n            },\n            toString: () => {\n                return 'by.partialButtonText(\"' + searchText + '\")';\n            }\n        };\n    }\n    ;\n    // Generate either by.repeater or by.exactRepeater\n    byRepeaterInner(exact, repeatDescriptor) {\n        let name = 'by.' + (exact ? 'exactR' : 'r') + 'epeater';\n        return {\n            findElementsOverride: (driver, using, rootSelector) => {\n                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findAllRepeaterRows, repeatDescriptor, exact, using, rootSelector));\n            },\n            toString: () => {\n                return name + '(\"' + repeatDescriptor + '\")';\n            },\n            row: (index) => {\n                return {\n                    findElementsOverride: (driver, using, rootSelector) => {\n                        return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findRepeaterRows, repeatDescriptor, exact, index, using, rootSelector));\n                    },\n                    toString: () => {\n                        return name + '(' + repeatDescriptor + '\").row(\"' + index + '\")\"';\n                    },\n                    column: (binding) => {\n                        return {\n                            findElementsOverride: (driver, using, rootSelector) => {\n                                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findRepeaterElement, repeatDescriptor, exact, index, binding, using, rootSelector));\n                            },\n                            toString: () => {\n                                return name + '(\"' + repeatDescriptor + '\").row(\"' + index + '\").column(\"' +\n                                    binding + '\")';\n                            }\n                        };\n                    }\n                };\n            },\n            column: (binding) => {\n                return {\n                    findElementsOverride: (driver, using, rootSelector) => {\n                        return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findRepeaterColumn, repeatDescriptor, exact, binding, using, rootSelector));\n                    },\n                    toString: () => {\n                        return name + '(\"' + repeatDescriptor + '\").column(\"' + binding + '\")';\n                    },\n                    row: (index) => {\n                        return {\n                            findElementsOverride: (driver, using, rootSelector) => {\n                                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findRepeaterElement, repeatDescriptor, exact, index, binding, using, rootSelector));\n                            },\n                            toString: () => {\n                                return name + '(\"' + repeatDescriptor + '\").column(\"' + binding + '\").row(\"' +\n                                    index + '\")';\n                            }\n                        };\n                    }\n                };\n            }\n        };\n    }\n    /**\n     * Find elements inside an ng-repeat.\n     *\n     * @view\n     * <div ng-repeat=\"cat in pets\">\n     *   <span>{{cat.name}}</span>\n     *   <span>{{cat.age}}</span>\n     * </div>\n     *\n     * <div class=\"book-img\" ng-repeat-start=\"book in library\">\n     *   <span>{{$index}}</span>\n     * </div>\n     * <div class=\"book-info\" ng-repeat-end>\n     *   <h4>{{book.name}}</h4>\n     *   <p>{{book.blurb}}</p>\n     * </div>\n     *\n     * @example\n     * // Returns the DIV for the second cat.\n     * var secondCat = element(by.repeater('cat in pets').row(1));\n     *\n     * // Returns the SPAN for the first cat's name.\n     * var firstCatName = element(by.repeater('cat in pets').\n     *     row(0).column('cat.name'));\n     *\n     * // Returns a promise that resolves to an array of WebElements from a column\n     * var ages = element.all(\n     *     by.repeater('cat in pets').column('cat.age'));\n     *\n     * // Returns a promise that resolves to an array of WebElements containing\n     * // all top level elements repeated by the repeater. For 2 pets rows\n     * // resolves to an array of 2 elements.\n     * var rows = element.all(by.repeater('cat in pets'));\n     *\n     * // Returns a promise that resolves to an array of WebElements containing\n     * // all the elements with a binding to the book's name.\n     * var divs = element.all(by.repeater('book in library').column('book.name'));\n     *\n     * // Returns a promise that resolves to an array of WebElements containing\n     * // the DIVs for the second book.\n     * var bookInfo = element.all(by.repeater('book in library').row(1));\n     *\n     * // Returns the H4 for the first book's name.\n     * var firstBookName = element(by.repeater('book in library').\n     *     row(0).column('book.name'));\n     *\n     * // Returns a promise that resolves to an array of WebElements containing\n     * // all top level elements repeated by the repeater. For 2 books divs\n     * // resolves to an array of 4 elements.\n     * var divs = element.all(by.repeater('book in library'));\n     *\n     * @param {string} repeatDescriptor\n     * @returns {ProtractorLocator} location strategy\n     */\n    repeater(repeatDescriptor) {\n        return this.byRepeaterInner(false, repeatDescriptor);\n    }\n    /**\n     * Find an element by exact repeater.\n     *\n     * @view\n     * <li ng-repeat=\"person in peopleWithRedHair\"></li>\n     * <li ng-repeat=\"car in cars | orderBy:year\"></li>\n     *\n     * @example\n     * expect(element(by.exactRepeater('person in\n     * peopleWithRedHair')).isPresent())\n     *     .toBe(true);\n     * expect(element(by.exactRepeater('person in\n     * people')).isPresent()).toBe(false);\n     * expect(element(by.exactRepeater('car in cars')).isPresent()).toBe(true);\n     *\n     * @param {string} repeatDescriptor\n     * @returns {ProtractorLocator} location strategy\n     */\n    exactRepeater(repeatDescriptor) {\n        return this.byRepeaterInner(true, repeatDescriptor);\n    }\n    /**\n     * Find elements by CSS which contain a certain string.\n     *\n     * @view\n     * <ul>\n     *   <li class=\"pet\">Dog</li>\n     *   <li class=\"pet\">Cat</li>\n     * </ul>\n     *\n     * @example\n     * // Returns the li for the dog, but not cat.\n     * var dog = element(by.cssContainingText('.pet', 'Dog'));\n     *\n     * @param {string} cssSelector css selector\n     * @param {string} searchString text search\n     * @returns {ProtractorLocator} location strategy\n     */\n    cssContainingText(cssSelector, searchText) {\n        return {\n            findElementsOverride: (driver, using, rootSelector) => {\n                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findByCssContainingText, cssSelector, searchText, using, rootSelector));\n            },\n            toString: () => {\n                return 'by.cssContainingText(\"' + cssSelector + '\", \"' + searchText + '\")';\n            }\n        };\n    }\n    ;\n    /**\n     * Find an element by ng-options expression.\n     *\n     * @alias by.options(optionsDescriptor)\n     * @view\n     * <select ng-model=\"color\" ng-options=\"c for c in colors\">\n     *   <option value=\"0\" selected=\"selected\">red</option>\n     *   <option value=\"1\">green</option>\n     * </select>\n     *\n     * @example\n     * var allOptions = element.all(by.options('c for c in colors'));\n     * expect(allOptions.count()).toEqual(2);\n     * var firstOption = allOptions.first();\n     * expect(firstOption.getText()).toEqual('red');\n     *\n     * @param {string} optionsDescriptor ng-options expression.\n     * @returns {ProtractorLocator} location strategy\n     */\n    options(optionsDescriptor) {\n        return {\n            findElementsOverride: (driver, using, rootSelector) => {\n                return driver.findElements(selenium_webdriver_1.By.js(clientSideScripts.findByOptions, optionsDescriptor, using, rootSelector));\n            },\n            toString: () => {\n                return 'by.option(\"' + optionsDescriptor + '\")';\n            }\n        };\n    }\n    ;\n    /**\n     * Find an element by css selector within the Shadow DOM.\n     *\n     * @alias by.deepCss(selector)\n     * @view\n     * <div>\n     *   <span id=\"outerspan\">\n     *   <\"shadow tree\">\n     *     <span id=\"span1\"></span>\n     *     <\"shadow tree\">\n     *       <span id=\"span2\"></span>\n     *     </>\n     *   </>\n     * </div>\n     * @example\n     * var spans = element.all(by.deepCss('span'));\n     * expect(spans.count()).toEqual(3);\n     *\n     * @param {string} selector a css selector within the Shadow DOM.\n     * @returns {Locator} location strategy\n     */\n    deepCss(selector) {\n        // TODO(julie): syntax will change from /deep/ to >>> at some point.\n        // When that is supported, switch it here.\n        return selenium_webdriver_1.By.css('* /deep/ ' + selector);\n    }\n    ;\n}\nexports.ProtractorBy = ProtractorBy;\n//# sourceMappingURL=locators.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/clientsidescripts.js":"/**\n * All scripts to be run on the client via executeAsyncScript or\n * executeScript should be put here.\n *\n * NOTE: These scripts are transmitted over the wire as JavaScript text\n * constructed using their toString representation, and *cannot*\n * reference external variables.\n *\n * Some implementations seem to have issues with // comments, so use star-style\n * inside scripts.  (TODO: add issue number / example implementations\n * that caused the switch to avoid the // comments.)\n */\n\n// jshint browser: true\n// jshint shadow: true\n/* global angular */\nvar functions = {};\n\n///////////////////////////////////////////////////////\n////                                               ////\n////                    HELPERS                    ////\n////                                               ////\n///////////////////////////////////////////////////////\n\n\n/* Wraps a function up into a string with its helper functions so that it can\n * call those helper functions client side\n *\n * @param {function} fun The function to wrap up with its helpers\n * @param {...function} The helper functions.  Each function must be named\n *\n * @return {string} The string which, when executed, will invoke fun in such a\n *   way that it has access to its helper functions\n */\nfunction wrapWithHelpers(fun) {\n  var helpers = Array.prototype.slice.call(arguments, 1);\n  if (!helpers.length) {\n    return fun;\n  }\n  var FunClass = Function; // Get the linter to allow this eval\n  return new FunClass(\n      helpers.join(';') + String.fromCharCode(59) +\n      '  return (' + fun.toString() + ').apply(this, arguments);');\n}\n\n/* Tests if an ngRepeat matches a repeater\n *\n * @param {string} ngRepeat The ngRepeat to test\n * @param {string} repeater The repeater to test against\n * @param {boolean} exact If the ngRepeat expression needs to match the whole\n *   repeater (not counting any `track by ...` modifier) or if it just needs to\n *   match a substring\n * @return {boolean} If the ngRepeat matched the repeater\n */\nfunction repeaterMatch(ngRepeat, repeater, exact) {\n  if (exact) {\n    return ngRepeat.split(' track by ')[0].split(' as ')[0].split('|')[0].\n        split('=')[0].trim() == repeater;\n  } else {\n    return ngRepeat.indexOf(repeater) != -1;\n  }\n}\n\n/* Tries to find $$testability and possibly $injector for an ng1 app\n *\n * By default, doesn't care about $injector if it finds $$testability.  However,\n * these priorities can be reversed.\n *\n * @param {string=} selector The selector for the element with the injector.  If\n *   falsy, tries a variety of methods to find an injector\n * @param {boolean=} injectorPlease Prioritize finding an injector\n * @return {$$testability?: Testability, $injector?: Injector} Returns whatever\n *   ng1 app hooks it finds\n */\nfunction getNg1Hooks(selector, injectorPlease) {\n  function tryEl(el) {\n    try {\n      if (!injectorPlease && angular.getTestability) {\n        var $$testability = angular.getTestability(el);\n        if ($$testability) {\n          return {$$testability: $$testability};\n        }\n      } else {\n        var $injector = angular.element(el).injector();\n        if ($injector) {\n          return {$injector: $injector};\n        }\n      }\n    } catch(err) {} \n  }\n  function trySelector(selector) {\n    var els = document.querySelectorAll(selector);\n    for (var i = 0; i < els.length; i++) {\n      var elHooks = tryEl(els[i]);\n      if (elHooks) {\n        return elHooks;\n      }\n    }\n  }\n\n  if (selector) {\n    return trySelector(selector);\n  } else if (window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__) {\n    var $injector = window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__;\n    var $$testability = null;\n    try {\n      $$testability = $injector.get('$$testability');\n    } catch (e) {}\n    return {$injector: $injector, $$testability: $$testability};\n  } else {\n    return tryEl(document.body) ||\n        trySelector('[ng-app]') || trySelector('[ng\\\\:app]') ||\n        trySelector('[ng-controller]') || trySelector('[ng\\\\:controller]');\n  }\n}\n\n///////////////////////////////////////////////////////\n////                                               ////\n////                    SCRIPTS                    ////\n////                                               ////\n///////////////////////////////////////////////////////\n\n\n/**\n * Wait until Angular has finished rendering and has\n * no outstanding $http calls before continuing. The specific Angular app\n * is determined by the rootSelector.\n *\n * Asynchronous.\n *\n * @param {string} rootSelector The selector housing an ng-app\n * @param {function(string)} callback callback. If a failure occurs, it will\n *     be passed as a parameter.\n */\nfunctions.waitForAngular = function(rootSelector, callback) {\n  try {\n    if (window.angular && !(window.angular.version &&\n          window.angular.version.major > 1)) {\n      /* ng1 */\n      var hooks = getNg1Hooks(rootSelector);\n      if (hooks.$$testability) {\n        hooks.$$testability.whenStable(callback);\n      } else if (hooks.$injector) {\n        hooks.$injector.get('$browser').\n            notifyWhenNoOutstandingRequests(callback);\n      } else if (!!rootSelector) {\n        throw new Error('Could not automatically find injector on page: \"' +\n            window.location.toString() + '\".  Consider using config.rootEl');\n      } else {\n        throw new Error('root element (' + rootSelector + ') has no injector.' +\n           ' this may mean it is not inside ng-app.');\n      }\n    } else if (rootSelector && window.getAngularTestability) {\n      var el = document.querySelector(rootSelector);\n      window.getAngularTestability(el).whenStable(callback);\n    } else if (window.getAllAngularTestabilities) {\n      var testabilities = window.getAllAngularTestabilities();\n      var count = testabilities.length;\n      var decrement = function() {\n        count--;\n        if (count === 0) {\n          callback();\n        }\n      };\n      testabilities.forEach(function(testability) {\n        testability.whenStable(decrement);\n      });\n    } else if (!window.angular) {\n      throw new Error('window.angular is undefined.  This could be either ' +\n          'because this is a non-angular page or because your test involves ' +\n          'client-side navigation, which can interfere with Protractor\\'s ' +\n          'bootstrapping.  See http://git.io/v4gXM for details');\n    } else if (window.angular.version >= 2) {\n      throw new Error('You appear to be using angular, but window.' +\n          'getAngularTestability was never set.  This may be due to bad ' +\n          'obfuscation.');\n    } else {\n      throw new Error('Cannot get testability API for unknown angular ' +\n          'version \"' + window.angular.version + '\"');\n    }\n  } catch (err) {\n    callback(err.message);\n  }\n};\n\n/**\n * Find a list of elements in the page by their angular binding.\n *\n * @param {string} binding The binding, e.g. {{cat.name}}.\n * @param {boolean} exactMatch Whether the binding needs to be matched exactly\n * @param {Element} using The scope of the search.\n * @param {string} rootSelector The selector to use for the root app element.\n *\n * @return {Array.<Element>} The elements containing the binding.\n */\nfunctions.findBindings = function(binding, exactMatch, using, rootSelector) {\n  using = using || document;\n  if (angular.getTestability) {\n    return getNg1Hooks(rootSelector).$$testability.\n        findBindings(using, binding, exactMatch);\n  }\n  var bindings = using.getElementsByClassName('ng-binding');\n  var matches = [];\n  for (var i = 0; i < bindings.length; ++i) {\n    var dataBinding = angular.element(bindings[i]).data('$binding');\n    if (dataBinding) {\n      var bindingName = dataBinding.exp || dataBinding[0].exp || dataBinding;\n      if (exactMatch) {\n        var matcher = new RegExp('({|\\\\s|^|\\\\|)' +\n            /* See http://stackoverflow.com/q/3561711 */\n            binding.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&') +\n            '(}|\\\\s|$|\\\\|)');\n        if (matcher.test(bindingName)) {\n          matches.push(bindings[i]);\n        }\n      } else {\n        if (bindingName.indexOf(binding) != -1) {\n          matches.push(bindings[i]);\n        }\n      }\n\n    }\n  }\n  return matches; /* Return the whole array for webdriver.findElements. */\n};\n\n/**\n * Find an array of elements matching a row within an ng-repeat.\n * Always returns an array of only one element for plain old ng-repeat.\n * Returns an array of all the elements in one segment for ng-repeat-start.\n *\n * @param {string} repeater The text of the repeater, e.g. 'cat in cats'.\n * @param {boolean} exact Whether the repeater needs to be matched exactly\n * @param {number} index The row index.\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} The row of the repeater, or an array of elements\n *     in the first row in the case of ng-repeat-start.\n */\nfunction findRepeaterRows(repeater, exact, index, using) {\n  using = using || document;\n\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n  var rows = [];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        rows.push(repeatElems[i]);\n      }\n    }\n  }\n  /* multiRows is an array of arrays, where each inner array contains\n     one row of elements. */\n  var multiRows = [];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat-start';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        var elem = repeatElems[i];\n        var row = [];\n        while (elem.nodeType != 8 ||\n            !repeaterMatch(elem.nodeValue, repeater)) {\n          if (elem.nodeType == 1) {\n            row.push(elem);\n          }\n          elem = elem.nextSibling;\n        }\n        multiRows.push(row);\n      }\n    }\n  }\n  var row = rows[index] || [], multiRow = multiRows[index] || [];\n  return [].concat(row, multiRow);\n}\nfunctions.findRepeaterRows = wrapWithHelpers(findRepeaterRows, repeaterMatch); \n\n /**\n * Find all rows of an ng-repeat.\n *\n * @param {string} repeater The text of the repeater, e.g. 'cat in cats'.\n * @param {boolean} exact Whether the repeater needs to be matched exactly\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} All rows of the repeater.\n */\nfunction findAllRepeaterRows(repeater, exact, using) {\n  using = using || document;\n\n  var rows = [];\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        rows.push(repeatElems[i]);\n      }\n    }\n  }\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat-start';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        var elem = repeatElems[i];\n        while (elem.nodeType != 8 ||\n            !repeaterMatch(elem.nodeValue, repeater)) {\n          if (elem.nodeType == 1) {\n            rows.push(elem);\n          }\n          elem = elem.nextSibling;\n        }\n      }\n    }\n  }\n  return rows;\n}\nfunctions.findAllRepeaterRows = wrapWithHelpers(findAllRepeaterRows, repeaterMatch);\n\n/**\n * Find an element within an ng-repeat by its row and column.\n *\n * @param {string} repeater The text of the repeater, e.g. 'cat in cats'.\n * @param {boolean} exact Whether the repeater needs to be matched exactly\n * @param {number} index The row index.\n * @param {string} binding The column binding, e.g. '{{cat.name}}'.\n * @param {Element} using The scope of the search.\n * @param {string} rootSelector The selector to use for the root app element.\n *\n * @return {Array.<Element>} The element in an array.\n */\nfunction findRepeaterElement(repeater, exact, index, binding, using, rootSelector) {\n  var matches = [];\n  using = using || document;\n\n  var rows = [];\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        rows.push(repeatElems[i]);\n      }\n    }\n  }\n  /* multiRows is an array of arrays, where each inner array contains\n     one row of elements. */\n  var multiRows = [];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat-start';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        var elem = repeatElems[i];\n        var row = [];\n        while (elem.nodeType != 8 || (elem.nodeValue &&\n            !repeaterMatch(elem.nodeValue, repeater))) {\n          if (elem.nodeType == 1) {\n            row.push(elem);\n          }\n          elem = elem.nextSibling;\n        }\n        multiRows.push(row);\n      }\n    }\n  }\n  var row = rows[index];\n  var multiRow = multiRows[index];\n  var bindings = [];\n  if (row) {\n    if (angular.getTestability) {\n      matches.push.apply(\n          matches,\n          getNg1Hooks(rootSelector).$$testability.findBindings(row, binding));\n    } else {\n      if (row.className.indexOf('ng-binding') != -1) {\n        bindings.push(row);\n      }\n      var childBindings = row.getElementsByClassName('ng-binding');\n      for (var i = 0; i < childBindings.length; ++i) {\n        bindings.push(childBindings[i]);\n      }\n    }\n  }\n  if (multiRow) {\n    for (var i = 0; i < multiRow.length; ++i) {\n      var rowElem = multiRow[i];\n      if (angular.getTestability) {\n        matches.push.apply(\n            matches,\n            getNg1Hooks(rootSelector).$$testability.findBindings(rowElem,\n                binding));\n      } else {\n        if (rowElem.className.indexOf('ng-binding') != -1) {\n          bindings.push(rowElem);\n        }\n        var childBindings = rowElem.getElementsByClassName('ng-binding');\n        for (var j = 0; j < childBindings.length; ++j) {\n          bindings.push(childBindings[j]);\n        }\n      }\n    }\n  }\n  for (var i = 0; i < bindings.length; ++i) {\n    var dataBinding = angular.element(bindings[i]).data('$binding');\n    if (dataBinding) {\n      var bindingName = dataBinding.exp || dataBinding[0].exp || dataBinding;\n      if (bindingName.indexOf(binding) != -1) {\n        matches.push(bindings[i]);\n      }\n    }\n  }\n  return matches;\n}\nfunctions.findRepeaterElement =\n    wrapWithHelpers(findRepeaterElement, repeaterMatch, getNg1Hooks);\n\n/**\n * Find the elements in a column of an ng-repeat.\n *\n * @param {string} repeater The text of the repeater, e.g. 'cat in cats'.\n * @param {boolean} exact Whether the repeater needs to be matched exactly\n * @param {string} binding The column binding, e.g. '{{cat.name}}'.\n * @param {Element} using The scope of the search.\n * @param {string} rootSelector The selector to use for the root app element.\n *\n * @return {Array.<Element>} The elements in the column.\n */\nfunction findRepeaterColumn(repeater, exact, binding, using, rootSelector) {\n  var matches = [];\n  using = using || document;\n\n  var rows = [];\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        rows.push(repeatElems[i]);\n      }\n    }\n  }\n  /* multiRows is an array of arrays, where each inner array contains\n     one row of elements. */\n  var multiRows = [];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var attr = prefixes[p] + 'repeat-start';\n    var repeatElems = using.querySelectorAll('[' + attr + ']');\n    attr = attr.replace(/\\\\/g, '');\n    for (var i = 0; i < repeatElems.length; ++i) {\n      if (repeaterMatch(repeatElems[i].getAttribute(attr), repeater, exact)) {\n        var elem = repeatElems[i];\n        var row = [];\n        while (elem.nodeType != 8 || (elem.nodeValue &&\n            !repeaterMatch(elem.nodeValue, repeater))) {\n          if (elem.nodeType == 1) {\n            row.push(elem);\n          }\n          elem = elem.nextSibling;\n        }\n        multiRows.push(row);\n      }\n    }\n  }\n  var bindings = [];\n  for (var i = 0; i < rows.length; ++i) {\n    if (angular.getTestability) {\n      matches.push.apply(\n          matches,\n          getNg1Hooks(rootSelector).$$testability.findBindings(rows[i],\n              binding));\n    } else {\n      if (rows[i].className.indexOf('ng-binding') != -1) {\n        bindings.push(rows[i]);\n      }\n      var childBindings = rows[i].getElementsByClassName('ng-binding');\n      for (var k = 0; k < childBindings.length; ++k) {\n        bindings.push(childBindings[k]);\n      }\n    }\n  }\n  for (var i = 0; i < multiRows.length; ++i) {\n    for (var j = 0; j < multiRows[i].length; ++j) {\n      if (angular.getTestability) {\n        matches.push.apply(\n            matches,\n            getNg1Hooks(rootSelector).$$testability.findBindings(\n                multiRows[i][j], binding));\n      } else {\n        var elem = multiRows[i][j];\n        if (elem.className.indexOf('ng-binding') != -1) {\n          bindings.push(elem);\n        }\n        var childBindings = elem.getElementsByClassName('ng-binding');\n        for (var k = 0; k < childBindings.length; ++k) {\n          bindings.push(childBindings[k]);\n        }\n      }\n    }\n  }\n  for (var j = 0; j < bindings.length; ++j) {\n    var dataBinding = angular.element(bindings[j]).data('$binding');\n    if (dataBinding) {\n      var bindingName = dataBinding.exp || dataBinding[0].exp || dataBinding;\n      if (bindingName.indexOf(binding) != -1) {\n        matches.push(bindings[j]);\n      }\n    }\n  }\n  return matches;\n}\nfunctions.findRepeaterColumn =\n    wrapWithHelpers(findRepeaterColumn, repeaterMatch, getNg1Hooks);\n\n/**\n * Find elements by model name.\n *\n * @param {string} model The model name.\n * @param {Element} using The scope of the search.\n * @param {string} rootSelector The selector to use for the root app element.\n *\n * @return {Array.<Element>} The matching elements.\n */\nfunctions.findByModel = function(model, using, rootSelector) {\n  using = using || document;\n\n  if (angular.getTestability) {\n    return getNg1Hooks(rootSelector).$$testability.\n        findModels(using, model, true);\n  }\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var selector = '[' + prefixes[p] + 'model=\"' + model + '\"]';\n    var elements = using.querySelectorAll(selector);\n    if (elements.length) {\n      return elements;\n    }\n  }\n};\n\n/**\n * Find elements by options.\n *\n * @param {string} optionsDescriptor The descriptor for the option\n *     (i.e. fruit for fruit in fruits).\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} The matching elements.\n */\nfunctions.findByOptions = function(optionsDescriptor, using) {\n  using = using || document;\n\n  var prefixes = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\\\:'];\n  for (var p = 0; p < prefixes.length; ++p) {\n    var selector = '[' + prefixes[p] + 'options=\"' + optionsDescriptor + '\"] option';\n    var elements = using.querySelectorAll(selector);\n    if (elements.length) {\n      return elements;\n    }\n  }\n};\n\n/**\n * Find buttons by textual content.\n *\n * @param {string} searchText The exact text to match.\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} The matching elements.\n */\nfunctions.findByButtonText = function(searchText, using) {\n  using = using || document;\n\n  var elements = using.querySelectorAll('button, input[type=\"button\"], input[type=\"submit\"]');\n  var matches = [];\n  for (var i = 0; i < elements.length; ++i) {\n    var element = elements[i];\n    var elementText;\n    if (element.tagName.toLowerCase() == 'button') {\n      elementText = element.textContent || element.innerText || '';\n    } else {\n      elementText = element.value;\n    }\n    if (elementText.trim() === searchText) {\n      matches.push(element);\n    }\n  }\n\n  return matches;\n};\n\n/**\n * Find buttons by textual content.\n *\n * @param {string} searchText The exact text to match.\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} The matching elements.\n */\nfunctions.findByPartialButtonText = function(searchText, using) {\n  using = using || document;\n\n  var elements = using.querySelectorAll('button, input[type=\"button\"], input[type=\"submit\"]');\n  var matches = [];\n  for (var i = 0; i < elements.length; ++i) {\n    var element = elements[i];\n    var elementText;\n    if (element.tagName.toLowerCase() == 'button') {\n      elementText = element.textContent || element.innerText || '';\n    } else {\n      elementText = element.value;\n    }\n    if (elementText.indexOf(searchText) > -1) {\n      matches.push(element);\n    }\n  }\n\n  return matches;\n};\n\n/**\n * Find elements by css selector and textual content.\n *\n * @param {string} cssSelector The css selector to match.\n * @param {string} searchText The exact text to match.\n * @param {Element} using The scope of the search.\n *\n * @return {Array.<Element>} An array of matching elements.\n */\nfunctions.findByCssContainingText = function(cssSelector, searchText, using) {\n  using = using || document;\n\n  var elements = using.querySelectorAll(cssSelector);\n  var matches = [];\n  for (var i = 0; i < elements.length; ++i) {\n    var element = elements[i];\n    var elementText = element.textContent || element.innerText || '';\n    if (elementText.indexOf(searchText) > -1) {\n      matches.push(element);\n    }\n  }\n  return matches;\n};\n\n/**\n * Tests whether the angular global variable is present on a page. Retries\n * in case the page is just loading slowly.\n *\n * Asynchronous.\n *\n * @param {number} attempts Number of times to retry.\n * @param {boolean} ng12Hybrid Flag set if app is a hybrid of angular 1 and 2\n * @param {function({version: ?number, message: ?string})} asyncCallback callback\n *\n */\nfunctions.testForAngular = function(attempts, ng12Hybrid, asyncCallback) {\n  var callback = function(args) {\n    setTimeout(function() {\n      asyncCallback(args);\n    }, 0);\n  };\n  var definitelyNg1 = !!ng12Hybrid;\n  var definitelyNg2OrNewer = false;\n  var check = function(n) {\n    try {\n      /* Figure out which version of angular we're waiting on */\n      if (!definitelyNg1 && !definitelyNg2OrNewer) {\n        if (window.angular && !(window.angular.version && window.angular.version.major > 1)) {\n          definitelyNg1 = true;\n        } else if (window.getAllAngularTestabilities) {\n          definitelyNg2OrNewer = true;\n        }\n      }\n      /* See if our version of angular is ready */\n      if (definitelyNg1) {\n        if (window.angular && window.angular.resumeBootstrap) {\n          return callback({ver: 1});\n        }\n      } else if (definitelyNg2OrNewer) {\n        if (true /* ng2 has no resumeBootstrap() */) {\n          return callback({ver: 2});\n        }\n      }\n      /* Try again (or fail) */\n      if (n < 1) {\n        if (definitelyNg1 && window.angular) {\n          callback({message: 'angular never provided resumeBootstrap'});\n        } else if (ng12Hybrid && !window.angular) { \n          callback({message: 'angular 1 never loaded' +\n              window.getAllAngularTestabilities ? ' (are you sure this app ' +\n              'uses ngUpgrade?  Try un-setting ng12Hybrid)' : ''});\n        } else {\n          callback({message: 'retries looking for angular exceeded'});\n        }\n      } else {\n        window.setTimeout(function() {check(n - 1);}, 1000);\n      }\n    } catch (e) {\n      callback({message: e});\n    }\n  };\n  check(attempts);\n};\n\n/**\n * Evalute an Angular expression in the context of a given element.\n *\n * @param {Element} element The element in whose scope to evaluate.\n * @param {string} expression The expression to evaluate.\n *\n * @return {?Object} The result of the evaluation.\n */\nfunctions.evaluate = function(element, expression) {\n  return angular.element(element).scope().$eval(expression);\n};\n\nfunctions.allowAnimations = function(element, value) {\n  var ngElement = angular.element(element);\n  if (ngElement.allowAnimations) {\n    // AngularDart: $testability API.\n    return ngElement.allowAnimations(value);\n  } else {\n    // AngularJS\n    var enabledFn = ngElement.injector().get('$animate').enabled;\n    return (value == null) ? enabledFn() : enabledFn(value);\n  }\n};\n\n/**\n * Return the current url using $location.absUrl().\n *\n * @param {string} selector The selector housing an ng-app\n */\nfunctions.getLocationAbsUrl = function(selector) {\n  var hooks = getNg1Hooks(selector);\n  if (angular.getTestability) {\n    return hooks.$$testability.getLocation();\n  }\n  return hooks.$injector.get('$location').absUrl();\n};\n\n/**\n * Browse to another page using in-page navigation.\n *\n * @param {string} selector The selector housing an ng-app\n * @param {string} url In page URL using the same syntax as $location.url(),\n *     /path?search=a&b=c#hash\n */\nfunctions.setLocation = function(selector, url) {\n  var hooks = getNg1Hooks(selector);\n  if (angular.getTestability) {\n    return hooks.$$testability.setLocation(url);\n  }\n  var $injector = hooks.$injector;\n  var $location = $injector.get('$location');\n  var $rootScope = $injector.get('$rootScope');\n\n  if (url !== $location.url()) {\n    $location.url(url);\n    $rootScope.$digest();\n  }\n};\n\n/**\n * Retrieve the pending $http requests.\n *\n * @param {string} selector The selector housing an ng-app\n * @return {!Array<!Object>} An array of pending http requests.\n */\nfunctions.getPendingHttpRequests = function(selector) {\n  var hooks = getNg1Hooks(selector, true);\n  var $http = hooks.$injector.get('$http');\n  return $http.pendingRequests;\n};\n\n['waitForAngular', 'findBindings', 'findByModel', 'getLocationAbsUrl',\n  'setLocation', 'getPendingHttpRequests'].forEach(function(funName) {\n    functions[funName] = wrapWithHelpers(functions[funName], getNg1Hooks);\n});\n\n/* Publish all the functions as strings to pass to WebDriver's\n * exec[Async]Script.  In addition, also include a script that will\n * install all the functions on window (for debugging.)\n *\n * We also wrap any exceptions thrown by a clientSideScripts function\n * that is not an instance of the Error type into an Error type.  If we\n * don't do so, then the resulting stack trace is completely unhelpful\n * and the exception message is just \"unknown error.\"  These types of\n * exceptions are the common case for dart2js code.  This wrapping gives\n * us the Dart stack trace and exception message.\n */\nvar util = require('util');\nvar scriptsList = [];\nvar scriptFmt = (\n    'try { return (%s).apply(this, arguments); }\\n' +\n    'catch(e) { throw (e instanceof Error) ? e : new Error(e); }');\nfor (var fnName in functions) {\n  if (functions.hasOwnProperty(fnName)) {\n    exports[fnName] = util.format(scriptFmt, functions[fnName]);\n    scriptsList.push(util.format('%s: %s', fnName, functions[fnName]));\n  }\n}\n\nexports.installInBrowser = (util.format(\n    'window.clientSideScripts = {%s};', scriptsList.join(', ')));\n\n/**\n * Automatically installed by Protractor when a page is loaded, this\n * default mock module decorates $timeout to keep track of any\n * outstanding timeouts.\n *\n * @param {boolean} trackOutstandingTimeouts\n */\nexports.protractorBaseModuleFn = function(trackOutstandingTimeouts) {\n  var ngMod = angular.module('protractorBaseModule_', []).config([\n    '$compileProvider',\n    function($compileProvider) {\n      if ($compileProvider.debugInfoEnabled) {\n        $compileProvider.debugInfoEnabled(true);\n      }\n    }\n  ]);\n  if (trackOutstandingTimeouts) {\n    ngMod.config([\n      '$provide',\n      function ($provide) {\n        $provide.decorator('$timeout', [\n          '$delegate',\n          function ($delegate) {\n            var $timeout = $delegate;\n\n            var taskId = 0;\n\n            if (!window['NG_PENDING_TIMEOUTS']) {\n              window['NG_PENDING_TIMEOUTS'] = {};\n            }\n\n            var extendedTimeout= function() {\n              var args = Array.prototype.slice.call(arguments);\n              if (typeof(args[0]) !== 'function') {\n                return $timeout.apply(null, args);\n              }\n\n              taskId++;\n              var fn = args[0];\n              window['NG_PENDING_TIMEOUTS'][taskId] =\n                  fn.toString();\n              var wrappedFn = (function(taskId_) {\n                return function() {\n                  delete window['NG_PENDING_TIMEOUTS'][taskId_];\n                  return fn.apply(null, arguments);\n                };\n              })(taskId);\n              args[0] = wrappedFn;\n\n              var promise = $timeout.apply(null, args);\n              promise.ptorTaskId_ = taskId;\n              return promise;\n            };\n\n            extendedTimeout.cancel = function() {\n              var taskId_ = arguments[0] && arguments[0].ptorTaskId_;\n              if (taskId_) {\n                delete window['NG_PENDING_TIMEOUTS'][taskId_];\n              }\n              return $timeout.cancel.apply($timeout, arguments);\n            };\n\n            return extendedTimeout;\n          }\n        ]);\n      }\n    ]);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/util.js":"\"use strict\";\nconst path_1 = require('path');\nconst q_1 = require('q');\nconst selenium_webdriver_1 = require('selenium-webdriver');\nlet STACK_SUBSTRINGS_TO_FILTER = [\n    'node_modules/jasmine/', 'node_modules/selenium-webdriver', 'at Module.', 'at Object.Module.',\n    'at Function.Module', '(timers.js:', 'jasminewd2/index.js', 'protractor/lib/'\n];\n/**\n * Utility function that filters a stack trace to be more readable. It removes\n * Jasmine test frames and webdriver promise resolution.\n * @param {string} text Original stack trace.\n * @return {string}\n */\nfunction filterStackTrace(text) {\n    if (!text) {\n        return text;\n    }\n    let lines = text.split(/\\n/).filter((line) => {\n        for (let filter of STACK_SUBSTRINGS_TO_FILTER) {\n            if (line.indexOf(filter) !== -1) {\n                return false;\n            }\n        }\n        return true;\n    });\n    return lines.join('\\n');\n}\nexports.filterStackTrace = filterStackTrace;\n/**\n * Internal helper for abstraction of polymorphic filenameOrFn properties.\n * @param {object} filenameOrFn The filename or function that we will execute.\n * @param {Array.<object>}} args The args to pass into filenameOrFn.\n * @return {q.Promise} A promise that will resolve when filenameOrFn completes.\n */\nfunction runFilenameOrFn_(configDir, filenameOrFn, args) {\n    return q_1.Promise((resolvePromise) => {\n        if (filenameOrFn && !(typeof filenameOrFn === 'string' || typeof filenameOrFn === 'function')) {\n            throw new Error('filenameOrFn must be a string or function');\n        }\n        if (typeof filenameOrFn === 'string') {\n            filenameOrFn = require(path_1.resolve(configDir, filenameOrFn));\n        }\n        if (typeof filenameOrFn === 'function') {\n            let results = q_1.when(filenameOrFn.apply(null, args), null, (err) => {\n                if (typeof err === 'string') {\n                    err = new Error(err);\n                }\n                else {\n                    err = err;\n                    if (!err.stack) {\n                        err.stack = new Error().stack;\n                    }\n                }\n                err.stack = exports.filterStackTrace(err.stack);\n                throw err;\n            });\n            resolvePromise(results);\n        }\n        else {\n            resolvePromise(undefined);\n        }\n    });\n}\nexports.runFilenameOrFn_ = runFilenameOrFn_;\n/**\n * Joins two logs of test results, each following the format of <framework>.run\n * @param {object} log1\n * @param {object} log2\n * @return {object} The joined log\n */\nfunction joinTestLogs(log1, log2) {\n    return {\n        failedCount: log1.failedCount + log2.failedCount,\n        specResults: (log1.specResults || []).concat(log2.specResults || [])\n    };\n}\nexports.joinTestLogs = joinTestLogs;\n/**\n * Returns false if an error indicates a missing or stale element, re-throws\n * the error otherwise\n *\n * @param {*} The error to check\n * @throws {*} The error it was passed if it doesn't indicate a missing or stale\n *   element\n * @return {boolean} false, if it doesn't re-throw the error\n */\nfunction falseIfMissing(error) {\n    if ((error instanceof selenium_webdriver_1.error.NoSuchElementError) ||\n        (error instanceof selenium_webdriver_1.error.StaleElementReferenceError)) {\n        return false;\n    }\n    else {\n        throw error;\n    }\n}\nexports.falseIfMissing = falseIfMissing;\n/**\n * Return a boolean given boolean value.\n *\n * @param {boolean} value\n * @returns {boolean} given value\n */\nfunction passBoolean(value) {\n    return value;\n}\nexports.passBoolean = passBoolean;\n//# sourceMappingURL=util.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/expectedConditions.js":"\"use strict\";\nconst selenium_webdriver_1 = require('selenium-webdriver');\nconst util_1 = require('./util');\n/**\n * Represents a library of canned expected conditions that are useful for\n * protractor, especially when dealing with non-angular apps.\n *\n * Each condition returns a function that evaluates to a promise. You may mix\n * multiple conditions using `and`, `or`, and/or `not`. You may also\n * mix these conditions with any other conditions that you write.\n *\n * See ExpectedCondition Class in Selenium WebDriver codebase.\n * http://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html\n *\n *\n * @example\n * var EC = protractor.ExpectedConditions;\n * var button = $('#xyz');\n * var isClickable = EC.elementToBeClickable(button);\n *\n * browser.get(URL);\n * browser.wait(isClickable, 5000); //wait for an element to become clickable\n * button.click();\n *\n * // You can define your own expected condition, which is a function that\n * // takes no parameter and evaluates to a promise of a boolean.\n * var urlChanged = function() {\n *   return browser.getCurrentUrl().then(function(url) {\n *     return url === 'http://www.angularjs.org';\n *   });\n * };\n *\n * // You can customize the conditions with EC.and, EC.or, and EC.not.\n * // Here's a condition to wait for url to change, $('abc') element to contain\n * // text 'bar', and button becomes clickable.\n * var condition = EC.and(urlChanged, EC.textToBePresentInElement($('abc'),\n * 'bar'), isClickable);\n * browser.get(URL);\n * browser.wait(condition, 5000); //wait for condition to be true.\n * button.click();\n *\n * @alias ExpectedConditions\n * @constructor\n */\nclass ProtractorExpectedConditions {\n    constructor(browser) {\n        this.browser = browser;\n    }\n    ;\n    /**\n     * Negates the result of a promise.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * var titleIsNotFoo = EC.not(EC.titleIs('Foo'));\n     * // Waits for title to become something besides 'foo'.\n     * browser.wait(titleIsNotFoo, 5000);\n     *\n     * @alias ExpectedConditions.not\n     * @param {!function} expectedCondition\n     *\n     * @returns {!function} An expected condition that returns the negated value.\n     */\n    not(expectedCondition) {\n        return () => {\n            return expectedCondition().then((bool) => {\n                return !bool;\n            });\n        };\n    }\n    /**\n     * Helper function that is equivalent to the logical_and if defaultRet==true,\n     * or logical_or if defaultRet==false\n     *\n     * @private\n     * @param {boolean} defaultRet\n     * @param {Array.<Function>} fns An array of expected conditions to chain.\n     *\n     * @returns {!function} An expected condition that returns a promise which\n     *     evaluates to the result of the logical chain.\n     */\n    logicalChain_(defaultRet, fns) {\n        let self = this;\n        return () => {\n            if (fns.length === 0) {\n                return defaultRet;\n            }\n            let fn = fns[0];\n            return fn().then((bool) => {\n                if (bool === defaultRet) {\n                    return self.logicalChain_(defaultRet, fns.slice(1))();\n                }\n                else {\n                    return !defaultRet;\n                }\n            });\n        };\n    }\n    /**\n     * Chain a number of expected conditions using logical_and, short circuiting\n     * at the first expected condition that evaluates to false.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * var titleContainsFoo = EC.titleContains('Foo');\n     * var titleIsNotFooBar = EC.not(EC.titleIs('FooBar'));\n     * // Waits for title to contain 'Foo', but is not 'FooBar'\n     * browser.wait(EC.and(titleContainsFoo, titleIsNotFooBar), 5000);\n     *\n     * @alias ExpectedConditions.and\n     * @param {Array.<Function>} fns An array of expected conditions to 'and'\n     * together.\n     *\n     * @returns {!function} An expected condition that returns a promise which\n     *     evaluates to the result of the logical and.\n     */\n    and(...args) {\n        return this.logicalChain_(true, args);\n    }\n    /**\n     * Chain a number of expected conditions using logical_or, short circuiting\n     * at the first expected condition that evaluates to true.\n     *\n     * @alias ExpectedConditions.or\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * var titleContainsFoo = EC.titleContains('Foo');\n     * var titleContainsBar = EC.titleContains('Bar');\n     * // Waits for title to contain either 'Foo' or 'Bar'\n     * browser.wait(EC.or(titleContainsFoo, titleContainsBar), 5000);\n     *\n     * @param {Array.<Function>} fns An array of expected conditions to 'or'\n     * together.\n     *\n     * @returns {!function} An expected condition that returns a promise which\n     *     evaluates to the result of the logical or.\n     */\n    or(...args) {\n        return this.logicalChain_(false, args);\n    }\n    /**\n     * Expect an alert to be present.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for an alert pops up.\n     * browser.wait(EC.alertIsPresent(), 5000);\n     *\n     * @alias ExpectedConditions.alertIsPresent\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether an alert is present.\n     */\n    alertIsPresent() {\n        return () => {\n            return this.browser.driver.switchTo().alert().then(() => {\n                return true;\n            }, (err) => {\n                if (err instanceof selenium_webdriver_1.error.NoSuchAlertError) {\n                    return false;\n                }\n                else {\n                    throw err;\n                }\n            });\n        };\n    }\n    /**\n     * An Expectation for checking an element is visible and enabled such that you\n     * can click it.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to be clickable.\n     * browser.wait(EC.elementToBeClickable($('#abc')), 5000);\n     *\n     * @alias ExpectedConditions.elementToBeClickable\n     * @param {!ElementFinder} elementFinder The element to check\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the element is clickable.\n     */\n    elementToBeClickable(elementFinder) {\n        return this.and(this.visibilityOf(elementFinder), () => {\n            return elementFinder.isEnabled().then(util_1.passBoolean, util_1.falseIfMissing);\n        });\n    }\n    /**\n     * An expectation for checking if the given text is present in the\n     * element. Returns false if the elementFinder does not find an element.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to contain the text 'foo'.\n     * browser.wait(EC.textToBePresentInElement($('#abc'), 'foo'), 5000);\n     *\n     * @alias ExpectedConditions.textToBePresentInElement\n     * @param {!ElementFinder} elementFinder The element to check\n     * @param {!string} text The text to verify against\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the text is present in the element.\n     */\n    textToBePresentInElement(elementFinder, text) {\n        let hasText = () => {\n            return elementFinder.getText().then((actualText) => {\n                // MSEdge does not properly remove newlines, which causes false\n                // negatives\n                return actualText.replace(/\\r?\\n|\\r/g, '').indexOf(text) > -1;\n            }, util_1.falseIfMissing);\n        };\n        return this.and(this.presenceOf(elementFinder), hasText);\n    }\n    /**\n     * An expectation for checking if the given text is present in the elements\n     * value. Returns false if the elementFinder does not find an element.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'myInput' to contain the input 'foo'.\n     * browser.wait(EC.textToBePresentInElementValue($('#myInput'), 'foo'), 5000);\n     *\n     * @alias ExpectedConditions.textToBePresentInElement\n     * @param {!ElementFinder} elementFinder The element to check\n     * @param {!string} text The text to verify against\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the text is present in the element's value.\n     */\n    textToBePresentInElementValue(elementFinder, text) {\n        let hasText = () => {\n            return elementFinder.getAttribute('value').then((actualText) => {\n                return actualText.indexOf(text) > -1;\n            }, util_1.falseIfMissing);\n        };\n        return this.and(this.presenceOf(elementFinder), hasText);\n    }\n    /**\n     * An expectation for checking that the title contains a case-sensitive\n     * substring.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the title to contain 'foo'.\n     * browser.wait(EC.titleContains('foo'), 5000);\n     *\n     * @alias ExpectedConditions.titleContains\n     * @param {!string} title The fragment of title expected\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the title contains the string.\n     */\n    titleContains(title) {\n        return () => {\n            return this.browser.driver.getTitle().then((actualTitle) => {\n                return actualTitle.indexOf(title) > -1;\n            });\n        };\n    }\n    /**\n     * An expectation for checking the title of a page.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the title to be 'foo'.\n     * browser.wait(EC.titleIs('foo'), 5000);\n     *\n     * @alias ExpectedConditions.titleIs\n     * @param {!string} title The expected title, which must be an exact match.\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the title equals the string.\n     */\n    titleIs(title) {\n        return () => {\n            return this.browser.driver.getTitle().then((actualTitle) => {\n                return actualTitle === title;\n            });\n        };\n    }\n    /**\n     * An expectation for checking that the URL contains a case-sensitive\n     * substring.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the URL to contain 'foo'.\n     * browser.wait(EC.urlContains('foo'), 5000);\n     *\n     * @alias ExpectedConditions.urlContains\n     * @param {!string} url The fragment of URL expected\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the URL contains the string.\n     */\n    urlContains(url) {\n        return () => {\n            return this.browser.driver.getCurrentUrl().then((actualUrl) => {\n                return actualUrl.indexOf(url) > -1;\n            });\n        };\n    }\n    /**\n     * An expectation for checking the URL of a page.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the URL to be 'foo'.\n     * browser.wait(EC.urlIs('foo'), 5000);\n     *\n     * @alias ExpectedConditions.urlIs\n     * @param {!string} url The expected URL, which must be an exact match.\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the url equals the string.\n     */\n    urlIs(url) {\n        return () => {\n            return this.browser.driver.getCurrentUrl().then((actualUrl) => {\n                return actualUrl === url;\n            });\n        };\n    }\n    /**\n     * An expectation for checking that an element is present on the DOM\n     * of a page. This does not necessarily mean that the element is visible.\n     * This is the opposite of 'stalenessOf'.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to be present on the dom.\n     * browser.wait(EC.presenceOf($('#abc')), 5000);\n     *\n     * @alias ExpectedConditions.presenceOf\n     * @param {!ElementFinder} elementFinder The element to check\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the element is present.\n     */\n    presenceOf(elementFinder) {\n        return elementFinder.isPresent.bind(elementFinder);\n    }\n    ;\n    /**\n     * An expectation for checking that an element is not attached to the DOM\n     * of a page. This is the opposite of 'presenceOf'.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to be no longer present on the dom.\n     * browser.wait(EC.stalenessOf($('#abc')), 5000);\n     *\n     * @alias ExpectedConditions.stalenessOf\n     * @param {!ElementFinder} elementFinder The element to check\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the element is stale.\n     */\n    stalenessOf(elementFinder) {\n        return this.not(this.presenceOf(elementFinder));\n    }\n    /**\n     * An expectation for checking that an element is present on the DOM of a\n     * page and visible. Visibility means that the element is not only displayed\n     * but also has a height and width that is greater than 0. This is the\n     * opposite\n     * of 'invisibilityOf'.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to be visible on the dom.\n     * browser.wait(EC.visibilityOf($('#abc')), 5000);\n     *\n     * @alias ExpectedConditions.visibilityOf\n     * @param {!ElementFinder} elementFinder The element to check\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the element is visible.\n     */\n    visibilityOf(elementFinder) {\n        return this.and(this.presenceOf(elementFinder), () => {\n            return elementFinder.isDisplayed().then(util_1.passBoolean, util_1.falseIfMissing);\n        });\n    }\n    /**\n     * An expectation for checking that an element is either invisible or not\n     * present on the DOM. This is the opposite of 'visibilityOf'.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to be no longer visible on the dom.\n     * browser.wait(EC.invisibilityOf($('#abc')), 5000);\n     *\n     * @alias ExpectedConditions.invisibilityOf\n     * @param {!ElementFinder} elementFinder The element to check\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the element is invisible.\n     */\n    invisibilityOf(elementFinder) {\n        return this.not(this.visibilityOf(elementFinder));\n    }\n    /**\n   * An expectation for checking the selection is selected.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'myCheckbox' to be selected.\n   * browser.wait(EC.elementToBeSelected($('#myCheckbox')), 5000);\n   *\n   * @alias ExpectedConditions.elementToBeSelected\n   * @param {!ElementFinder} elementFinder The element to check\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the element is selected.\n   */\n    elementToBeSelected(elementFinder) {\n        return this.and(this.presenceOf(elementFinder), () => {\n            return elementFinder.isSelected().then(util_1.passBoolean, util_1.falseIfMissing);\n        });\n    }\n}\nexports.ProtractorExpectedConditions = ProtractorExpectedConditions;\n//# sourceMappingURL=expectedConditions.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/ptor.js":"\"use strict\";\nconst webdriver = require('selenium-webdriver');\nconst chrome = require('selenium-webdriver/chrome');\nconst firefox = require('selenium-webdriver/firefox');\nconst http = require('selenium-webdriver/http');\nconst remote = require('selenium-webdriver/remote');\nclass Ptor {\n    constructor() {\n        this.$ = function (search) {\n            return null;\n        };\n        this.$$ = function (search) {\n            return null;\n        };\n        // Export protractor classes.\n        this.ProtractorBrowser = require('./browser').ProtractorBrowser;\n        this.ElementFinder = require('./element').ElementFinder;\n        this.ElementArrayFinder = require('./element').ElementArrayFinder;\n        this.ProtractorBy = require('./locators').ProtractorBy;\n        this.ProtractorExpectedConditions = require('./expectedConditions').ProtractorExpectedConditions;\n        // Export selenium webdriver.\n        this.ActionSequence = webdriver.ActionSequence;\n        this.Browser = webdriver.Browser;\n        this.Builder = webdriver.Builder;\n        this.Button = webdriver.Button;\n        this.Capabilities = webdriver.Capabilities;\n        this.Capability = webdriver.Capability;\n        this.EventEmitter = webdriver.EventEmitter;\n        this.FileDetector = webdriver.FileDetector;\n        this.Key = webdriver.Key;\n        this.Session = webdriver.Session;\n        this.WebDriver = webdriver.WebDriver;\n        this.WebElement = webdriver.WebElement;\n        this.WebElementPromise = webdriver.WebElementPromise;\n        this.error = webdriver.error;\n        this.logging = webdriver.logging;\n        this.promise = webdriver.promise;\n        this.until = webdriver.until;\n        this.Command = require('selenium-webdriver/lib/command').Command;\n        this.CommandName = require('selenium-webdriver/lib/command').Name;\n        this.utils = { firefox: firefox, http: http, remote: remote, chrome: chrome };\n    }\n}\nexports.Ptor = Ptor;\nexports.protractor = new Ptor();\n//# sourceMappingURL=ptor.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/bpRunner.js":"\"use strict\";\nconst child_process_1 = require('child_process');\nconst q = require('q');\nconst logger_1 = require('./logger');\nconst BP_PATH = require.resolve('blocking-proxy/built/lib/bin.js');\nlet logger = new logger_1.Logger('BlockingProxy');\nclass BlockingProxyRunner {\n    constructor(config) {\n        this.config = config;\n    }\n    start() {\n        return q.Promise((resolve, reject) => {\n            this.checkSupportedConfig();\n            let args = [\n                '--fork',\n                '--seleniumAddress',\n                this.config.seleniumAddress,\n            ];\n            if (this.config.webDriverLogDir) {\n                args.push('--logDir', this.config.webDriverLogDir);\n            }\n            if (this.config.highlightDelay) {\n                args.push('--highlightDelay', this.config.highlightDelay.toString());\n            }\n            this.bpProcess = child_process_1.fork(BP_PATH, args, { silent: true });\n            logger.info('Starting BlockingProxy with args: ' + args.toString());\n            this.bpProcess\n                .on('message', (data) => {\n                this.port = data['port'];\n                resolve(data['port']);\n            })\n                .on('error', (err) => {\n                reject(new Error('Unable to start BlockingProxy ' + err));\n            })\n                .on('exit', (code, signal) => {\n                reject(new Error('BP exited with ' + code));\n                logger.error('Exited with ' + code);\n                logger.error('signal ' + signal);\n            });\n            this.bpProcess.stdout.on('data', (msg) => {\n                logger.debug(msg.toString().trim());\n            });\n            this.bpProcess.stderr.on('data', (msg) => {\n                logger.error(msg.toString().trim());\n            });\n            process.on('exit', () => {\n                this.bpProcess.kill();\n            });\n        });\n    }\n    checkSupportedConfig() {\n        if (this.config.directConnect) {\n            throw new Error('BlockingProxy not yet supported with directConnect!');\n        }\n    }\n}\nexports.BlockingProxyRunner = BlockingProxyRunner;\n//# sourceMappingURL=bpRunner.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/config.js":"\"use strict\";\n//# sourceMappingURL=config.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/configParser.js":"\"use strict\";\nconst glob = require('glob');\nconst path = require('path');\nconst exitCodes_1 = require('./exitCodes');\nconst logger_1 = require('./logger');\nlet logger = new logger_1.Logger('configParser');\n// Coffee is required here to enable config files written in coffee-script.\ntry {\n    require('coffee-script').register();\n}\ncatch (e) {\n}\n// LiveScript is required here to enable config files written in LiveScript.\ntry {\n    require('LiveScript');\n}\ncatch (e) {\n}\nclass ConfigParser {\n    constructor() {\n        // Default configuration.\n        this.config_ = {\n            specs: [],\n            multiCapabilities: [],\n            verboseMultiSessions: false,\n            rootElement: '',\n            allScriptsTimeout: 11000,\n            getPageTimeout: 10000,\n            params: {},\n            framework: 'jasmine',\n            jasmineNodeOpts: { showColors: true, defaultTimeoutInterval: (30 * 1000) },\n            seleniumArgs: [],\n            mochaOpts: { ui: 'bdd', reporter: 'list' },\n            configDir: './',\n            noGlobals: false,\n            plugins: [],\n            skipSourceMapSupport: false,\n            ng12Hybrid: false\n        };\n    }\n    /**\n     * Resolve a list of file patterns into a list of individual file paths.\n     *\n     * @param {Array.<string> | string} patterns\n     * @param {=boolean} opt_omitWarnings Whether to omit did not match warnings\n     * @param {=string} opt_relativeTo Path to resolve patterns against\n     *\n     * @return {Array} The resolved file paths.\n     */\n    static resolveFilePatterns(patterns, opt_omitWarnings, opt_relativeTo) {\n        let resolvedFiles = [];\n        let cwd = opt_relativeTo || process.cwd();\n        patterns = (typeof patterns === 'string') ? [patterns] : patterns;\n        if (patterns) {\n            for (let fileName of patterns) {\n                let matches = glob.hasMagic(fileName) ? glob.sync(fileName, { cwd }) : [fileName];\n                if (!matches.length && !opt_omitWarnings) {\n                    logger.warn('pattern ' + fileName + ' did not match any files.');\n                }\n                for (let match of matches) {\n                    let resolvedPath = path.resolve(cwd, match);\n                    resolvedFiles.push(resolvedPath);\n                }\n            }\n        }\n        return resolvedFiles;\n    }\n    /**\n     * Returns only the specs that should run currently based on `config.suite`\n     *\n     * @return {Array} An array of globs locating the spec files\n     */\n    static getSpecs(config) {\n        let specs = [];\n        if (config.suite) {\n            config.suite.split(',').forEach((suite) => {\n                let suiteList = config.suites ? config.suites[suite] : null;\n                if (suiteList == null) {\n                    throw new exitCodes_1.ConfigError(logger, 'Unknown test suite: ' + suite);\n                }\n                union(specs, makeArray(suiteList));\n            });\n            return specs;\n        }\n        if (config.specs.length > 0) {\n            return config.specs;\n        }\n        Object.keys(config.suites || {}).forEach((suite) => {\n            union(specs, makeArray(config.suites[suite]));\n        });\n        return specs;\n    }\n    /**\n     * Add the options in the parameter config to this runner instance.\n     *\n     * @private\n     * @param {Object} additionalConfig\n     * @param {string} relativeTo the file path to resolve paths against\n     */\n    addConfig_(additionalConfig, relativeTo) {\n        // All filepaths should be kept relative to the current config location.\n        // This will not affect absolute paths.\n        ['seleniumServerJar', 'chromeDriver', 'onPrepare', 'firefoxPath', 'frameworkPath'].forEach((name) => {\n            if (additionalConfig[name] && typeof additionalConfig[name] === 'string') {\n                additionalConfig[name] = path.resolve(relativeTo, additionalConfig[name]);\n            }\n        });\n        merge_(this.config_, additionalConfig);\n    }\n    /**\n     * Public function specialized towards merging in a file's config\n     *\n     * @public\n     * @param {String} filename\n     */\n    addFileConfig(filename) {\n        if (!filename) {\n            return this;\n        }\n        let filePath = path.resolve(process.cwd(), filename);\n        let fileConfig;\n        try {\n            fileConfig = require(filePath).config;\n        }\n        catch (e) {\n            throw new exitCodes_1.ConfigError(logger, 'failed loading configuration file ' + filename, e);\n        }\n        if (!fileConfig) {\n            throw new exitCodes_1.ConfigError(logger, 'configuration file ' + filename + ' did not export a config object');\n        }\n        fileConfig.configDir = path.dirname(filePath);\n        this.addConfig_(fileConfig, fileConfig.configDir);\n        return this;\n    }\n    /**\n     * Public function specialized towards merging in config from argv\n     *\n     * @public\n     * @param {Object} argv\n     */\n    addConfig(argv) {\n        this.addConfig_(argv, process.cwd());\n        return this;\n    }\n    /**\n     * Public getter for the final, computed config object\n     *\n     * @public\n     * @return {Object} config\n     */\n    getConfig() {\n        return this.config_;\n    }\n}\nexports.ConfigParser = ConfigParser;\n/**\n * Merge config objects together.\n *\n * @private\n * @param {Object} into\n * @param {Object} from\n *\n * @return {Object} The 'into' config.\n */\nlet merge_ = function (into, from) {\n    for (let key in from) {\n        if (into[key] instanceof Object && !(into[key] instanceof Array) &&\n            !(into[key] instanceof Function)) {\n            merge_(into[key], from[key]);\n        }\n        else {\n            into[key] = from[key];\n        }\n    }\n    return into;\n};\n/**\n * Returns the item if it's an array or puts the item in an array\n * if it was not one already.\n */\nlet makeArray = function (item) {\n    return Array.isArray(item) ? item : [item];\n};\n/**\n * Adds to an array all the elements in another array without adding any\n * duplicates\n *\n * @param {Array<string>} dest The array to add to\n * @param {Array<string>} src The array to copy from\n */\nlet union = function (dest, src) {\n    let elems = {};\n    for (let key in dest) {\n        elems[dest[key]] = true;\n    }\n    for (let key in src) {\n        if (!elems[src[key]]) {\n            dest.push(src[key]);\n            elems[src[key]] = true;\n        }\n    }\n};\n//# sourceMappingURL=configParser.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/exitCodes.js":"\"use strict\";\nconst CONFIG_ERROR_CODE = 105;\nconst BROWSER_CONNECT_ERROR_CODE = 135;\nconst KITCHEN_SINK_CODE = 199;\nclass IError extends Error {\n}\nexports.IError = IError;\nclass ProtractorError extends IError {\n    constructor(logger, message, code, error) {\n        super(message);\n        this.message = message;\n        this.code = code;\n        // replacing the stack trace with the thrown error stack trace.\n        if (error) {\n            let protractorError = error;\n            this.stack = protractorError.stack;\n        }\n        ProtractorError.log(logger, this.code, this.message, this.stack);\n        if (!ProtractorError.SUPRESS_EXIT_CODE) {\n            process.exit(this.code);\n        }\n    }\n    static log(logger, code, message, stack) {\n        let messages = message.split('\\n');\n        if (messages.length > 1) {\n            message = messages[0];\n        }\n        logger.error('Error code: ' + code);\n        logger.error('Error message: ' + message);\n        logger.error(stack);\n    }\n}\nProtractorError.CODE = KITCHEN_SINK_CODE;\nProtractorError.SUPRESS_EXIT_CODE = false;\nexports.ProtractorError = ProtractorError;\n/**\n * Configuration file error\n */\nclass ConfigError extends ProtractorError {\n    constructor(logger, message, error) {\n        super(logger, message, ConfigError.CODE, error);\n    }\n}\nConfigError.CODE = CONFIG_ERROR_CODE;\nexports.ConfigError = ConfigError;\n/**\n * Browser errors including getting a driver session, direct connect, etc.\n */\nclass BrowserError extends ProtractorError {\n    constructor(logger, message) {\n        super(logger, message, BrowserError.CODE);\n    }\n}\nBrowserError.CODE = BROWSER_CONNECT_ERROR_CODE;\nBrowserError.ERR_MSGS = [\n    'ECONNREFUSED connect ECONNREFUSED', 'Sauce Labs Authentication Error',\n    'Invalid username or password'\n];\nexports.BrowserError = BrowserError;\nclass ErrorHandler {\n    static isError(errMsgs, e) {\n        if (errMsgs && errMsgs.length > 0) {\n            for (let errPos in errMsgs) {\n                let errMsg = errMsgs[errPos];\n                if (e.message && e.message.indexOf(errMsg) !== -1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    static parseError(e) {\n        if (ErrorHandler.isError(ConfigError.ERR_MSGS, e)) {\n            return ConfigError.CODE;\n        }\n        if (ErrorHandler.isError(BrowserError.ERR_MSGS, e)) {\n            return BrowserError.CODE;\n        }\n        return null;\n    }\n}\nexports.ErrorHandler = ErrorHandler;\n//# sourceMappingURL=exitCodes.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/launcher.js":"\"use strict\";\n/**\n * The launcher is responsible for parsing the capabilities from the\n * input configuration and launching test runners.\n */\nconst fs = require('fs');\nconst q = require('q');\nconst configParser_1 = require('./configParser');\nconst exitCodes_1 = require('./exitCodes');\nconst logger_1 = require('./logger');\nconst runner_1 = require('./runner');\nconst taskRunner_1 = require('./taskRunner');\nconst taskScheduler_1 = require('./taskScheduler');\nconst helper = require('./util');\nlet logger = new logger_1.Logger('launcher');\nlet RUNNERS_FAILED_EXIT_CODE = 100;\n/**\n * Keeps track of a list of task results. Provides method to add a new\n * result, aggregate the results into a summary, count failures,\n * and save results into a JSON file.\n */\nclass TaskResults {\n    constructor() {\n        // TODO: set a type for result\n        this.results_ = [];\n    }\n    add(result) {\n        this.results_.push(result);\n    }\n    totalSpecFailures() {\n        return this.results_.reduce((specFailures, result) => {\n            return specFailures + result.failedCount;\n        }, 0);\n    }\n    totalProcessFailures() {\n        return this.results_.reduce((processFailures, result) => {\n            return !result.failedCount && result.exitCode !== 0 ? processFailures + 1 : processFailures;\n        }, 0);\n    }\n    saveResults(filepath) {\n        let jsonOutput = this.results_.reduce((jsonOutput, result) => {\n            return jsonOutput.concat(result.specResults);\n        }, []);\n        let json = JSON.stringify(jsonOutput, null, '  ');\n        fs.writeFileSync(filepath, json);\n    }\n    reportSummary() {\n        let specFailures = this.totalSpecFailures();\n        let processFailures = this.totalProcessFailures();\n        this.results_.forEach((result) => {\n            let capabilities = result.capabilities;\n            let shortName = (capabilities.browserName) ? capabilities.browserName : '';\n            shortName = (capabilities.logName) ?\n                capabilities.logName :\n                (capabilities.browserName) ? capabilities.browserName : '';\n            shortName += (capabilities.version) ? capabilities.version : '';\n            shortName += (capabilities.logName && capabilities.count < 2) ? '' : ' #' + result.taskId;\n            if (result.failedCount) {\n                logger.info(shortName + ' failed ' + result.failedCount + ' test(s)');\n            }\n            else if (result.exitCode !== 0) {\n                logger.info(shortName + ' failed with exit code: ' + result.exitCode);\n            }\n            else {\n                logger.info(shortName + ' passed');\n            }\n        });\n        if (specFailures && processFailures) {\n            logger.info('overall: ' + specFailures + ' failed spec(s) and ' + processFailures +\n                ' process(es) failed to complete');\n        }\n        else if (specFailures) {\n            logger.info('overall: ' + specFailures + ' failed spec(s)');\n        }\n        else if (processFailures) {\n            logger.info('overall: ' + processFailures + ' process(es) failed to complete');\n        }\n    }\n}\nlet taskResults_ = new TaskResults();\n/**\n * Initialize and run the tests.\n * Exits with 1 on test failure, and RUNNERS_FAILED_EXIT_CODE on unexpected\n * failures.\n *\n * @param {string=} configFile\n * @param {Object=} additionalConfig\n */\nlet initFn = function (configFile, additionalConfig) {\n    let configParser = new configParser_1.ConfigParser();\n    if (configFile) {\n        configParser.addFileConfig(configFile);\n    }\n    if (additionalConfig) {\n        configParser.addConfig(additionalConfig);\n    }\n    let config = configParser.getConfig();\n    logger_1.Logger.set(config);\n    logger.debug('Running with --troubleshoot');\n    logger.debug('Protractor version: ' + require('../package.json').version);\n    logger.debug('Your base url for tests is ' + config.baseUrl);\n    // Run beforeLaunch\n    helper.runFilenameOrFn_(config.configDir, config.beforeLaunch)\n        .then(() => {\n        return q\n            .Promise((resolve, reject) => {\n            // 1) If getMultiCapabilities is set, resolve that as\n            // `multiCapabilities`.\n            if (config.getMultiCapabilities &&\n                typeof config.getMultiCapabilities === 'function') {\n                if (config.multiCapabilities.length || config.capabilities) {\n                    logger.warn('getMultiCapabilities() will override both capabilities ' +\n                        'and multiCapabilities');\n                }\n                // If getMultiCapabilities is defined and a function, use this.\n                q(config.getMultiCapabilities())\n                    .then((multiCapabilities) => {\n                    config.multiCapabilities = multiCapabilities;\n                    config.capabilities = null;\n                })\n                    .then(() => {\n                    resolve();\n                })\n                    .catch(err => {\n                    reject(err);\n                });\n            }\n            else {\n                resolve();\n            }\n        })\n            .then(() => {\n            // 2) Set `multicapabilities` using `capabilities`,\n            // `multicapabilities`,\n            // or default\n            if (config.capabilities) {\n                if (config.multiCapabilities.length) {\n                    logger.warn('You have specified both capabilities and ' +\n                        'multiCapabilities. This will result in capabilities being ' +\n                        'ignored');\n                }\n                else {\n                    // Use capabilities if multiCapabilities is empty.\n                    config.multiCapabilities = [config.capabilities];\n                }\n            }\n            else if (!config.multiCapabilities.length) {\n                // Default to chrome if no capabilities given\n                config.multiCapabilities = [{ browserName: 'chrome' }];\n            }\n        });\n    })\n        .then(() => {\n        // 3) If we're in `elementExplorer` mode, run only that.\n        if (config.elementExplorer || config.framework === 'explorer') {\n            if (config.multiCapabilities.length != 1) {\n                throw new Error('Must specify only 1 browser while using elementExplorer');\n            }\n            else {\n                config.capabilities = config.multiCapabilities[0];\n            }\n            config.framework = 'explorer';\n            let runner = new runner_1.Runner(config);\n            return runner.run().then((exitCode) => {\n                process.exit(exitCode);\n            }, (err) => {\n                logger.error(err);\n                process.exit(1);\n            });\n        }\n    })\n        .then(() => {\n        // 4) Run tests.\n        let scheduler = new taskScheduler_1.TaskScheduler(config);\n        process.on('uncaughtException', (exc) => {\n            let e = (exc instanceof Error) ? exc : new Error(exc);\n            if (config.ignoreUncaughtExceptions) {\n                // This can be a sign of a bug in the test framework, that it may\n                // not be handling WebDriver errors properly. However, we don't\n                // want these errors to prevent running the tests.\n                logger.warn('Ignoring uncaught error ' + exc);\n                return;\n            }\n            let errorCode = exitCodes_1.ErrorHandler.parseError(e);\n            if (errorCode) {\n                let protractorError = e;\n                exitCodes_1.ProtractorError.log(logger, errorCode, protractorError.message, protractorError.stack);\n                process.exit(errorCode);\n            }\n            else {\n                logger.error(e.message);\n                logger.error(e.stack);\n                process.exit(exitCodes_1.ProtractorError.CODE);\n            }\n        });\n        process.on('exit', (code) => {\n            if (code) {\n                logger.error('Process exited with error code ' + code);\n            }\n            else if (scheduler.numTasksOutstanding() > 0) {\n                logger.error('BUG: launcher exited with ' + scheduler.numTasksOutstanding() +\n                    ' tasks remaining');\n                process.exit(RUNNERS_FAILED_EXIT_CODE);\n            }\n        });\n        // Run afterlaunch and exit\n        let cleanUpAndExit = (exitCode) => {\n            return helper.runFilenameOrFn_(config.configDir, config.afterLaunch, [exitCode])\n                .then((returned) => {\n                if (typeof returned === 'number') {\n                    process.exit(returned);\n                }\n                else {\n                    process.exit(exitCode);\n                }\n            }, (err) => {\n                logger.error('Error:', err);\n                process.exit(1);\n            });\n        };\n        let totalTasks = scheduler.numTasksOutstanding();\n        let forkProcess = false;\n        if (totalTasks > 1) {\n            forkProcess = true;\n            if (config.debug) {\n                throw new exitCodes_1.ConfigError(logger, 'Cannot run in debug mode with multiCapabilities, count > 1, or sharding');\n            }\n        }\n        let deferred = q.defer(); // Resolved when all tasks are completed\n        let createNextTaskRunner = () => {\n            let task = scheduler.nextTask();\n            if (task) {\n                let taskRunner = new taskRunner_1.TaskRunner(configFile, additionalConfig, task, forkProcess);\n                taskRunner.run()\n                    .then((result) => {\n                    if (result.exitCode && !result.failedCount) {\n                        logger.error('Runner process exited unexpectedly with error code: ' + result.exitCode);\n                    }\n                    taskResults_.add(result);\n                    task.done();\n                    createNextTaskRunner();\n                    // If all tasks are finished\n                    if (scheduler.numTasksOutstanding() === 0) {\n                        deferred.resolve();\n                    }\n                    logger.info(scheduler.countActiveTasks() + ' instance(s) of WebDriver still running');\n                })\n                    .catch((err) => {\n                    logger.error('Error:', err.stack || err.message || err);\n                    cleanUpAndExit(RUNNERS_FAILED_EXIT_CODE);\n                });\n            }\n        };\n        // Start `scheduler.maxConcurrentTasks()` workers for handling tasks in\n        // the beginning. As a worker finishes a task, it will pick up the next\n        // task\n        // from the scheduler's queue until all tasks are gone.\n        for (let i = 0; i < scheduler.maxConcurrentTasks(); ++i) {\n            createNextTaskRunner();\n        }\n        logger.info('Running ' + scheduler.countActiveTasks() + ' instances of WebDriver');\n        // By now all runners have completed.\n        deferred.promise\n            .then(function () {\n            // Save results if desired\n            if (config.resultJsonOutputFile) {\n                taskResults_.saveResults(config.resultJsonOutputFile);\n            }\n            taskResults_.reportSummary();\n            let exitCode = 0;\n            if (taskResults_.totalProcessFailures() > 0) {\n                exitCode = RUNNERS_FAILED_EXIT_CODE;\n            }\n            else if (taskResults_.totalSpecFailures() > 0) {\n                exitCode = 1;\n            }\n            return cleanUpAndExit(exitCode);\n        })\n            .done();\n    })\n        .done();\n};\nexports.init = initFn;\n//# sourceMappingURL=launcher.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/runner.js":"\"use strict\";\nconst events_1 = require('events');\nconst q = require('q');\nconst selenium_webdriver_1 = require('selenium-webdriver');\nconst util = require('util');\nconst browser_1 = require('./browser');\nconst driverProviders_1 = require('./driverProviders');\nconst logger_1 = require('./logger');\nconst plugins_1 = require('./plugins');\nconst ptor_1 = require('./ptor');\nconst helper = require('./util');\nlet logger = new logger_1.Logger('runner');\n/*\n * Runner is responsible for starting the execution of a test run and triggering\n * setup, teardown, managing config, etc through its various dependencies.\n *\n * The Protractor Runner is a node EventEmitter with the following events:\n * - testPass\n * - testFail\n * - testsDone\n *\n * @param {Object} config\n * @constructor\n */\nclass Runner extends events_1.EventEmitter {\n    constructor(config) {\n        super();\n        /**\n         * Responsible for cleaning up test run and exiting the process.\n         * @private\n         * @param {int} Standard unix exit code\n         */\n        this.exit_ = function (exitCode) {\n            return helper.runFilenameOrFn_(this.config_.configDir, this.config_.onCleanUp, [exitCode])\n                .then((returned) => {\n                if (typeof returned === 'number') {\n                    return returned;\n                }\n                else {\n                    return exitCode;\n                }\n            });\n        };\n        this.config_ = config;\n        if (config.v8Debug) {\n            // Call this private function instead of sending SIGUSR1 because Windows.\n            process['_debugProcess'](process.pid);\n        }\n        if (config.nodeDebug) {\n            process['_debugProcess'](process.pid);\n            let flow = selenium_webdriver_1.promise.controlFlow();\n            this.ready_ = flow.execute(() => {\n                let nodedebug = require('child_process').fork('debug', ['localhost:5858']);\n                process.on('exit', function () {\n                    nodedebug.kill('SIGTERM');\n                });\n                nodedebug.on('exit', function () {\n                    process.exit(1);\n                });\n            }, 'start the node debugger').then(() => {\n                return flow.timeout(1000, 'waiting for debugger to attach');\n            });\n        }\n        if (config.capabilities && config.capabilities.seleniumAddress) {\n            config.seleniumAddress = config.capabilities.seleniumAddress;\n        }\n        this.loadDriverProvider_(config);\n        this.setTestPreparer(config.onPrepare);\n    }\n    /**\n     * Registrar for testPreparers - executed right before tests run.\n     * @public\n     * @param {string/Fn} filenameOrFn\n     */\n    setTestPreparer(filenameOrFn) {\n        this.preparer_ = filenameOrFn;\n    }\n    /**\n     * Executor of testPreparer\n     * @public\n     * @param {string[]=} An optional list of command line arguments the framework will accept.\n     * @return {q.Promise} A promise that will resolve when the test preparers\n     *     are finished.\n     */\n    runTestPreparer(extraFlags) {\n        let unknownFlags = this.config_.unknownFlags_ || [];\n        if (extraFlags) {\n            unknownFlags = unknownFlags.filter((f) => extraFlags.indexOf(f) === -1);\n        }\n        if (unknownFlags.length > 0 && !this.config_.disableChecks) {\n            // TODO: Make this throw a ConfigError in Protractor 6.\n            logger.warn('Ignoring unknown extra flags: ' + unknownFlags.join(', ') + '. This will be' +\n                ' an error in future versions, please use --disableChecks flag to disable the ' +\n                ' Protractor CLI flag checks. ');\n        }\n        return this.plugins_.onPrepare().then(() => {\n            return helper.runFilenameOrFn_(this.config_.configDir, this.preparer_);\n        });\n    }\n    /**\n     * Called after each test finishes.\n     *\n     * Responsible for `restartBrowserBetweenTests`\n     *\n     * @public\n     * @return {q.Promise} A promise that will resolve when the work here is done\n     */\n    afterEach() {\n        let ret;\n        this.frameworkUsesAfterEach = true;\n        if (this.config_.restartBrowserBetweenTests) {\n            this.restartPromise = this.restartPromise || q(ptor_1.protractor.browser.restart());\n            ret = this.restartPromise;\n            this.restartPromise = undefined;\n        }\n        return ret || q();\n    }\n    /**\n     * Grab driver provider based on type\n     * @private\n     *\n     * Priority\n     * 1) if directConnect is true, use that\n     * 2) if seleniumAddress is given, use that\n     * 3) if a Sauce Labs account is given, use that\n     * 4) if a seleniumServerJar is specified, use that\n     * 5) try to find the seleniumServerJar in protractor/selenium\n     */\n    loadDriverProvider_(config) {\n        this.config_ = config;\n        this.driverprovider_ = driverProviders_1.buildDriverProvider(this.config_);\n    }\n    /**\n     * Getter for the Runner config object\n     * @public\n     * @return {Object} config\n     */\n    getConfig() {\n        return this.config_;\n    }\n    /**\n     * Get the control flow used by this runner.\n     * @return {Object} WebDriver control flow.\n     */\n    controlFlow() {\n        return selenium_webdriver_1.promise.controlFlow();\n    }\n    /**\n     * Sets up convenience globals for test specs\n     * @private\n     */\n    setupGlobals_(browser_) {\n        // Keep $, $$, element, and by/By under the global protractor namespace\n        ptor_1.protractor.browser = browser_;\n        ptor_1.protractor.$ = browser_.$;\n        ptor_1.protractor.$$ = browser_.$$;\n        ptor_1.protractor.element = browser_.element;\n        ptor_1.protractor.by = ptor_1.protractor.By = browser_1.ProtractorBrowser.By;\n        ptor_1.protractor.ExpectedConditions = browser_.ExpectedConditions;\n        if (!this.config_.noGlobals) {\n            // Export protractor to the global namespace to be used in tests.\n            global.browser = browser_;\n            global.$ = browser_.$;\n            global.$$ = browser_.$$;\n            global.element = browser_.element;\n            global.by = global.By = ptor_1.protractor.By;\n            global.ExpectedConditions = ptor_1.protractor.ExpectedConditions;\n        }\n        global.protractor = ptor_1.protractor;\n        if (!this.config_.skipSourceMapSupport) {\n            // Enable sourcemap support for stack traces.\n            require('source-map-support').install();\n        }\n        // Required by dart2js machinery.\n        // https://code.google.com/p/dart/source/browse/branches/bleeding_edge/dart/sdk/lib/js/dart2js/js_dart2js.dart?spec=svn32943&r=32943#487\n        global.DartObject = function (o) {\n            this.o = o;\n        };\n    }\n    /**\n     * Create a new driver from a driverProvider. Then set up a\n     * new protractor instance using this driver.\n     * This is used to set up the initial protractor instances and any\n     * future ones.\n     *\n     * @param {Plugin} plugins The plugin functions\n     * @param {ProtractorBrowser=} parentBrowser The browser which spawned this one\n     *\n     * @return {Protractor} a protractor instance.\n     * @public\n     */\n    createBrowser(plugins, parentBrowser) {\n        let config = this.config_;\n        let driver = this.driverprovider_.getNewDriver();\n        let blockingProxyUrl;\n        if (config.useBlockingProxy) {\n            blockingProxyUrl = this.driverprovider_.getBPUrl();\n        }\n        let initProperties = {\n            baseUrl: config.baseUrl,\n            rootElement: config.rootElement,\n            untrackOutstandingTimeouts: config.untrackOutstandingTimeouts,\n            params: config.params,\n            getPageTimeout: config.getPageTimeout,\n            allScriptsTimeout: config.allScriptsTimeout,\n            debuggerServerPort: config.debuggerServerPort,\n            ng12Hybrid: config.ng12Hybrid,\n            waitForAngularEnabled: true\n        };\n        if (parentBrowser) {\n            initProperties.baseUrl = parentBrowser.baseUrl;\n            initProperties.rootElement = parentBrowser.angularAppRoot();\n            initProperties.untrackOutstandingTimeouts = !parentBrowser.trackOutstandingTimeouts_;\n            initProperties.params = parentBrowser.params;\n            initProperties.getPageTimeout = parentBrowser.getPageTimeout;\n            initProperties.allScriptsTimeout = parentBrowser.allScriptsTimeout;\n            initProperties.debuggerServerPort = parentBrowser.debuggerServerPort;\n            initProperties.ng12Hybrid = parentBrowser.ng12Hybrid;\n            initProperties.waitForAngularEnabled = parentBrowser.waitForAngularEnabled();\n        }\n        let browser_ = new browser_1.ProtractorBrowser(driver, initProperties.baseUrl, initProperties.rootElement, initProperties.untrackOutstandingTimeouts, blockingProxyUrl);\n        browser_.params = initProperties.params;\n        browser_.plugins_ = plugins || new plugins_1.Plugins({});\n        if (initProperties.getPageTimeout) {\n            browser_.getPageTimeout = initProperties.getPageTimeout;\n        }\n        if (initProperties.allScriptsTimeout) {\n            browser_.allScriptsTimeout = initProperties.allScriptsTimeout;\n        }\n        if (initProperties.debuggerServerPort) {\n            browser_.debuggerServerPort = initProperties.debuggerServerPort;\n        }\n        if (initProperties.ng12Hybrid) {\n            browser_.ng12Hybrid = initProperties.ng12Hybrid;\n        }\n        browser_.ready =\n            browser_.ready\n                .then(() => {\n                return browser_.waitForAngularEnabled(initProperties.waitForAngularEnabled);\n            })\n                .then(() => {\n                return driver.manage().timeouts().setScriptTimeout(initProperties.allScriptsTimeout);\n            })\n                .then(() => {\n                return browser_;\n            });\n        browser_.getProcessedConfig = () => {\n            return selenium_webdriver_1.promise.when(config);\n        };\n        browser_.forkNewDriverInstance =\n                (useSameUrl, copyMockModules, copyConfigUpdates = true) => {\n                let newBrowser = this.createBrowser(plugins);\n                if (copyMockModules) {\n                    newBrowser.mockModules_ = browser_.mockModules_;\n                }\n                if (useSameUrl) {\n                    newBrowser.ready = newBrowser.ready\n                        .then(() => {\n                        return browser_.driver.getCurrentUrl();\n                    })\n                        .then((url) => {\n                        return newBrowser.get(url);\n                    })\n                        .then(() => {\n                        return newBrowser;\n                    });\n                }\n                return newBrowser;\n            };\n        let replaceBrowser = () => {\n            let newBrowser = browser_.forkNewDriverInstance(false, true);\n            if (browser_ === ptor_1.protractor.browser) {\n                this.setupGlobals_(newBrowser);\n            }\n            return newBrowser;\n        };\n        browser_.restart = () => {\n            // Note: because tests are not paused at this point, any async\n            // calls here are not guaranteed to complete before the tests resume.\n            // Seperate solutions depending on if the control flow is enabled (see lib/browser.ts)\n            if (browser_.controlFlowIsEnabled()) {\n                return browser_.restartSync().ready;\n            }\n            else {\n                return this.driverprovider_.quitDriver(browser_.driver)\n                    .then(replaceBrowser)\n                    .then(newBrowser => newBrowser.ready);\n            }\n        };\n        browser_.restartSync = () => {\n            if (!browser_.controlFlowIsEnabled()) {\n                throw TypeError('Unable to use `browser.restartSync()` when the control flow is disabled');\n            }\n            this.driverprovider_.quitDriver(browser_.driver);\n            return replaceBrowser();\n        };\n        return browser_;\n    }\n    /**\n     * Final cleanup on exiting the runner.\n     *\n     * @return {q.Promise} A promise which resolves on finish.\n     * @private\n     */\n    shutdown_() {\n        return driverProviders_1.DriverProvider.quitDrivers(this.driverprovider_, this.driverprovider_.getExistingDrivers());\n    }\n    /**\n     * The primary workhorse interface. Kicks off the test running process.\n     *\n     * @return {q.Promise} A promise which resolves to the exit code of the tests.\n     * @public\n     */\n    run() {\n        let testPassed;\n        let plugins = this.plugins_ = new plugins_1.Plugins(this.config_);\n        let pluginPostTestPromises;\n        let browser_;\n        let results;\n        if (this.config_.framework !== 'explorer' && !this.config_.specs.length) {\n            throw new Error('Spec patterns did not match any files.');\n        }\n        if (this.config_.SELENIUM_PROMISE_MANAGER != null) {\n            selenium_webdriver_1.promise.USE_PROMISE_MANAGER = this.config_.SELENIUM_PROMISE_MANAGER;\n        }\n        if (this.config_.webDriverLogDir || this.config_.highlightDelay) {\n            this.config_.useBlockingProxy = true;\n        }\n        // 0) Wait for debugger\n        return q(this.ready_)\n            .then(() => {\n            // 1) Setup environment\n            // noinspection JSValidateTypes\n            return this.driverprovider_.setupEnv();\n        })\n            .then(() => {\n            // 2) Create a browser and setup globals\n            browser_ = this.createBrowser(plugins);\n            this.setupGlobals_(browser_);\n            return browser_.ready.then(browser_.getSession)\n                .then((session) => {\n                logger.debug('WebDriver session successfully started with capabilities ' +\n                    util.inspect(session.getCapabilities()));\n            }, (err) => {\n                logger.error('Unable to start a WebDriver session.');\n                throw err;\n            });\n            // 3) Setup plugins\n        })\n            .then(() => {\n            return plugins.setup();\n            // 4) Execute test cases\n        })\n            .then(() => {\n            // Do the framework setup here so that jasmine and mocha globals are\n            // available to the onPrepare function.\n            let frameworkPath = '';\n            if (this.config_.framework === 'jasmine' || this.config_.framework === 'jasmine2') {\n                frameworkPath = './frameworks/jasmine.js';\n            }\n            else if (this.config_.framework === 'mocha') {\n                frameworkPath = './frameworks/mocha.js';\n            }\n            else if (this.config_.framework === 'debugprint') {\n                // Private framework. Do not use.\n                frameworkPath = './frameworks/debugprint.js';\n            }\n            else if (this.config_.framework === 'explorer') {\n                // Private framework. Do not use.\n                frameworkPath = './frameworks/explorer.js';\n            }\n            else if (this.config_.framework === 'custom') {\n                if (!this.config_.frameworkPath) {\n                    throw new Error('When config.framework is custom, ' +\n                        'config.frameworkPath is required.');\n                }\n                frameworkPath = this.config_.frameworkPath;\n            }\n            else {\n                throw new Error('config.framework (' + this.config_.framework + ') is not a valid framework.');\n            }\n            if (this.config_.restartBrowserBetweenTests) {\n                // TODO(sjelin): replace with warnings once `afterEach` support is required\n                let restartDriver = () => {\n                    if (!this.frameworkUsesAfterEach) {\n                        this.restartPromise = q(browser_.restart());\n                    }\n                };\n                this.on('testPass', restartDriver);\n                this.on('testFail', restartDriver);\n            }\n            // We need to save these promises to make sure they're run, but we\n            // don't\n            // want to delay starting the next test (because we can't, it's just\n            // an event emitter).\n            pluginPostTestPromises = [];\n            this.on('testPass', (testInfo) => {\n                pluginPostTestPromises.push(plugins.postTest(true, testInfo));\n            });\n            this.on('testFail', (testInfo) => {\n                pluginPostTestPromises.push(plugins.postTest(false, testInfo));\n            });\n            logger.debug('Running with spec files ' + this.config_.specs);\n            return require(frameworkPath).run(this, this.config_.specs);\n            // 5) Wait for postTest plugins to finish\n        })\n            .then((testResults) => {\n            results = testResults;\n            return q.all(pluginPostTestPromises);\n            // 6) Teardown plugins\n        })\n            .then(() => {\n            return plugins.teardown();\n            // 7) Teardown\n        })\n            .then(() => {\n            results = helper.joinTestLogs(results, plugins.getResults());\n            this.emit('testsDone', results);\n            testPassed = results.failedCount === 0;\n            if (this.driverprovider_.updateJob) {\n                return this.driverprovider_.updateJob({ 'passed': testPassed }).then(() => {\n                    return this.driverprovider_.teardownEnv();\n                });\n            }\n            else {\n                return this.driverprovider_.teardownEnv();\n            }\n            // 8) Let plugins do final cleanup\n        })\n            .then(() => {\n            return plugins.postResults();\n            // 9) Exit process\n        })\n            .then(() => {\n            let exitCode = testPassed ? 0 : 1;\n            return this.exit_(exitCode);\n        })\n            .fin(() => {\n            return this.shutdown_();\n        });\n    }\n}\nexports.Runner = Runner;\n//# sourceMappingURL=runner.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/driverProviders/index.js":"\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require('./attachSession'));\n__export(require('./browserStack'));\n__export(require('./direct'));\n__export(require('./driverProvider'));\n__export(require('./hosted'));\n__export(require('./local'));\n__export(require('./mock'));\n__export(require('./sauce'));\nconst attachSession_2 = require('./attachSession');\nconst browserStack_2 = require('./browserStack');\nconst direct_2 = require('./direct');\nconst hosted_2 = require('./hosted');\nconst local_2 = require('./local');\nconst mock_2 = require('./mock');\nconst sauce_2 = require('./sauce');\nconst logger_1 = require('../logger');\nlet logger = new logger_1.Logger('driverProviders');\nexports.buildDriverProvider = (config) => {\n    let driverProvider;\n    if (config.directConnect) {\n        driverProvider = new direct_2.Direct(config);\n        exports.logWarnings('directConnect', config);\n    }\n    else if (config.seleniumAddress) {\n        if (config.seleniumSessionId) {\n            driverProvider = new attachSession_2.AttachSession(config);\n            exports.logWarnings('attachSession', config);\n        }\n        else {\n            driverProvider = new hosted_2.Hosted(config);\n            exports.logWarnings('hosted', config);\n        }\n    }\n    else if (config.browserstackUser && config.browserstackKey) {\n        driverProvider = new browserStack_2.BrowserStack(config);\n        exports.logWarnings('browserStack', config);\n    }\n    else if (config.sauceUser && config.sauceKey) {\n        driverProvider = new sauce_2.Sauce(config);\n        exports.logWarnings('sauce', config);\n    }\n    else if (config.seleniumServerJar) {\n        driverProvider = new local_2.Local(config);\n        exports.logWarnings('local', config);\n    }\n    else if (config.mockSelenium) {\n        driverProvider = new mock_2.Mock(config);\n        exports.logWarnings('mock', config);\n    }\n    else {\n        driverProvider = new local_2.Local(config);\n        exports.logWarnings('local', config);\n    }\n    return driverProvider;\n};\nexports.logWarnings = (providerType, config) => {\n    let warnInto = 'Using driver provider ' + providerType +\n        ', but also found extra driver provider parameter(s): ';\n    let warnList = [];\n    if ('directConnect' !== providerType && config.directConnect) {\n        warnList.push('directConnect');\n    }\n    if ('attachSession' !== providerType && 'hosted' !== providerType && config.seleniumAddress) {\n        warnList.push('seleniumAddress');\n    }\n    if ('attachSession' !== providerType && config.seleniumSessionId) {\n        warnList.push('seleniumSessionId');\n    }\n    if ('browserStack' !== providerType && config.browserstackUser) {\n        warnList.push('browserstackUser');\n    }\n    if ('browserStack' !== providerType && config.browserstackKey) {\n        warnList.push('browserstackKey');\n    }\n    if ('sauce' !== providerType && config.sauceUser) {\n        warnList.push('sauceUser');\n    }\n    if ('sauce' !== providerType && config.sauceKey) {\n        warnList.push('sauceKey');\n    }\n    if ('local' !== providerType && config.seleniumServerJar) {\n        warnList.push('seleniumServerJar');\n    }\n    if ('mock' !== providerType && config.mockSelenium) {\n        warnList.push('mockSelenium');\n    }\n    if (warnList.length !== 0) {\n        logger.warn(warnInto + warnList.join(', '));\n    }\n};\n//# sourceMappingURL=index.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/driverProviders/attachSession.js":"\"use strict\";\n/*\n *  This is an implementation of the Attach Session Driver Provider.\n *  It is responsible for setting up the account object, tearing\n *  it down, and setting up the driver correctly.\n */\nconst q = require('q');\nconst selenium_webdriver_1 = require('selenium-webdriver');\nconst logger_1 = require('../logger');\nconst driverProvider_1 = require('./driverProvider');\nconst http = require('selenium-webdriver/http');\nlet logger = new logger_1.Logger('attachSession');\nclass AttachSession extends driverProvider_1.DriverProvider {\n    constructor(config) {\n        super(config);\n    }\n    /**\n     * Configure and launch (if applicable) the object's environment.\n     * @return {q.promise} A promise which will resolve when the environment is\n     *     ready to test.\n     */\n    setupDriverEnv() {\n        logger.info('Using the selenium server at ' + this.config_.seleniumAddress);\n        logger.info('Using session id - ' + this.config_.seleniumSessionId);\n        return q(undefined);\n    }\n    /**\n     * Getting a new driver by attaching an existing session.\n     *\n     * @public\n     * @return {WebDriver} webdriver instance\n     */\n    getNewDriver() {\n        const httpClient = new http.HttpClient(this.config_.seleniumAddress);\n        const executor = new http.Executor(httpClient);\n        const newDriver = selenium_webdriver_1.WebDriver.attachToSession(executor, this.config_.seleniumSessionId);\n        this.drivers_.push(newDriver);\n        return newDriver;\n    }\n    /**\n     * Maintains the existing session and does not quit the driver.\n     *\n     * @public\n     */\n    quitDriver() {\n        return selenium_webdriver_1.promise.when(undefined);\n    }\n}\nexports.AttachSession = AttachSession;\n//# sourceMappingURL=attachSession.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/driverProviders/driverProvider.js":"\"use strict\";\n/**\n *  This is a base driver provider class.\n *  It is responsible for setting up the account object, tearing\n *  it down, and setting up the driver correctly.\n */\nconst q = require('q');\nconst selenium_webdriver_1 = require('selenium-webdriver');\nconst bpRunner_1 = require('../bpRunner');\nclass DriverProvider {\n    constructor(config) {\n        this.config_ = config;\n        this.drivers_ = [];\n        this.bpRunner = new bpRunner_1.BlockingProxyRunner(config);\n    }\n    /**\n     * Get all existing drivers.\n     *\n     * @public\n     * @return array of webdriver instances\n     */\n    getExistingDrivers() {\n        return this.drivers_.slice(); // Create a shallow copy\n    }\n    getBPUrl() {\n        if (this.config_.blockingProxyUrl) {\n            return this.config_.blockingProxyUrl;\n        }\n        return `http://localhost:${this.bpRunner.port}`;\n    }\n    /**\n     * Create a new driver.\n     *\n     * @public\n     * @return webdriver instance\n     */\n    getNewDriver() {\n        let builder;\n        if (this.config_.useBlockingProxy) {\n            builder =\n                new selenium_webdriver_1.Builder().usingServer(this.getBPUrl()).withCapabilities(this.config_.capabilities);\n        }\n        else {\n            builder = new selenium_webdriver_1.Builder()\n                .usingServer(this.config_.seleniumAddress)\n                .usingWebDriverProxy(this.config_.webDriverProxy)\n                .withCapabilities(this.config_.capabilities);\n        }\n        if (this.config_.disableEnvironmentOverrides === true) {\n            builder.disableEnvironmentOverrides();\n        }\n        let newDriver = builder.build();\n        this.drivers_.push(newDriver);\n        return newDriver;\n    }\n    /**\n     * Quit a driver.\n     *\n     * @public\n     * @param webdriver instance\n     */\n    quitDriver(driver) {\n        let driverIndex = this.drivers_.indexOf(driver);\n        if (driverIndex >= 0) {\n            this.drivers_.splice(driverIndex, 1);\n        }\n        if (driver.getSession() === undefined) {\n            return selenium_webdriver_1.promise.when(undefined);\n        }\n        else {\n            return driver.getSession()\n                .then((session_) => {\n                if (session_) {\n                    return driver.quit();\n                }\n            })\n                .catch(function (err) { });\n        }\n    }\n    /**\n     * Quits an array of drivers and returns a q promise instead of a webdriver one\n     *\n     * @param drivers {webdriver.WebDriver[]} The webdriver instances\n     */\n    static quitDrivers(provider, drivers) {\n        let deferred = q.defer();\n        selenium_webdriver_1.promise\n            .all(drivers.map((driver) => {\n            return provider.quitDriver(driver);\n        }))\n            .then(() => {\n            deferred.resolve();\n        }, () => {\n            deferred.resolve();\n        });\n        return deferred.promise;\n    }\n    /**\n     * Default update job method.\n     * @return a promise\n     */\n    updateJob(update) {\n        return q.fcall(function () { });\n    }\n    ;\n    /**\n     * Default setup environment method, common to all driver providers.\n     */\n    setupEnv() {\n        let driverPromise = this.setupDriverEnv();\n        if (this.config_.useBlockingProxy && !this.config_.blockingProxyUrl) {\n            // TODO(heathkit): If set, pass the webDriverProxy to BP.\n            return q.all([driverPromise, this.bpRunner.start()]);\n        }\n        return driverPromise;\n    }\n    ;\n    /**\n     * Teardown and destroy the environment and do any associated cleanup.\n     * Shuts down the drivers.\n     *\n     * @public\n     * @return {q.Promise<any>} A promise which will resolve when the environment is down.\n     */\n    teardownEnv() {\n        return DriverProvider.quitDrivers(this, this.drivers_);\n    }\n}\nexports.DriverProvider = DriverProvider;\n//# sourceMappingURL=driverProvider.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/driverProviders/browserStack.js":"\"use strict\";\n/*\n * This is an implementation of the Browserstack Driver Provider.\n * It is responsible for setting up the account object, tearing\n * it down, and setting up the driver correctly.\n */\nconst https = require('https');\nconst q = require('q');\nconst util = require('util');\nconst exitCodes_1 = require('../exitCodes');\nconst logger_1 = require('../logger');\nconst driverProvider_1 = require('./driverProvider');\nlet logger = new logger_1.Logger('browserstack');\nclass BrowserStack extends driverProvider_1.DriverProvider {\n    constructor(config) {\n        super(config);\n    }\n    /**\n     * Hook to update the BrowserStack job status.\n     * @public\n     * @param {Object} update\n     * @return {q.promise} A promise that will resolve when the update is complete.\n     */\n    updateJob(update) {\n        let deferredArray = this.drivers_.map((driver) => {\n            let deferred = q.defer();\n            driver.getSession().then((session) => {\n                let headers = {\n                    'Content-Type': 'application/json',\n                    'Authorization': 'Basic ' +\n                        new Buffer(this.config_.browserstackUser + ':' + this.config_.browserstackKey)\n                            .toString('base64')\n                };\n                let options = {\n                    hostname: 'www.browserstack.com',\n                    port: 443,\n                    path: '/automate/sessions/' + session.getId() + '.json',\n                    method: 'GET',\n                    headers: headers\n                };\n                let req = https.request(options, (res) => {\n                    res.on('data', (data) => {\n                        let info = JSON.parse(data.toString());\n                        if (info && info.automation_session && info.automation_session.browser_url) {\n                            logger.info('BrowserStack results available at ' + info.automation_session.browser_url);\n                        }\n                        else {\n                            logger.info('BrowserStack results available at ' +\n                                'https://www.browserstack.com/automate');\n                        }\n                    });\n                });\n                req.end();\n                req.on('error', (e) => {\n                    logger.info('BrowserStack results available at ' +\n                        'https://www.browserstack.com/automate');\n                });\n                let jobStatus = update.passed ? 'completed' : 'error';\n                options.method = 'PUT';\n                let update_req = https.request(options, (res) => {\n                    let responseStr = '';\n                    res.on('data', (data) => {\n                        responseStr += data.toString();\n                    });\n                    res.on('end', () => {\n                        logger.info(responseStr);\n                        deferred.resolve();\n                    });\n                    res.on('error', (e) => {\n                        throw new exitCodes_1.BrowserError(logger, 'Error updating BrowserStack pass/fail status: ' + util.inspect(e));\n                    });\n                });\n                update_req.write('{\"status\":\"' + jobStatus + '\"}');\n                update_req.end();\n            });\n            return deferred.promise;\n        });\n        return q.all(deferredArray);\n    }\n    /**\n     * Configure and launch (if applicable) the object's environment.\n     * @return {q.promise} A promise which will resolve when the environment is\n     *     ready to test.\n     */\n    setupDriverEnv() {\n        let deferred = q.defer();\n        this.config_.capabilities['browserstack.user'] = this.config_.browserstackUser;\n        this.config_.capabilities['browserstack.key'] = this.config_.browserstackKey;\n        this.config_.seleniumAddress = 'http://hub.browserstack.com/wd/hub';\n        // Append filename to capabilities.name so that it's easier to identify\n        // tests.\n        if (this.config_.capabilities.name && this.config_.capabilities.shardTestFiles) {\n            this.config_.capabilities.name +=\n                (':' + this.config_.specs.toString().replace(/^.*[\\\\\\/]/, ''));\n        }\n        logger.info('Using BrowserStack selenium server at ' + this.config_.seleniumAddress);\n        deferred.resolve();\n        return deferred.promise;\n    }\n}\nexports.BrowserStack = BrowserStack;\n//# sourceMappingURL=browserStack.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/driverProviders/direct.js":"\"use strict\";\n/*\n *  This is an implementation of the Direct Driver Provider.\n *  It is responsible for setting up the account object, tearing\n *  it down, and setting up the driver correctly.\n */\nconst fs = require('fs');\nconst path = require('path');\nconst q = require('q');\nconst selenium_webdriver_1 = require('selenium-webdriver');\nconst chrome_1 = require('selenium-webdriver/chrome');\nconst exitCodes_1 = require('../exitCodes');\nconst logger_1 = require('../logger');\nconst driverProvider_1 = require('./driverProvider');\nconst SeleniumConfig = require('webdriver-manager/built/lib/config').Config;\nlet logger = new logger_1.Logger('direct');\nclass Direct extends driverProvider_1.DriverProvider {\n    constructor(config) {\n        super(config);\n    }\n    /**\n     * Configure and launch (if applicable) the object's environment.\n     * @return {q.promise} A promise which will resolve when the environment is\n     *     ready to test.\n     */\n    setupDriverEnv() {\n        switch (this.config_.capabilities.browserName) {\n            case 'chrome':\n                logger.info('Using ChromeDriver directly...');\n                break;\n            case 'firefox':\n                logger.info('Using FirefoxDriver directly...');\n                break;\n            default:\n                throw new exitCodes_1.BrowserError(logger, 'browserName ' + this.config_.capabilities.browserName +\n                    ' is not supported with directConnect.');\n        }\n        return q.fcall(function () { });\n    }\n    /**\n     * Create a new driver.\n     *\n     * @public\n     * @override\n     * @return webdriver instance\n     */\n    getNewDriver() {\n        let driver;\n        switch (this.config_.capabilities.browserName) {\n            case 'chrome':\n                let chromeDriverFile;\n                if (this.config_.chromeDriver) {\n                    chromeDriverFile = this.config_.chromeDriver;\n                }\n                else {\n                    try {\n                        let updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n                        let updateConfig = JSON.parse(fs.readFileSync(updateJson).toString());\n                        chromeDriverFile = updateConfig.chrome.last;\n                    }\n                    catch (e) {\n                        throw new exitCodes_1.BrowserError(logger, 'Could not find update-config.json. ' +\n                            'Run \\'webdriver-manager update\\' to download binaries.');\n                    }\n                }\n                if (!fs.existsSync(chromeDriverFile)) {\n                    throw new exitCodes_1.BrowserError(logger, 'Could not find chromedriver at ' + chromeDriverFile +\n                        '. Run \\'webdriver-manager update\\' to download binaries.');\n                }\n                let chromeService = new chrome_1.ServiceBuilder(chromeDriverFile).build();\n                // driver = ChromeDriver.createSession(new Capabilities(this.config_.capabilities),\n                // chromeService);\n                // TODO(ralphj): fix typings\n                driver =\n                    require('selenium-webdriver/chrome')\n                        .Driver.createSession(new selenium_webdriver_1.Capabilities(this.config_.capabilities), chromeService);\n                break;\n            case 'firefox':\n                let geckoDriverFile;\n                try {\n                    let updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n                    let updateConfig = JSON.parse(fs.readFileSync(updateJson).toString());\n                    geckoDriverFile = updateConfig.gecko.last;\n                }\n                catch (e) {\n                    throw new exitCodes_1.BrowserError(logger, 'Could not find update-config.json. ' +\n                        'Run \\'webdriver-manager update\\' to download binaries.');\n                }\n                // TODO (mgiambalvo): Turn this into an import when the selenium typings are updated.\n                const FirefoxServiceBuilder = require('selenium-webdriver/firefox').ServiceBuilder;\n                let firefoxService = new FirefoxServiceBuilder(geckoDriverFile).build();\n                // TODO(mgiambalvo): Fix typings.\n                driver =\n                    require('selenium-webdriver/firefox')\n                        .Driver.createSession(new selenium_webdriver_1.Capabilities(this.config_.capabilities), firefoxService);\n                break;\n            default:\n                throw new exitCodes_1.BrowserError(logger, 'browserName ' + this.config_.capabilities.browserName +\n                    ' is not supported with directConnect.');\n        }\n        this.drivers_.push(driver);\n        return driver;\n    }\n}\nexports.Direct = Direct;\n//# sourceMappingURL=direct.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/node_modules/webdriver-manager/built/lib/config.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst cli_1 = require(\"./cli\");\nlet logger = new cli_1.Logger('config');\n/**\n * The configuration for webdriver-manager\n *\n * The config.json, package.json, and selenium directory are found in the\n * same location at the root directory in webdriver-manager.\n *\n */\nclass Config {\n    static osArch() {\n        return Config.osArch_;\n    }\n    static osType() {\n        return Config.osType_;\n    }\n    static noProxy() {\n        return Config.noProxy_;\n    }\n    static httpProxy() {\n        return Config.httpProxy_;\n    }\n    static httpsProxy() {\n        return Config.httpsProxy_;\n    }\n    static getConfigFile_() {\n        return path.resolve(Config.dir, '..', Config.configFile);\n    }\n    static getPackageFile_() {\n        return path.resolve(Config.dir, '..', Config.packageFile);\n    }\n    static getSeleniumDir() {\n        return path.resolve(Config.dir, '..', '..', 'selenium/');\n    }\n    static getBaseDir() {\n        return path.resolve(Config.dir, '..', '..');\n    }\n    /**\n     * Get the binary versions from the configuration file.\n     * @returns A map of the versions defined in the configuration file.\n     */\n    static binaryVersions() {\n        let configFile = require(Config.getConfigFile_());\n        let configVersions = {};\n        configVersions.selenium = configFile.webdriverVersions.selenium;\n        configVersions.chrome = configFile.webdriverVersions.chromedriver;\n        configVersions.gecko = configFile.webdriverVersions.geckodriver;\n        configVersions.ie = configFile.webdriverVersions.iedriver;\n        configVersions.android = configFile.webdriverVersions.androidsdk;\n        configVersions.appium = configFile.webdriverVersions.appium;\n        return configVersions;\n    }\n    /**\n     * Get the CDN urls from the configuration file.\n     * @returns A map of the CDN versions defined in the configuration file.\n     */\n    static cdnUrls() {\n        let configFile = require(Config.getConfigFile_());\n        let configCdnUrls = {};\n        configCdnUrls.selenium = configFile.cdnUrls.selenium;\n        configCdnUrls.chrome = configFile.cdnUrls.chromedriver;\n        configCdnUrls.gecko = configFile.cdnUrls.geckodriver;\n        configCdnUrls.ie = configFile.cdnUrls.iedriver;\n        configCdnUrls.android = configFile.cdnUrls.androidsdk;\n        return configCdnUrls;\n    }\n    /**\n     * Get the package version.\n     */\n    static getVersion() {\n        let packageFile = require(Config.getPackageFile_());\n        return packageFile.version;\n    }\n}\nConfig.configFile = 'config.json';\nConfig.packageFile = 'package.json';\nConfig.nodeModuleName = 'webdriver-manager';\nConfig.cwd = process.cwd();\nConfig.parentPath = path.resolve(Config.cwd, '..');\nConfig.dir = __dirname;\nConfig.folder = Config.cwd.replace(Config.parentPath, '').substring(1);\nConfig.isProjectVersion = Config.folder === Config.nodeModuleName;\nConfig.isLocalVersion = false;\nConfig.osArch_ = os.arch();\nConfig.osType_ = os.type();\nConfig.noProxy_ = process.env.NO_PROXY || process.env.no_proxy;\nConfig.httpsProxy_ = process.env.HTTPS_PROXY || process.env.https_proxy;\nConfig.httpProxy_ = process.env.HTTP_PROXY || process.env.http_proxy;\nexports.Config = Config;\n//# sourceMappingURL=config.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/node_modules/webdriver-manager/built/lib/cli/index.js":"\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./cli\"));\n__export(require(\"./options\"));\n__export(require(\"./programs\"));\n__export(require(\"./logger\"));\n//# sourceMappingURL=index.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/node_modules/webdriver-manager/built/lib/cli/cli.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The Cli contains the usage and the collection of programs.\n *\n * Printing help for all the programs in the following order:\n * usage, commands, and options. If the options are used in multiple programs,\n * it will list it once.\n */\nclass Cli {\n    constructor() {\n        this.programs = {};\n    }\n    /**\n     * Register a program to the command line interface.\n     * @returns The cli for method chaining.\n     */\n    program(prog) {\n        this.programs[prog.cmd] = prog;\n        return this;\n    }\n    /**\n     * Add a usage for the command line interface.\n     * @returns The cli for method chaining.\n     */\n    usage(usageText) {\n        this.usageText = usageText;\n        return this;\n    }\n    /**\n     * Prints help for the programs registered to the cli.\n     */\n    printHelp() {\n        console.log('Usage: ' + this.usageText);\n        console.log('\\nCommands:');\n        let cmdDescriptionPos = this.posCmdDescription();\n        for (let cmd in this.programs) {\n            let prog = this.programs[cmd];\n            prog.printCmd(cmdDescriptionPos);\n        }\n        let descriptionPos = this.posDescription();\n        let defaultPos = this.posDefault();\n        let extOptions = {};\n        console.log('\\nOptions:');\n        // print all options\n        for (let cmd in this.programs) {\n            let prog = this.programs[cmd];\n            prog.printOptions(descriptionPos, defaultPos, extOptions);\n        }\n    }\n    /**\n     * For commands, gets the position where the description should start so they\n     * are aligned.\n     * @returns The position where the command description should start.\n     */\n    posCmdDescription() {\n        let position = -1;\n        for (let cmd in this.programs) {\n            position = Math.max(position, cmd.length + 6);\n        }\n        return position;\n    }\n    /**\n     * For options, gets the position where the description should start so they\n     * are aligned.\n     * @returns The position where the option description should start.\n     */\n    posDescription() {\n        let position = -1;\n        for (let cmd in this.programs) {\n            let prog = this.programs[cmd];\n            position = Math.max(position, prog.posDescription());\n        }\n        return position;\n    }\n    /**\n     * For options, get the position where the default values should start so they\n     * are aligned.\n     * @returns The position where the option default values should start.\n     */\n    posDefault() {\n        let position = -1;\n        for (let cmd in this.programs) {\n            let prog = this.programs[cmd];\n            position = Math.max(position, prog.posDefault());\n        }\n        return position;\n    }\n    /**\n     * Go through all programs and add options to the collection.\n     * @returns The options used in the programs.\n     */\n    getOptions() {\n        let allOptions = {};\n        for (let cmd in this.programs) {\n            let prog = this.programs[cmd];\n            allOptions = prog.getOptions_(allOptions);\n        }\n        return allOptions;\n    }\n    /**\n     * Get the options used by the programs and create the minimist options\n     * to ensure that minimist parses the values properly.\n     * @returns The options for minimist.\n     */\n    getMinimistOptions() {\n        let allOptions = this.getOptions();\n        let minimistOptions = {};\n        let minimistBoolean = [];\n        let minimistString = [];\n        let minimistNumber = [];\n        let minimistDefault = {};\n        for (let opt in allOptions) {\n            let option = allOptions[opt];\n            if (option.type === 'boolean') {\n                minimistBoolean.push(option.opt);\n            }\n            else if (option.type === 'string') {\n                minimistString.push(option.opt);\n            }\n            else if (option.type === 'number') {\n                minimistNumber.push(option.opt);\n            }\n            if (typeof option.defaultValue !== 'undefined') {\n                minimistDefault[option.opt] = option.defaultValue;\n            }\n        }\n        minimistOptions['boolean'] = minimistBoolean;\n        minimistOptions['string'] = minimistString;\n        minimistOptions['number'] = minimistNumber;\n        minimistOptions['default'] = minimistDefault;\n        return minimistOptions;\n    }\n}\nexports.Cli = Cli;\n//# sourceMappingURL=cli.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/node_modules/webdriver-manager/built/lib/cli/options.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Option {\n    constructor(opt, description, type, defaultValue) {\n        this.opt = opt;\n        this.description = description;\n        this.type = type;\n        if (defaultValue != null) {\n            this.defaultValue = defaultValue;\n        }\n    }\n    getValue_() {\n        if (typeof this.value !== 'undefined') {\n            return this.value;\n        }\n        else {\n            return this.defaultValue;\n        }\n    }\n    getNumber() {\n        let value = this.getValue_();\n        if (value != null && (typeof value === 'number' || typeof value === 'string')) {\n            return +value;\n        }\n        else {\n            return null;\n        }\n    }\n    getString() {\n        let value = this.getValue_();\n        if (value != null) {\n            return '' + this.getValue_();\n        }\n        else {\n            return '';\n        }\n    }\n    getBoolean() {\n        let value = this.getValue_();\n        if (value != null) {\n            if (typeof value === 'string') {\n                return !(value === '0' || value === 'false');\n            }\n            else if (typeof value === 'number') {\n                return value !== 0;\n            }\n            else {\n                return value;\n            }\n        }\n        return false;\n    }\n}\nexports.Option = Option;\nfunction unparseOptions(options) {\n    var args = [];\n    for (let name in options) {\n        let value = options[name].getValue_();\n        if (value !== options[name].defaultValue) {\n            args.push('--' + name, '' + value);\n        }\n    }\n    return args;\n}\nexports.unparseOptions = unparseOptions;\n;\n//# sourceMappingURL=options.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/node_modules/webdriver-manager/built/lib/cli/programs.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst options_1 = require(\"./options\");\n/**\n * A program has a command, a description, options, and a run method\n */\nclass Program {\n    constructor() {\n        this.options = {};\n    }\n    /**\n     * Register a command and the description.\n     * @param cmd The command.\n     * @param cmdDescription The description of the command.\n     * @returns The program for method chaining.\n     */\n    command(cmd, cmdDescription) {\n        this.cmd = cmd;\n        this.cmdDescription = cmdDescription;\n        return this;\n    }\n    /**\n     * Register a new option.\n     * @param opt The option.\n     * @param description The description of the option.\n     * @param type The type of value expected: boolean, number, or string\n     * @param defaultValue The option's default value.\n     * @returns The program for method chaining.\n     */\n    option(opt, description, type, opt_defaultValue) {\n        this.options[opt] = new options_1.Option(opt, description, type, opt_defaultValue);\n        return this;\n    }\n    /**\n     * Adds an option to the program.\n     * @param option The option.\n     * @returns The program for method chaining.\n     */\n    addOption(option) {\n        this.options[option.opt] = option;\n        return this;\n    }\n    /**\n     * Registers a method that will be used to run the program.\n     * @param runMethod The method that will be used to run the program.\n     * @returns The program for method chaining.\n     */\n    action(runMethod) {\n        this.runMethod = runMethod;\n        return this;\n    }\n    /**\n     * Adds the value to the options and passes the updated options to the run\n     * method.\n     * @param args The arguments that will be parsed to run the method.\n     */\n    run(json) {\n        for (let opt in this.options) {\n            this.options[opt].value = this.getValue_(opt, json);\n        }\n        return Promise.resolve(this.runMethod(this.options));\n    }\n    getValue_(key, json) {\n        let keyList = key.split('.');\n        let tempJson = json;\n        while (keyList.length > 0) {\n            let keyItem = keyList[0];\n            if (tempJson[keyItem] != null) {\n                tempJson = tempJson[keyItem];\n                keyList = keyList.slice(1);\n            }\n            else {\n                return undefined;\n            }\n        }\n        return tempJson;\n    }\n    /**\n     * Prints the command with the description. The description will have spaces\n     * between the cmd so that the starting position is \"posDescription\". If the\n     * gap between the cmd and the description is less than MIN_SPACING or\n     * posDescription is undefined, the spacing will be MIN_SPACING.\n     *\n     * @param opt_postDescription Starting position of the description.\n     */\n    printCmd(opt_posDescription) {\n        let log = '  ' + this.cmd;\n        let spacing = Program.MIN_SPACING;\n        if (opt_posDescription) {\n            let diff = opt_posDescription - log.length;\n            if (diff < Program.MIN_SPACING) {\n                spacing = Program.MIN_SPACING;\n            }\n            else {\n                spacing = diff;\n            }\n        }\n        log += Array(spacing).join(' ') + this.cmdDescription;\n        console.log(log);\n    }\n    /**\n     * Prints the options with the option descriptions and default values.\n     * The posDescription and posDefault is the starting position for the option\n     * description. If extOptions are provided, check to see if we have already\n     * printed those options. Also, once we print the option, add them to the extOptions.\n     *\n     * @param posDescription Position to start logging the description.\n     * @param posDefault Position to start logging the default value.\n     * @param opt_extOptions A collection of options that will be updated.\n     */\n    printOptions(posDescription, posDefault, opt_extOptions) {\n        for (let opt in this.options) {\n            // we have already logged it\n            if (opt_extOptions && opt_extOptions[opt]) {\n                continue;\n            }\n            let option = this.options[opt];\n            let log = '  --' + option.opt;\n            let spacing = Program.MIN_SPACING;\n            // description\n            let diff = posDescription - log.length;\n            if (diff < Program.MIN_SPACING) {\n                spacing = Program.MIN_SPACING;\n            }\n            else {\n                spacing = diff;\n            }\n            log += Array(spacing).join(' ') + option.description;\n            // default value\n            if (option.defaultValue) {\n                spacing = Program.MIN_SPACING;\n                let diff = posDefault - log.length - 1;\n                if (diff <= Program.MIN_SPACING) {\n                    spacing = Program.MIN_SPACING;\n                }\n                else {\n                    spacing = diff;\n                }\n                log += Array(spacing).join(' ');\n                log += '[default: ' + option.defaultValue + ']';\n            }\n            console.log(log);\n            if (opt_extOptions) {\n                opt_extOptions[option.opt] = option;\n            }\n        }\n    }\n    /**\n     * Assuming that the this program can run by itself, to print out the program's\n     * help. Also assuming that the commands are called cmd-run and cmd-help.\n     */\n    printHelp() {\n        console.log('\\n' +\n            'Usage:        ' + this.cmd + ' [options]\\n' +\n            '              ' + this.cmd + ' help\\n' +\n            'Description:  ' + this.cmdDescription + '\\n');\n        console.log('Options:');\n        this.printOptions(this.posDescription(), this.posDefault());\n    }\n    posDescription() {\n        return this.lengthOf_('opt') + 2 * Program.MIN_SPACING;\n    }\n    posDefault() {\n        return this.posDescription() + this.lengthOf_('description') + Program.MIN_SPACING;\n    }\n    lengthOf_(param) {\n        let maxLength = -1;\n        for (let opt in this.options) {\n            let option = this.options[opt];\n            if (param === 'description') {\n                maxLength = Math.max(maxLength, option.description.length);\n            }\n            else if (param === 'opt') {\n                maxLength = Math.max(maxLength, option.opt.length);\n            }\n        }\n        return maxLength;\n    }\n    /**\n     * Create a collection of options used by this program.\n     * @returns The options used in the programs.\n     */\n    getOptions_(allOptions) {\n        for (let opt in this.options) {\n            allOptions[opt] = this.options[opt];\n        }\n        return allOptions;\n    }\n    /**\n     * Get the options used by the program and create the minimist options\n     * to ensure that minimist parses the values properly.\n     * @returns The options for minimist.\n     */\n    getMinimistOptions() {\n        let allOptions = {};\n        allOptions = this.getOptions_(allOptions);\n        let minimistOptions = {};\n        let minimistBoolean = [];\n        let minimistString = [];\n        let minimistNumber = [];\n        let minimistDefault = {};\n        for (let opt in allOptions) {\n            let option = allOptions[opt];\n            if (option.type === 'boolean') {\n                minimistBoolean.push(option.opt);\n            }\n            else if (option.type === 'string') {\n                minimistString.push(option.opt);\n            }\n            else if (option.type === 'number') {\n                minimistNumber.push(option.opt);\n            }\n            if (typeof option.defaultValue !== 'undefined') {\n                minimistDefault[option.opt] = option.defaultValue;\n            }\n        }\n        minimistOptions['boolean'] = minimistBoolean;\n        minimistOptions['string'] = minimistString;\n        minimistOptions['number'] = minimistNumber;\n        minimistOptions['default'] = minimistDefault;\n        return minimistOptions;\n    }\n}\nProgram.MIN_SPACING = 4;\nexports.Program = Program;\n//# sourceMappingURL=programs.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/node_modules/webdriver-manager/built/lib/cli/logger.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n// Will use chalk if chalk is available to add color to console logging\nlet chalk;\nlet printRed;\nlet printYellow;\nlet printGray;\ntry {\n    chalk = require('chalk');\n    printRed = chalk.red;\n    printYellow = chalk.yellow;\n    printGray = chalk.gray;\n}\ncatch (e) {\n    printRed = printYellow = printGray = (msg) => {\n        return msg;\n    };\n}\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n    LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"DEBUG\"] = 3] = \"DEBUG\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\nvar WriteTo;\n(function (WriteTo) {\n    WriteTo[WriteTo[\"CONSOLE\"] = 0] = \"CONSOLE\";\n    WriteTo[WriteTo[\"FILE\"] = 1] = \"FILE\";\n    WriteTo[WriteTo[\"BOTH\"] = 2] = \"BOTH\";\n    WriteTo[WriteTo[\"NONE\"] = 3] = \"NONE\";\n})(WriteTo = exports.WriteTo || (exports.WriteTo = {}));\nlet logFile = 'webdriver.log'; // the default log file name\n/**\n * Logger class adds timestamp output, log levels, and identifiers to help\n * when debugging. Also could write to console, file, both, or none.\n */\nclass Logger {\n    /**\n     * Creates a logger instance with an ID for the logger.\n     * @constructor\n     */\n    constructor(id) {\n        this.id = id;\n    }\n    /**\n     * Set up the write location. If writing to a file, get the file descriptor.\n     * @param writeTo The enum for where to write the logs.\n     * @param opt_logFile An optional parameter to override the log file location.\n     */\n    static setWrite(writeTo, opt_logFile) {\n        if (opt_logFile) {\n            logFile = opt_logFile;\n        }\n        Logger.writeTo = writeTo;\n        if (Logger.writeTo == WriteTo.FILE || Logger.writeTo == WriteTo.BOTH) {\n            Logger.fd = fs.openSync(path.resolve(logFile), 'a');\n            Logger.firstWrite = false;\n        }\n    }\n    /**\n     * Log INFO\n     * @param ...msgs multiple arguments to be logged.\n     */\n    info(...msgs) {\n        this.log_(LogLevel.INFO, msgs);\n    }\n    /**\n     * Log DEBUG\n     * @param ...msgs multiple arguments to be logged.\n     */\n    debug(...msgs) {\n        this.log_(LogLevel.DEBUG, msgs);\n    }\n    /**\n     * Log WARN\n     * @param ...msgs multiple arguments to be logged.\n     */\n    warn(...msgs) {\n        this.log_(LogLevel.WARN, msgs);\n    }\n    /**\n     * Log ERROR\n     * @param ...msgs multiple arguments to be logged.\n     */\n    error(...msgs) {\n        this.log_(LogLevel.ERROR, msgs);\n    }\n    /**\n     * For the log level set, check to see if the messages should be logged.\n     * @param logLevel The log level of the message.\n     * @param msgs The messages to be logged\n     */\n    log_(logLevel, msgs) {\n        switch (Logger.logLevel) {\n            case LogLevel.ERROR:\n                if (logLevel <= LogLevel.ERROR) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.WARN:\n                if (logLevel <= LogLevel.WARN) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.INFO:\n                if (logLevel <= LogLevel.INFO) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.DEBUG:\n                if (logLevel <= LogLevel.DEBUG) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            default:\n                throw new Error('Log level undefined');\n        }\n    }\n    /**\n     * Format with timestamp, log level, identifier, and message and log to\n     * specified medium (console, file, both, none).\n     * @param logLevel The log level of the message.\n     * @param msgs The messages to be logged.\n     */\n    print_(logLevel, msgs) {\n        let consoleLog = '';\n        let fileLog = '';\n        if (Logger.showTimestamp) {\n            consoleLog += Logger.timestamp_(WriteTo.CONSOLE);\n            fileLog += Logger.timestamp_(WriteTo.FILE);\n        }\n        consoleLog += Logger.level_(logLevel, this.id, WriteTo.CONSOLE);\n        fileLog += Logger.level_(logLevel, this.id, WriteTo.FILE);\n        if (Logger.showId) {\n            consoleLog += Logger.id_(logLevel, this.id, WriteTo.CONSOLE);\n            fileLog += Logger.id_(logLevel, this.id, WriteTo.FILE);\n        }\n        consoleLog += ' -';\n        fileLog += ' - ';\n        switch (Logger.writeTo) {\n            case WriteTo.CONSOLE:\n                msgs.unshift(consoleLog);\n                console.log.apply(console, msgs);\n                break;\n            case WriteTo.FILE:\n                // for the first line written to the file, add a space\n                if (!Logger.firstWrite) {\n                    fs.writeSync(Logger.fd, '\\n');\n                    Logger.firstWrite = true;\n                }\n                fileLog += ' ' + Logger.msgToFile_(msgs);\n                fs.writeSync(Logger.fd, fileLog + '\\n');\n                break;\n            case WriteTo.BOTH:\n                // for the first line written to the file, add a space\n                if (!Logger.firstWrite) {\n                    fs.writeSync(Logger.fd, '\\n');\n                    Logger.firstWrite = true;\n                }\n                fileLog += ' ' + Logger.msgToFile_(msgs);\n                fs.writeSync(Logger.fd, fileLog + '\\n');\n                msgs.unshift(consoleLog);\n                console.log.apply(console, msgs);\n                break;\n            case WriteTo.NONE:\n                break;\n        }\n    }\n    /**\n     * Get a timestamp formatted with [hh:mm:ss]\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted timestamp\n     */\n    static timestamp_(writeTo) {\n        let d = new Date();\n        let ts = '[';\n        let hours = d.getHours() < 10 ? '0' + d.getHours() : d.getHours();\n        let minutes = d.getMinutes() < 10 ? '0' + d.getMinutes() : d.getMinutes();\n        let seconds = d.getSeconds() < 10 ? '0' + d.getSeconds() : d.getSeconds();\n        if (writeTo == WriteTo.CONSOLE) {\n            ts += printGray(hours + ':' + minutes + ':' + seconds) + ']';\n        }\n        else {\n            ts += hours + ':' + minutes + ':' + seconds + ']';\n        }\n        ts += ' ';\n        return ts;\n    }\n    /**\n     * Get the identifier of the logger as '/<id>'\n     * @param logLevel The log level of the message.\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted id\n     */\n    static id_(logLevel, id, writeTo) {\n        let level = LogLevel[logLevel].toString();\n        if (writeTo === WriteTo.FILE) {\n            return '/' + id;\n        }\n        else if (logLevel === LogLevel.ERROR) {\n            return printRed('/' + id);\n        }\n        else if (logLevel === LogLevel.WARN) {\n            return printYellow('/' + id);\n        }\n        else {\n            return '/' + id;\n        }\n    }\n    /**\n     * Get the log level formatted with the first letter. For info, it is I.\n     * @param logLevel The log level of the message.\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted log level\n     */\n    static level_(logLevel, id, writeTo) {\n        let level = LogLevel[logLevel].toString();\n        if (writeTo === WriteTo.FILE) {\n            return level[0];\n        }\n        else if (logLevel === LogLevel.ERROR) {\n            return printRed(level[0]);\n        }\n        else if (logLevel === LogLevel.WARN) {\n            return printYellow(level[0]);\n        }\n        else {\n            return level[0];\n        }\n    }\n    /**\n     * Convert the list of messages to a single string message.\n     * @param msgs The list of messages.\n     * @return The string of the formatted messages\n     */\n    static msgToFile_(msgs) {\n        let log = '';\n        for (let pos = 0; pos < msgs.length; pos++) {\n            let msg = msgs[pos];\n            let ret;\n            if (typeof msg === 'object') {\n                ret = JSON.stringify(msg);\n            }\n            else {\n                ret = msg;\n            }\n            if (pos !== msgs.length - 1) {\n                ret += ' ';\n            }\n            log += ret;\n        }\n        return log;\n    }\n}\nLogger.logLevel = LogLevel.INFO;\nLogger.showTimestamp = true;\nLogger.showId = true;\nLogger.writeTo = WriteTo.CONSOLE;\nLogger.firstWrite = false;\nexports.Logger = Logger;\n//# sourceMappingURL=logger.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/driverProviders/hosted.js":"\"use strict\";\n/*\n *  This is an implementation of the Hosted Driver Provider.\n *  It is responsible for setting up the account object, tearing\n *  it down, and setting up the driver correctly.\n */\nconst q = require('q');\nconst logger_1 = require('../logger');\nconst driverProvider_1 = require('./driverProvider');\nlet logger = new logger_1.Logger('hosted');\nclass Hosted extends driverProvider_1.DriverProvider {\n    constructor(config) {\n        super(config);\n    }\n    /**\n     * Configure and launch (if applicable) the object's environment.\n     * @public\n     * @return {q.promise} A promise which will resolve when the environment is\n     *     ready to test.\n     */\n    setupDriverEnv() {\n        logger.info('Using the selenium server at ' + this.config_.seleniumAddress);\n        return q.fcall(function () { });\n    }\n}\nexports.Hosted = Hosted;\n//# sourceMappingURL=hosted.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/driverProviders/local.js":"\"use strict\";\n/*\n * This is an implementation of the Local Driver Provider.\n * It is responsible for setting up the account object, tearing\n * it down, and setting up the driver correctly.\n *\n * TODO - it would be nice to do this in the launcher phase,\n * so that we only start the local selenium once per entire launch.\n */\nconst fs = require('fs');\nconst path = require('path');\nconst q = require('q');\nconst exitCodes_1 = require('../exitCodes');\nconst logger_1 = require('../logger');\nconst driverProvider_1 = require('./driverProvider');\nconst SeleniumConfig = require('webdriver-manager/built/lib/config').Config;\nconst SeleniumChrome = require('webdriver-manager/built/lib/binaries/chrome_driver').ChromeDriver;\nconst SeleniumStandAlone = require('webdriver-manager/built/lib/binaries/standalone').StandAlone;\nconst remote = require('selenium-webdriver/remote');\nlet logger = new logger_1.Logger('local');\nclass Local extends driverProvider_1.DriverProvider {\n    constructor(config) {\n        super(config);\n        this.server_ = null;\n    }\n    /**\n     * Helper to locate the default jar path if none is provided by the user.\n     * @private\n     */\n    addDefaultBinaryLocs_() {\n        if (!this.config_.seleniumServerJar) {\n            logger.debug('Attempting to find the SeleniumServerJar in the default ' +\n                'location used by webdriver-manager');\n            try {\n                let updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n                let updateConfig = JSON.parse(fs.readFileSync(updateJson).toString());\n                this.config_.seleniumServerJar = updateConfig.standalone.last;\n            }\n            catch (err) {\n                throw new exitCodes_1.BrowserError(logger, 'No update-config.json found.' +\n                    ' Run \\'webdriver-manager update\\' to download binaries.');\n            }\n        }\n        if (!fs.existsSync(this.config_.seleniumServerJar)) {\n            throw new exitCodes_1.BrowserError(logger, 'No selenium server jar found at ' + this.config_.seleniumServerJar +\n                '. Run \\'webdriver-manager update\\' to download binaries.');\n        }\n        if (this.config_.capabilities.browserName === 'chrome') {\n            if (!this.config_.chromeDriver) {\n                logger.debug('Attempting to find the chromedriver binary in the default ' +\n                    'location used by webdriver-manager');\n                try {\n                    let updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n                    let updateConfig = JSON.parse(fs.readFileSync(updateJson).toString());\n                    this.config_.chromeDriver = updateConfig.chrome.last;\n                }\n                catch (err) {\n                    throw new exitCodes_1.BrowserError(logger, 'No update-config.json found. ' +\n                        'Run \\'webdriver-manager update\\' to download binaries.');\n                }\n            }\n            // Check if file exists, if not try .exe or fail accordingly\n            if (!fs.existsSync(this.config_.chromeDriver)) {\n                if (fs.existsSync(this.config_.chromeDriver + '.exe')) {\n                    this.config_.chromeDriver += '.exe';\n                }\n                else {\n                    throw new exitCodes_1.BrowserError(logger, 'Could not find chromedriver at ' + this.config_.chromeDriver +\n                        '. Run \\'webdriver-manager update\\' to download binaries.');\n                }\n            }\n        }\n    }\n    /**\n     * Configure and launch (if applicable) the object's environment.\n     * @public\n     * @return {q.promise} A promise which will resolve when the environment is\n     *     ready to test.\n     */\n    setupDriverEnv() {\n        this.addDefaultBinaryLocs_();\n        logger.info('Starting selenium standalone server...');\n        let serverConf = this.config_.localSeleniumStandaloneOpts || {};\n        // If args or port is not set use seleniumArgs and seleniumPort\n        // for backward compatibility\n        if (serverConf.args === undefined) {\n            serverConf.args = this.config_.seleniumArgs || [];\n        }\n        if (serverConf.jvmArgs === undefined) {\n            serverConf.jvmArgs = this.config_.jvmArgs || [];\n        }\n        else {\n            if (!Array.isArray(serverConf.jvmArgs)) {\n                throw new exitCodes_1.ConfigError(logger, 'jvmArgs should be an array.');\n            }\n        }\n        if (serverConf.port === undefined) {\n            serverConf.port = this.config_.seleniumPort;\n        }\n        // configure server\n        if (this.config_.chromeDriver) {\n            serverConf.jvmArgs.push('-Dwebdriver.chrome.driver=' + this.config_.chromeDriver);\n        }\n        this.server_ = new remote.SeleniumServer(this.config_.seleniumServerJar, serverConf);\n        let deferred = q.defer();\n        // start local server, grab hosted address, and resolve promise\n        this.server_.start(this.config_.seleniumServerStartTimeout)\n            .then((url) => {\n            logger.info('Selenium standalone server started at ' + url);\n            return this.server_.address();\n        })\n            .then((address) => {\n            this.config_.seleniumAddress = address;\n            deferred.resolve();\n        })\n            .catch((err) => {\n            deferred.reject(err);\n        });\n        return deferred.promise;\n    }\n    /**\n     * Teardown and destroy the environment and do any associated cleanup.\n     * Shuts down the drivers and server.\n     *\n     * @public\n     * @override\n     * @return {q.promise} A promise which will resolve when the environment\n     *     is down.\n     */\n    teardownEnv() {\n        return super.teardownEnv().then(() => {\n            logger.info('Shutting down selenium standalone server.');\n            return this.server_.stop();\n        });\n    }\n}\nexports.Local = Local;\n//# sourceMappingURL=local.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/node_modules/webdriver-manager/built/lib/binaries/chrome_driver.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst config_1 = require(\"../config\");\nconst binary_1 = require(\"./binary\");\nconst chrome_xml_1 = require(\"./chrome_xml\");\nclass ChromeDriver extends binary_1.Binary {\n    constructor(opt_alternativeCdn) {\n        super(opt_alternativeCdn || config_1.Config.cdnUrls().chrome);\n        this.configSource = new chrome_xml_1.ChromeXml();\n        this.name = 'chromedriver';\n        this.versionDefault = ChromeDriver.versionDefault;\n        this.versionCustom = this.versionDefault;\n    }\n    id() {\n        return ChromeDriver.id;\n    }\n    prefix() {\n        return 'chromedriver_';\n    }\n    suffix() {\n        return '.zip';\n    }\n    getVersionList() {\n        // If an alternative cdn is set, return an empty list.\n        if (this.alternativeDownloadUrl != null) {\n            Promise.resolve([]);\n        }\n        else {\n            return this.configSource.getVersionList();\n        }\n    }\n}\nChromeDriver.id = 'chrome';\nChromeDriver.isDefault = true;\nChromeDriver.os = [binary_1.OS.Windows_NT, binary_1.OS.Linux, binary_1.OS.Darwin];\nChromeDriver.versionDefault = config_1.Config.binaryVersions().chrome;\nexports.ChromeDriver = ChromeDriver;\n//# sourceMappingURL=chrome_driver.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/node_modules/webdriver-manager/built/lib/binaries/binary.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst config_1 = require(\"../config\");\n/**\n * operating system enum\n */\nvar OS;\n(function (OS) {\n    OS[OS[\"Windows_NT\"] = 0] = \"Windows_NT\";\n    OS[OS[\"Linux\"] = 1] = \"Linux\";\n    OS[OS[\"Darwin\"] = 2] = \"Darwin\";\n})(OS = exports.OS || (exports.OS = {}));\nclass Binary {\n    constructor(opt_alternativeCdn) {\n        this.ostype = config_1.Config.osType();\n        this.osarch = config_1.Config.osArch();\n        this.cdn = opt_alternativeCdn;\n    }\n    executableSuffix() {\n        if (this.ostype == 'Windows_NT') {\n            return '.exe';\n        }\n        else {\n            return '';\n        }\n    }\n    version() {\n        return this.versionCustom;\n    }\n    filename() {\n        return this.prefix() + this.version() + this.suffix();\n    }\n    /**\n     * @param ostype The operating system.\n     * @returns The file name for the executable.\n     */\n    executableFilename() {\n        return this.prefix() + this.version() + this.executableSuffix();\n    }\n    /**\n     * Gets the url to download the file set by the version. This will use the XML if available.\n     * If not, it will download from an existing url.\n     *\n     * @param {string} version The version we are looking for. This could also be 'latest'.\n     * @param {opt_proxy} string Option to get proxy URL.\n     * @param {opt_ignoreSSL} boolean Option to ignore SSL.\n     */\n    getUrl(version, opt_proxy, opt_ignoreSSL) {\n        this.opt_proxy = opt_proxy == undefined ? this.opt_proxy : opt_proxy;\n        this.opt_ignoreSSL = opt_ignoreSSL == undefined ? this.opt_ignoreSSL : opt_ignoreSSL;\n        if (this.configSource) {\n            this.configSource.opt_proxy = this.opt_proxy;\n            this.configSource.opt_ignoreSSL = this.opt_ignoreSSL;\n        }\n        if (this.alternativeDownloadUrl != null) {\n            return Promise.resolve({ url: '', version: '' });\n        }\n        else {\n            return this.getVersionList().then(() => {\n                version = version || config_1.Config.binaryVersions()[this.id()];\n                return this.configSource.getUrl(version).then(binaryUrl => {\n                    this.versionCustom = binaryUrl.version;\n                    return { url: binaryUrl.url, version: binaryUrl.version };\n                });\n            });\n        }\n    }\n    /**\n     * Delete an instance of this binary from the file system\n     */\n    remove(filename) {\n        fs.unlinkSync(filename);\n    }\n    /**\n     * @param ostype The operating system.\n     * @returns The file name for the file inside the downloaded zip file\n     */\n    zipContentName() {\n        return this.name + this.executableSuffix();\n    }\n}\nexports.Binary = Binary;\n//# sourceMappingURL=binary.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/node_modules/webdriver-manager/built/lib/binaries/chrome_xml.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst semver = require(\"semver\");\nconst config_1 = require(\"../config\");\nconst config_source_1 = require(\"./config_source\");\nclass ChromeXml extends config_source_1.XmlConfigSource {\n    constructor() {\n        super('chrome', config_1.Config.cdnUrls()['chrome']);\n    }\n    getUrl(version) {\n        if (version === 'latest') {\n            return this.getLatestChromeDriverVersion();\n        }\n        else {\n            return this.getSpecificChromeDriverVersion(version);\n        }\n    }\n    /**\n     * Get a list of chrome drivers paths available for the configuration OS type and architecture.\n     */\n    getVersionList() {\n        return this.getXml().then(xml => {\n            let versionPaths = [];\n            let osType = this.getOsTypeName();\n            for (let content of xml.ListBucketResult.Contents) {\n                let contentKey = content.Key[0];\n                // Filter for 32-bit devices, make sure x64 is not an option\n                if (this.osarch === 'x64' || !contentKey.includes('64')) {\n                    // Filter for only the osType\n                    if (contentKey.includes(osType)) {\n                        versionPaths.push(contentKey);\n                    }\n                }\n            }\n            return versionPaths;\n        });\n    }\n    /**\n     * Helper method, gets the ostype and gets the name used by the XML\n     */\n    getOsTypeName() {\n        // Get the os type name.\n        if (this.ostype === 'Darwin') {\n            return 'mac';\n        }\n        else if (this.ostype === 'Windows_NT') {\n            return 'win';\n        }\n        else {\n            return 'linux';\n        }\n    }\n    /**\n     * Gets the latest item from the XML.\n     */\n    getLatestChromeDriverVersion() {\n        return this.getVersionList().then(list => {\n            let chromedriverVersion = null;\n            let latest = '';\n            let latestVersion = '';\n            for (let item of list) {\n                // Get a semantic version\n                let version = item.split('/')[0];\n                if (semver.valid(version) == null) {\n                    version += '.0';\n                    if (semver.valid(version)) {\n                        // First time: use the version found.\n                        if (chromedriverVersion == null) {\n                            chromedriverVersion = version;\n                            latest = item;\n                            latestVersion = item.split('/')[0];\n                        }\n                        else if (semver.gt(version, chromedriverVersion)) {\n                            // After the first time, make sure the semantic version is greater.\n                            chromedriverVersion = version;\n                            latest = item;\n                            latestVersion = item.split('/')[0];\n                        }\n                        else if (version === chromedriverVersion) {\n                            // If the semantic version is the same, check os arch.\n                            // For 64-bit systems, prefer the 64-bit version.\n                            if (this.osarch === 'x64') {\n                                if (item.includes(this.getOsTypeName() + '64')) {\n                                    latest = item;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return { url: config_1.Config.cdnUrls().chrome + latest, version: latestVersion };\n        });\n    }\n    /**\n     * Gets a specific item from the XML.\n     */\n    getSpecificChromeDriverVersion(inputVersion) {\n        return this.getVersionList().then(list => {\n            let itemFound = '';\n            let specificVersion = semver.valid(inputVersion) ? inputVersion : inputVersion + '.0';\n            for (let item of list) {\n                // Get a semantic version.\n                let version = item.split('/')[0];\n                if (semver.valid(version) == null) {\n                    version += '.0';\n                    if (semver.valid(version)) {\n                        // Check to see if the specified version matches.\n                        if (version === specificVersion) {\n                            // When item found is null, check the os arch\n                            // 64-bit version works OR not 64-bit version and the path does not have '64'\n                            if (itemFound == '') {\n                                if (this.osarch === 'x64' ||\n                                    (this.osarch !== 'x64' && !item.includes(this.getOsTypeName() + '64'))) {\n                                    itemFound = item;\n                                }\n                            }\n                            else if (this.osarch === 'x64') {\n                                if (item.includes(this.getOsTypeName() + '64')) {\n                                    itemFound = item;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (itemFound == '') {\n                return { url: '', version: inputVersion };\n            }\n            else {\n                return { url: config_1.Config.cdnUrls().chrome + itemFound, version: inputVersion };\n            }\n        });\n    }\n}\nexports.ChromeXml = ChromeXml;\n//# sourceMappingURL=chrome_xml.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/node_modules/semver/semver.js":"exports = module.exports = SemVer;\n\n// The debug function is excluded entirely from the minified version.\n/* nomin */ var debug;\n/* nomin */ if (typeof process === 'object' &&\n    /* nomin */ process.env &&\n    /* nomin */ process.env.NODE_DEBUG &&\n    /* nomin */ /\\bsemver\\b/i.test(process.env.NODE_DEBUG))\n  /* nomin */ debug = function() {\n    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);\n    /* nomin */ args.unshift('SEMVER');\n    /* nomin */ console.log.apply(console, args);\n    /* nomin */ };\n/* nomin */ else\n  /* nomin */ debug = function() {};\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0';\n\nvar MAX_LENGTH = 256;\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n// The actual regexps go on exports.re\nvar re = exports.re = [];\nvar src = exports.src = [];\nvar R = 0;\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++;\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\nvar NUMERICIDENTIFIERLOOSE = R++;\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\n\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++;\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++;\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')';\n\nvar MAINVERSIONLOOSE = R++;\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++;\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')';\n\nvar PRERELEASEIDENTIFIERLOOSE = R++;\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\n\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++;\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\n\nvar PRERELEASELOOSE = R++;\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++;\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++;\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++;\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?';\n\nsrc[FULL] = '^' + FULLPLAIN + '$';\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?';\n\nvar LOOSE = R++;\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\n\nvar GTLT = R++;\nsrc[GTLT] = '((?:<|>)?=?)';\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++;\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\nvar XRANGEIDENTIFIER = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\n\nvar XRANGEPLAIN = R++;\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?';\n\nvar XRANGEPLAINLOOSE = R++;\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?';\n\nvar XRANGE = R++;\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\nvar XRANGELOOSE = R++;\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++;\nsrc[LONETILDE] = '(?:~>?)';\n\nvar TILDETRIM = R++;\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\nvar tildeTrimReplace = '$1~';\n\nvar TILDE = R++;\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\nvar TILDELOOSE = R++;\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++;\nsrc[LONECARET] = '(?:\\\\^)';\n\nvar CARETTRIM = R++;\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\nvar caretTrimReplace = '$1^';\n\nvar CARET = R++;\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\nvar CARETLOOSE = R++;\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++;\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\nvar COMPARATOR = R++;\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++;\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\nvar comparatorTrimReplace = '$1$2$3';\n\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++;\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$';\n\nvar HYPHENRANGELOOSE = R++;\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$';\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++;\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n  if (!re[i])\n    re[i] = new RegExp(src[i]);\n}\n\nexports.parse = parse;\nfunction parse(version, loose) {\n  if (version instanceof SemVer)\n    return version;\n\n  if (typeof version !== 'string')\n    return null;\n\n  if (version.length > MAX_LENGTH)\n    return null;\n\n  var r = loose ? re[LOOSE] : re[FULL];\n  if (!r.test(version))\n    return null;\n\n  try {\n    return new SemVer(version, loose);\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.valid = valid;\nfunction valid(version, loose) {\n  var v = parse(version, loose);\n  return v ? v.version : null;\n}\n\n\nexports.clean = clean;\nfunction clean(version, loose) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);\n  return s ? s.version : null;\n}\n\nexports.SemVer = SemVer;\n\nfunction SemVer(version, loose) {\n  if (version instanceof SemVer) {\n    if (version.loose === loose)\n      return version;\n    else\n      version = version.version;\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  if (version.length > MAX_LENGTH)\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n\n  if (!(this instanceof SemVer))\n    return new SemVer(version, loose);\n\n  debug('SemVer', version, loose);\n  this.loose = loose;\n  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);\n\n  if (!m)\n    throw new TypeError('Invalid Version: ' + version);\n\n  this.raw = version;\n\n  // these are actually numbers\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0)\n    throw new TypeError('Invalid major version')\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)\n    throw new TypeError('Invalid minor version')\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)\n    throw new TypeError('Invalid patch version')\n\n  // numberify any prerelease numeric ids\n  if (!m[4])\n    this.prerelease = [];\n  else\n    this.prerelease = m[4].split('.').map(function(id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id;\n        if (num >= 0 && num < MAX_SAFE_INTEGER)\n          return num;\n      }\n      return id;\n    });\n\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\n\nSemVer.prototype.format = function() {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n  if (this.prerelease.length)\n    this.version += '-' + this.prerelease.join('.');\n  return this.version;\n};\n\nSemVer.prototype.toString = function() {\n  return this.version;\n};\n\nSemVer.prototype.compare = function(other) {\n  debug('SemVer.compare', this.version, this.loose, other);\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return this.compareMain(other) || this.comparePre(other);\n};\n\nSemVer.prototype.compareMain = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch);\n};\n\nSemVer.prototype.comparePre = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length)\n    return -1;\n  else if (!this.prerelease.length && other.prerelease.length)\n    return 1;\n  else if (!this.prerelease.length && !other.prerelease.length)\n    return 0;\n\n  var i = 0;\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n    if (a === undefined && b === undefined)\n      return 0;\n    else if (b === undefined)\n      return 1;\n    else if (a === undefined)\n      return -1;\n    else if (a === b)\n      continue;\n    else\n      return compareIdentifiers(a, b);\n  } while (++i);\n};\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function(release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc('pre', identifier);\n      break;\n    case 'preminor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc('pre', identifier);\n      break;\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0;\n      this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0)\n        this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)\n        this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0)\n        this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0)\n        this.patch++;\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0)\n        this.prerelease = [0];\n      else {\n        var i = this.prerelease.length;\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n        if (i === -1) // didn't increment anything\n          this.prerelease.push(0);\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1]))\n            this.prerelease = [identifier, 0];\n        } else\n          this.prerelease = [identifier, 0];\n      }\n      break;\n\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\n\nexports.inc = inc;\nfunction inc(version, release, loose, identifier) {\n  if (typeof(loose) === 'string') {\n    identifier = loose;\n    loose = undefined;\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.diff = diff;\nfunction diff(version1, version2) {\n  if (eq(version1, version2)) {\n    return null;\n  } else {\n    var v1 = parse(version1);\n    var v2 = parse(version2);\n    if (v1.prerelease.length || v2.prerelease.length) {\n      for (var key in v1) {\n        if (key === 'major' || key === 'minor' || key === 'patch') {\n          if (v1[key] !== v2[key]) {\n            return 'pre'+key;\n          }\n        }\n      }\n      return 'prerelease';\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return key;\n        }\n      }\n    }\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\n\nvar numeric = /^[0-9]+$/;\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return (anum && !bnum) ? -1 :\n         (bnum && !anum) ? 1 :\n         a < b ? -1 :\n         a > b ? 1 :\n         0;\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers;\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\n\nexports.major = major;\nfunction major(a, loose) {\n  return new SemVer(a, loose).major;\n}\n\nexports.minor = minor;\nfunction minor(a, loose) {\n  return new SemVer(a, loose).minor;\n}\n\nexports.patch = patch;\nfunction patch(a, loose) {\n  return new SemVer(a, loose).patch;\n}\n\nexports.compare = compare;\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(b);\n}\n\nexports.compareLoose = compareLoose;\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\n\nexports.rcompare = rcompare;\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\n\nexports.sort = sort;\nfunction sort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.compare(a, b, loose);\n  });\n}\n\nexports.rsort = rsort;\nfunction rsort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.rcompare(a, b, loose);\n  });\n}\n\nexports.gt = gt;\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\n\nexports.lt = lt;\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\n\nexports.eq = eq;\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\n\nexports.neq = neq;\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\n\nexports.gte = gte;\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\n\nexports.lte = lte;\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\n\nexports.cmp = cmp;\nfunction cmp(a, op, b, loose) {\n  var ret;\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a === b;\n      break;\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a !== b;\n      break;\n    case '': case '=': case '==': ret = eq(a, b, loose); break;\n    case '!=': ret = neq(a, b, loose); break;\n    case '>': ret = gt(a, b, loose); break;\n    case '>=': ret = gte(a, b, loose); break;\n    case '<': ret = lt(a, b, loose); break;\n    case '<=': ret = lte(a, b, loose); break;\n    default: throw new TypeError('Invalid operator: ' + op);\n  }\n  return ret;\n}\n\nexports.Comparator = Comparator;\nfunction Comparator(comp, loose) {\n  if (comp instanceof Comparator) {\n    if (comp.loose === loose)\n      return comp;\n    else\n      comp = comp.value;\n  }\n\n  if (!(this instanceof Comparator))\n    return new Comparator(comp, loose);\n\n  debug('comparator', comp, loose);\n  this.loose = loose;\n  this.parse(comp);\n\n  if (this.semver === ANY)\n    this.value = '';\n  else\n    this.value = this.operator + this.semver.version;\n\n  debug('comp', this);\n}\n\nvar ANY = {};\nComparator.prototype.parse = function(comp) {\n  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var m = comp.match(r);\n\n  if (!m)\n    throw new TypeError('Invalid comparator: ' + comp);\n\n  this.operator = m[1];\n  if (this.operator === '=')\n    this.operator = '';\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2])\n    this.semver = ANY;\n  else\n    this.semver = new SemVer(m[2], this.loose);\n};\n\nComparator.prototype.toString = function() {\n  return this.value;\n};\n\nComparator.prototype.test = function(version) {\n  debug('Comparator.test', version, this.loose);\n\n  if (this.semver === ANY)\n    return true;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  return cmp(version, this.operator, this.semver, this.loose);\n};\n\n\nexports.Range = Range;\nfunction Range(range, loose) {\n  if ((range instanceof Range) && range.loose === loose)\n    return range;\n\n  if (!(this instanceof Range))\n    return new Range(range, loose);\n\n  this.loose = loose;\n\n  // First, split based on boolean or ||\n  this.raw = range;\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function(c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range);\n  }\n\n  this.format();\n}\n\nRange.prototype.format = function() {\n  this.range = this.set.map(function(comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\n\nRange.prototype.toString = function() {\n  return this.range;\n};\n\nRange.prototype.parseRange = function(range) {\n  var loose = this.loose;\n  range = range.trim();\n  debug('range', range, loose);\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range);\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, re[COMPARATORTRIM]);\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace);\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace);\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ');\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var set = range.split(' ').map(function(comp) {\n    return parseComparator(comp, loose);\n  }).join(' ').split(/\\s+/);\n  if (this.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function(comp) {\n      return !!comp.match(compRe);\n    });\n  }\n  set = set.map(function(comp) {\n    return new Comparator(comp, loose);\n  });\n\n  return set;\n};\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators;\nfunction toComparators(range, loose) {\n  return new Range(range, loose).set.map(function(comp) {\n    return comp.map(function(c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp, loose) {\n  debug('comp', comp);\n  comp = replaceCarets(comp, loose);\n  debug('caret', comp);\n  comp = replaceTildes(comp, loose);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, loose);\n  debug('xrange', comp);\n  comp = replaceStars(comp, loose);\n  debug('stars', comp);\n  return comp;\n}\n\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceTilde(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceTilde(comp, loose) {\n  var r = loose ? re[TILDELOOSE] : re[TILDE];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p))\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    else if (pr) {\n      debug('replaceTilde pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      ret = '>=' + M + '.' + m + '.' + p + pr +\n            ' <' + M + '.' + (+m + 1) + '.0';\n    } else\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0';\n\n    debug('tilde return', ret);\n    return ret;\n  });\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceCaret(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceCaret(comp, loose) {\n  debug('caret', comp, loose);\n  var r = loose ? re[CARETLOOSE] : re[CARET];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p)) {\n      if (M === '0')\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n      else\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p + pr +\n              ' <' + (+M + 1) + '.0.0';\n    } else {\n      debug('no pr');\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0';\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp, loose) {\n  debug('replaceXRanges', comp, loose);\n  return comp.split(/\\s+/).map(function(comp) {\n    return replaceXRange(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceXRange(comp, loose) {\n  comp = comp.trim();\n  var r = loose ? re[XRANGELOOSE] : re[XRANGE];\n  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n\n    if (gtlt === '=' && anyX)\n      gtlt = '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // replace X with 0\n      if (xm)\n        m = 0;\n      if (xp)\n        p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>=';\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else if (xp) {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<';\n        if (xm)\n          M = +M + 1;\n        else\n          m = +m + 1;\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p;\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    }\n\n    debug('xRange return', ret);\n\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp, loose) {\n  debug('replaceStars', comp, loose);\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '');\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace($0,\n                       from, fM, fm, fp, fpr, fb,\n                       to, tM, tm, tp, tpr, tb) {\n\n  if (isX(fM))\n    from = '';\n  else if (isX(fm))\n    from = '>=' + fM + '.0.0';\n  else if (isX(fp))\n    from = '>=' + fM + '.' + fm + '.0';\n  else\n    from = '>=' + from;\n\n  if (isX(tM))\n    to = '';\n  else if (isX(tm))\n    to = '<' + (+tM + 1) + '.0.0';\n  else if (isX(tp))\n    to = '<' + tM + '.' + (+tm + 1) + '.0';\n  else if (tpr)\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  else\n    to = '<=' + to;\n\n  return (from + ' ' + to).trim();\n}\n\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function(version) {\n  if (!version)\n    return false;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version))\n      return true;\n  }\n  return false;\n};\n\nfunction testSet(set, version) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version))\n      return false;\n  }\n\n  if (version.prerelease.length) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (var i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n      if (set[i].semver === ANY)\n        continue;\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver;\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch)\n          return true;\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false;\n  }\n\n  return true;\n}\n\nexports.satisfies = satisfies;\nfunction satisfies(version, range, loose) {\n  try {\n    range = new Range(range, loose);\n  } catch (er) {\n    return false;\n  }\n  return range.test(version);\n}\n\nexports.maxSatisfying = maxSatisfying;\nfunction maxSatisfying(versions, range, loose) {\n  return versions.filter(function(version) {\n    return satisfies(version, range, loose);\n  }).sort(function(a, b) {\n    return rcompare(a, b, loose);\n  })[0] || null;\n}\n\nexports.minSatisfying = minSatisfying;\nfunction minSatisfying(versions, range, loose) {\n  return versions.filter(function(version) {\n    return satisfies(version, range, loose);\n  }).sort(function(a, b) {\n    return compare(a, b, loose);\n  })[0] || null;\n}\n\nexports.validRange = validRange;\nfunction validRange(range, loose) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, loose).range || '*';\n  } catch (er) {\n    return null;\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr;\nfunction ltr(version, range, loose) {\n  return outside(version, range, '<', loose);\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr;\nfunction gtr(version, range, loose) {\n  return outside(version, range, '>', loose);\n}\n\nexports.outside = outside;\nfunction outside(version, range, hilo, loose) {\n  version = new SemVer(version, loose);\n  range = new Range(range, loose);\n\n  var gtfn, ltefn, ltfn, comp, ecomp;\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, loose)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n\n    var high = null;\n    var low = null;\n\n    comparators.forEach(function(comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, loose)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, loose)) {\n        low = comparator;\n      }\n    });\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexports.prerelease = prerelease;\nfunction prerelease(version, loose) {\n  var parsed = parse(version, loose);\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;\n}\n","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/node_modules/webdriver-manager/built/lib/binaries/config_source.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst request = require(\"request\");\nconst xml2js = require(\"xml2js\");\nconst config_1 = require(\"../config\");\nconst http_utils_1 = require(\"../http_utils\");\nclass ConfigSource {\n    constructor() {\n        this.ostype = config_1.Config.osType();\n        this.osarch = config_1.Config.osArch();\n        this.out_dir = config_1.Config.getSeleniumDir();\n    }\n}\nexports.ConfigSource = ConfigSource;\nclass XmlConfigSource extends ConfigSource {\n    constructor(name, xmlUrl) {\n        super();\n        this.name = name;\n        this.xmlUrl = xmlUrl;\n    }\n    getFileName() {\n        try {\n            fs.statSync(this.out_dir);\n        }\n        catch (e) {\n            fs.mkdirSync(this.out_dir);\n        }\n        return path.resolve(this.out_dir, this.name + '-response.xml');\n    }\n    getXml() {\n        let fileName = this.getFileName();\n        let content = this.readResponse();\n        if (content != null) {\n            return Promise.resolve(content);\n        }\n        return this.requestXml().then(text => {\n            let xml = this.convertXml2js(text);\n            fs.writeFileSync(fileName, text);\n            return xml;\n        });\n    }\n    readResponse() {\n        let fileName = this.getFileName();\n        try {\n            let contents = fs.readFileSync(fileName).toString();\n            let timestamp = new Date(fs.statSync(fileName).mtime).getTime();\n            let now = Date.now();\n            // 60 minutes * 60 seconds / minute * 1000 ms / second\n            if (now - (60 * 60 * 1000) < timestamp) {\n                return this.convertXml2js(contents);\n            }\n        }\n        catch (err) {\n            return null;\n        }\n    }\n    requestXml() {\n        return new Promise((resolve, reject) => {\n            let options = http_utils_1.HttpUtils.initOptions(this.xmlUrl);\n            options = http_utils_1.HttpUtils.optionsSSL(options, this.opt_ignoreSSL);\n            options = http_utils_1.HttpUtils.optionsProxy(options, this.xmlUrl, this.opt_proxy);\n            let req = request(options);\n            req.on('response', response => {\n                if (response.statusCode === 200) {\n                    // logger.info('curl -v ' + options.url);\n                    let output = '';\n                    response.on('data', (data) => {\n                        output += data;\n                    });\n                    response.on('end', () => {\n                        resolve(output);\n                    });\n                }\n                else {\n                    reject(new Error('response status code is not 200'));\n                }\n            });\n        });\n    }\n    convertXml2js(xml) {\n        let retResult = null;\n        xml2js.parseString(xml, (err, result) => {\n            retResult = result;\n        });\n        return retResult;\n    }\n}\nexports.XmlConfigSource = XmlConfigSource;\nclass JsonConfigSource extends ConfigSource {\n    constructor(name, jsonUrl) {\n        super();\n        this.name = name;\n        this.jsonUrl = jsonUrl;\n    }\n    getFileName() {\n        try {\n            fs.statSync(this.out_dir);\n        }\n        catch (e) {\n            fs.mkdirSync(this.out_dir);\n        }\n        return path.resolve(this.out_dir, this.name + '-response.json');\n    }\n}\nexports.JsonConfigSource = JsonConfigSource;\nclass GithubApiConfigSource extends JsonConfigSource {\n    constructor(name, url) {\n        super(name, url);\n    }\n    /**\n     * This is an unauthenticated request and since Github limits the rate, we will cache this\n     * to a file. { timestamp: number, response: response }. We will check the timestamp and renew\n     * this request if the file is older than an hour.\n     */\n    getJson() {\n        let fileName = this.getFileName();\n        let content = this.readResponse();\n        if (content != null) {\n            return Promise.resolve(JSON.parse(content));\n        }\n        else {\n            return this.requestJson().then(body => {\n                let json = JSON.parse(body);\n                fs.writeFileSync(fileName, JSON.stringify(json, null, '  '));\n                return json;\n            });\n        }\n    }\n    requestJson() {\n        return new Promise((resolve, reject) => {\n            let options = http_utils_1.HttpUtils.initOptions(this.jsonUrl);\n            options = http_utils_1.HttpUtils.optionsSSL(options, this.opt_ignoreSSL);\n            options = http_utils_1.HttpUtils.optionsProxy(options, this.jsonUrl, this.opt_proxy);\n            options = http_utils_1.HttpUtils.optionsHeader(options, 'Host', 'api.github.com');\n            options = http_utils_1.HttpUtils.optionsHeader(options, 'User-Agent', 'request');\n            let req = request(options);\n            req.on('response', response => {\n                if (response.statusCode === 200) {\n                    // logger.info('curl -v ' + options.url);\n                    let output = '';\n                    response.on('data', (data) => {\n                        output += data;\n                    });\n                    response.on('end', () => {\n                        resolve(output);\n                    });\n                }\n                else if (response.statusCode == 403 && response.headers['x-ratelimit-remaining'] == 0) {\n                    reject(new Error('Failed to make Github request, rate limit reached.'));\n                }\n                else {\n                    reject(new Error('response status code is not 200.  It was ' + response.statusCode));\n                }\n            });\n        });\n    }\n    readResponse() {\n        let fileName = this.getFileName();\n        try {\n            let contents = fs.readFileSync(fileName).toString();\n            let timestamp = new Date(fs.statSync(fileName).mtime).getTime();\n            let now = Date.now();\n            // 60 minutes * 60 seconds / minute * 1000 ms / second\n            if (now - (60 * 60 * 1000) < timestamp) {\n                return contents;\n            }\n        }\n        catch (err) {\n            return null;\n        }\n    }\n}\nexports.GithubApiConfigSource = GithubApiConfigSource;\n//# sourceMappingURL=config_source.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/node_modules/webdriver-manager/built/lib/http_utils.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst url = require(\"url\");\nconst logger_1 = require(\"./cli/logger\");\nconst config_1 = require(\"./config\");\nlet logger = new logger_1.Logger('http_utils');\nclass HttpUtils {\n    static initOptions(url, timeout) {\n        let options = {\n            url: url,\n            // default Linux can be anywhere from 20-120 seconds\n            // increasing this arbitrarily to 4 minutes\n            timeout: 240000\n        };\n        return options;\n    }\n    static optionsSSL(options, opt_ignoreSSL) {\n        if (opt_ignoreSSL) {\n            logger.info('ignoring SSL certificate');\n            options.strictSSL = !opt_ignoreSSL;\n            options.rejectUnauthorized = !opt_ignoreSSL;\n        }\n        return options;\n    }\n    static optionsProxy(options, requestUrl, opt_proxy) {\n        if (opt_proxy) {\n            options.proxy = HttpUtils.resolveProxy(requestUrl, opt_proxy);\n            if (url.parse(requestUrl).protocol === 'https:') {\n                options.url = requestUrl.replace('https:', 'http:');\n            }\n        }\n        return options;\n    }\n    static optionsHeader(options, key, value) {\n        if (options.headers == null) {\n            options.headers = {};\n        }\n        options.headers[key] = value;\n        return options;\n    }\n    /**\n     * Resolves proxy based on values set\n     * @param fileUrl The url to download the file.\n     * @param opt_proxy The proxy to connect to to download files.\n     * @return Either undefined or the proxy.\n     */\n    static resolveProxy(fileUrl, opt_proxy) {\n        let protocol = url.parse(fileUrl).protocol;\n        let hostname = url.parse(fileUrl).hostname;\n        if (opt_proxy) {\n            return opt_proxy;\n        }\n        else {\n            // If the NO_PROXY environment variable exists and matches the host name,\n            // to ignore the resolve proxy.\n            // the checks to see if it exists and equal to empty string is to help with testing\n            let noProxy = config_1.Config.noProxy();\n            if (noProxy) {\n                // array of hostnames/domain names listed in the NO_PROXY environment variable\n                let noProxyTokens = noProxy.split(',');\n                // check if the fileUrl hostname part does not end with one of the\n                // NO_PROXY environment variable's hostnames/domain names\n                for (let noProxyToken of noProxyTokens) {\n                    if (hostname.indexOf(noProxyToken) !== -1) {\n                        return undefined;\n                    }\n                }\n            }\n            // If the HTTPS_PROXY and HTTP_PROXY environment variable is set, use that as the proxy\n            if (protocol === 'https:') {\n                return config_1.Config.httpsProxy() || config_1.Config.httpProxy();\n            }\n            else if (protocol === 'http:') {\n                return config_1.Config.httpProxy();\n            }\n        }\n        return undefined;\n    }\n}\nexports.HttpUtils = HttpUtils;\n//# sourceMappingURL=http_utils.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/node_modules/webdriver-manager/built/lib/binaries/standalone.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst config_1 = require(\"../config\");\nconst binary_1 = require(\"./binary\");\nconst standalone_xml_1 = require(\"./standalone_xml\");\nclass Standalone extends binary_1.Binary {\n    constructor(opt_alternativeCdn) {\n        super(opt_alternativeCdn || config_1.Config.cdnUrls().selenium);\n        this.configSource = new standalone_xml_1.StandaloneXml();\n        this.name = 'selenium standalone';\n        this.versionDefault = Standalone.versionDefault;\n        this.versionCustom = this.versionDefault;\n    }\n    id() {\n        return Standalone.id;\n    }\n    prefix() {\n        return 'selenium-server-standalone-';\n    }\n    suffix() {\n        return '.jar';\n    }\n    executableSuffix() {\n        return '.jar';\n    }\n    getVersionList() {\n        // If an alternative cdn is set, return an empty list.\n        if (this.alternativeDownloadUrl != null) {\n            return Promise.resolve([]);\n        }\n        else {\n            return this.configSource.getVersionList();\n        }\n    }\n}\nStandalone.id = 'standalone';\nStandalone.isDefault = true;\nStandalone.os = [binary_1.OS.Windows_NT, binary_1.OS.Linux, binary_1.OS.Darwin];\nStandalone.versionDefault = config_1.Config.binaryVersions().selenium;\nexports.Standalone = Standalone;\n//# sourceMappingURL=standalone.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/node_modules/webdriver-manager/built/lib/binaries/standalone_xml.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst semver = require(\"semver\");\nconst config_1 = require(\"../config\");\nconst config_source_1 = require(\"./config_source\");\nclass StandaloneXml extends config_source_1.XmlConfigSource {\n    constructor() {\n        super('standalone', config_1.Config.cdnUrls()['selenium']);\n    }\n    getUrl(version) {\n        if (version === 'latest') {\n            return this.getLatestStandaloneVersion();\n        }\n        else {\n            return this.getSpecificStandaloneVersion(version);\n        }\n    }\n    getVersionList() {\n        return this.getXml().then(xml => {\n            let versionPaths = [];\n            for (let content of xml.ListBucketResult.Contents) {\n                let contentKey = content.Key[0];\n                // Filter the selenium-server-standalone.\n                if (contentKey.includes('selenium-server-standalone')) {\n                    versionPaths.push(contentKey);\n                }\n            }\n            return versionPaths;\n        });\n    }\n    getLatestStandaloneVersion() {\n        return this.getVersionList().then(list => {\n            let standaloneVersion = null;\n            let latest = '';\n            let latestVersion = '';\n            for (let item of list) {\n                // Get a semantic version.\n                let version = item.split('selenium-server-standalone-')[1].replace('.jar', '');\n                // Do not do beta versions for latest.\n                if (!version.includes('beta')) {\n                    if (standaloneVersion == null) {\n                        // First time: use the version found.\n                        standaloneVersion = version;\n                        latest = item;\n                        latestVersion = version;\n                    }\n                    else if (semver.gt(version, standaloneVersion)) {\n                        // Get the latest.\n                        standaloneVersion = version;\n                        latest = item;\n                        latestVersion = version;\n                    }\n                }\n            }\n            return { url: config_1.Config.cdnUrls().selenium + latest, version: latestVersion };\n        });\n    }\n    getSpecificStandaloneVersion(inputVersion) {\n        return this.getVersionList().then(list => {\n            let itemFound = '';\n            let standaloneVersion = null;\n            for (let item of list) {\n                // Get a semantic version.\n                let version = item.split('selenium-server-standalone-')[1].replace('.jar', '');\n                // Check to see if the specified version matches.\n                let firstPath = item.split('/')[0];\n                if (version === inputVersion) {\n                    // Check if the beta exists that we have the right version\n                    // Example: We will see that beta3 appears in the file and path\n                    // 3.0-beta3/selenium-server-standalone-3.0.0-beta3.jar\n                    // where this should not work:\n                    // 3.0-beta2/selenium-server-standalone-3.0.0-beta3.jar\n                    if (inputVersion.includes('beta')) {\n                        let betaInputVersion = inputVersion.replace('.jar', '').split('beta')[1];\n                        if (item.split('/')[0].includes('beta' + betaInputVersion)) {\n                            return { url: config_1.Config.cdnUrls().selenium + item, version: version };\n                        }\n                    }\n                    else {\n                        return { url: config_1.Config.cdnUrls().selenium + item, version: version };\n                    }\n                }\n            }\n        });\n    }\n}\nexports.StandaloneXml = StandaloneXml;\n//# sourceMappingURL=standalone_xml.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/driverProviders/mock.js":"\"use strict\";\n/*\n * This is an mock implementation of the Driver Provider.\n * It returns a fake webdriver and never actually contacts a selenium\n * server.\n */\nconst q = require('q');\nconst selenium_webdriver_1 = require('selenium-webdriver');\nconst driverProvider_1 = require('./driverProvider');\nclass MockExecutor {\n    execute(command) { }\n}\nexports.MockExecutor = MockExecutor;\nclass Mock extends driverProvider_1.DriverProvider {\n    constructor(config) {\n        super(config);\n    }\n    /**\n     * An execute function that returns a promise with a test value.\n     */\n    execute() {\n        let deferred = q.defer();\n        deferred.resolve({ value: 'test_response' });\n        return deferred.promise;\n    }\n    /**\n     * Configure and launch (if applicable) the object's environment.\n     * @public\n     * @return {q.promise} A promise which will resolve immediately.\n     */\n    setupDriverEnv() {\n        return q.fcall(function () { });\n    }\n    /**\n     * Create a new driver.\n     *\n     * @public\n     * @override\n     * @return webdriver instance\n     */\n    getNewDriver() {\n        let mockSession = new selenium_webdriver_1.Session('test_session_id', {});\n        let newDriver = new selenium_webdriver_1.WebDriver(mockSession, new MockExecutor());\n        this.drivers_.push(newDriver);\n        return newDriver;\n    }\n}\nexports.Mock = Mock;\n//# sourceMappingURL=mock.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/driverProviders/sauce.js":"/*\n * This is an implementation of the SauceLabs Driver Provider.\n * It is responsible for setting up the account object, tearing\n * it down, and setting up the driver correctly.\n */\n\"use strict\";\nconst q = require('q');\nconst util = require('util');\nconst logger_1 = require('../logger');\nconst driverProvider_1 = require('./driverProvider');\nconst SauceLabs = require('saucelabs');\nlet logger = new logger_1.Logger('sauce');\nclass Sauce extends driverProvider_1.DriverProvider {\n    constructor(config) {\n        super(config);\n    }\n    /**\n     * Hook to update the sauce job.\n     * @public\n     * @param {Object} update\n     * @return {q.promise} A promise that will resolve when the update is complete.\n     */\n    updateJob(update) {\n        let deferredArray = this.drivers_.map((driver) => {\n            let deferred = q.defer();\n            driver.getSession().then((session) => {\n                logger.info('SauceLabs results available at http://saucelabs.com/jobs/' + session.getId());\n                this.sauceServer_.updateJob(session.getId(), update, (err) => {\n                    if (err) {\n                        throw new Error('Error updating Sauce pass/fail status: ' + util.inspect(err));\n                    }\n                    deferred.resolve();\n                });\n            });\n            return deferred.promise;\n        });\n        return q.all(deferredArray);\n    }\n    /**\n     * Configure and launch (if applicable) the object's environment.\n     * @public\n     * @return {q.promise} A promise which will resolve when the environment is\n     *     ready to test.\n     */\n    setupDriverEnv() {\n        let deferred = q.defer();\n        this.sauceServer_ = new SauceLabs({\n            username: this.config_.sauceUser,\n            password: this.config_.sauceKey,\n            agent: this.config_.sauceAgent,\n            proxy: this.config_.webDriverProxy\n        });\n        this.config_.capabilities['username'] = this.config_.sauceUser;\n        this.config_.capabilities['accessKey'] = this.config_.sauceKey;\n        this.config_.capabilities['build'] = this.config_.sauceBuild;\n        let auth = 'https://' + this.config_.sauceUser + ':' + this.config_.sauceKey + '@';\n        this.config_.seleniumAddress =\n            auth + (this.config_.sauceSeleniumAddress ? this.config_.sauceSeleniumAddress :\n                'ondemand.saucelabs.com:443/wd/hub');\n        // Append filename to capabilities.name so that it's easier to identify\n        // tests.\n        if (this.config_.capabilities.name && this.config_.capabilities.shardTestFiles) {\n            this.config_.capabilities.name +=\n                (':' + this.config_.specs.toString().replace(/^.*[\\\\\\/]/, ''));\n        }\n        logger.info('Using SauceLabs selenium server at ' +\n            this.config_.seleniumAddress.replace(/\\/\\/.+@/, '//'));\n        deferred.resolve();\n        return deferred.promise;\n    }\n}\nexports.Sauce = Sauce;\n//# sourceMappingURL=sauce.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/plugins.js":"\"use strict\";\nconst q = require('q');\nconst webdriver = require('selenium-webdriver');\nconst configParser_1 = require('./configParser');\nconst logger_1 = require('./logger');\nconst ptor_1 = require('./ptor');\nlet logger = new logger_1.Logger('plugins');\n(function (PromiseType) {\n    PromiseType[PromiseType[\"Q\"] = 0] = \"Q\";\n    PromiseType[PromiseType[\"WEBDRIVER\"] = 1] = \"WEBDRIVER\";\n})(exports.PromiseType || (exports.PromiseType = {}));\nvar PromiseType = exports.PromiseType;\n/**\n * The plugin API for Protractor.  Note that this API is unstable. See\n * plugins/README.md for more information.\n *\n * @constructor\n * @param {Object} config parsed from the config file\n */\nclass Plugins {\n    constructor(config) {\n        /**\n         * @see docs/plugins.md#writing-plugins for information on these functions\n         */\n        this.setup = this.pluginFunFactory('setup', PromiseType.Q);\n        this.onPrepare = this.pluginFunFactory('onPrepare', PromiseType.Q);\n        this.teardown = this.pluginFunFactory('teardown', PromiseType.Q);\n        this.postResults = this.pluginFunFactory('postResults', PromiseType.Q);\n        this.postTest = this.pluginFunFactory('postTest', PromiseType.Q);\n        this.onPageLoad = this.pluginFunFactory('onPageLoad', PromiseType.WEBDRIVER);\n        this.onPageStable = this.pluginFunFactory('onPageStable', PromiseType.WEBDRIVER);\n        this.waitForPromise = this.pluginFunFactory('waitForPromise', PromiseType.WEBDRIVER);\n        this.waitForCondition = this.pluginFunFactory('waitForCondition', PromiseType.WEBDRIVER, true);\n        this.pluginObjs = [];\n        this.assertions = {};\n        this.resultsReported = false;\n        if (config.plugins) {\n            config.plugins.forEach((pluginConf, i) => {\n                let path;\n                if (pluginConf.path) {\n                    path = configParser_1.ConfigParser.resolveFilePatterns(pluginConf.path, true, config.configDir)[0];\n                    if (!path) {\n                        throw new Error('Invalid path to plugin: ' + pluginConf.path);\n                    }\n                }\n                else {\n                    path = pluginConf.package;\n                }\n                let pluginObj;\n                if (path) {\n                    pluginObj = require(path);\n                }\n                else if (pluginConf.inline) {\n                    pluginObj = pluginConf.inline;\n                }\n                else {\n                    throw new Error('Plugin configuration did not contain a valid path or ' +\n                        'inline definition.');\n                }\n                this.annotatePluginObj(pluginObj, pluginConf, i);\n                logger.debug('Plugin \"' + pluginObj.name + '\" loaded.');\n                this.pluginObjs.push(pluginObj);\n            });\n        }\n    }\n    ;\n    /**\n     * Adds properties to a plugin's object\n     *\n     * @see docs/plugins.md#provided-properties-and-functions\n     */\n    annotatePluginObj(obj, conf, i) {\n        let addAssertion = (info, passed, message) => {\n            if (this.resultsReported) {\n                throw new Error('Cannot add new tests results, since they were already ' +\n                    'reported.');\n            }\n            info = info || {};\n            const specName = info.specName || (obj.name + ' Plugin Tests');\n            const assertion = { passed: passed };\n            if (!passed) {\n                assertion.errorMsg = message;\n                if (info.stackTrace) {\n                    assertion.stackTrace = info.stackTrace;\n                }\n            }\n            this.assertions[specName] = this.assertions[specName] || [];\n            this.assertions[specName].push(assertion);\n        };\n        obj.name = obj.name || conf.name || conf.path || conf.package || ('Plugin #' + i);\n        obj.config = conf;\n        obj.addFailure = (message, info) => {\n            addAssertion(info, false, message);\n        };\n        obj.addSuccess = (options) => {\n            addAssertion(options, true);\n        };\n        obj.addWarning = (message, options) => {\n            options = options || {};\n            logger.warn('Warning ' +\n                (options.specName ? 'in ' + options.specName : 'from \"' + obj.name + '\" plugin') + ': ' +\n                message);\n        };\n    }\n    printPluginResults(specResults) {\n        const green = '\\x1b[32m';\n        const red = '\\x1b[31m';\n        const normalColor = '\\x1b[39m';\n        const printResult = (message, pass) => {\n            logger.info(pass ? green : red, '\\t', pass ? 'Pass: ' : 'Fail: ', message, normalColor);\n        };\n        for (const specResult of specResults) {\n            const passed = specResult.assertions.map(x => x.passed).reduce((x, y) => (x && y), true);\n            printResult(specResult.description, passed);\n            if (!passed) {\n                for (const assertion of specResult.assertions) {\n                    if (!assertion.passed) {\n                        logger.error('\\t\\t' + assertion.errorMsg);\n                        if (assertion.stackTrace) {\n                            logger.error('\\t\\t' + assertion.stackTrace.replace(/\\n/g, '\\n\\t\\t'));\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Gets the tests results generated by any plugins\n     *\n     * @see lib/frameworks/README.md#requirements for a complete description of what\n     *     the results object must look like\n     *\n     * @return {Object} The results object\n     */\n    getResults() {\n        const results = { failedCount: 0, specResults: [] };\n        for (const specName in this.assertions) {\n            results.specResults.push({ description: specName, assertions: this.assertions[specName] });\n            results.failedCount +=\n                this.assertions[specName].filter(assertion => !assertion.passed).length;\n        }\n        this.printPluginResults(results.specResults);\n        this.resultsReported = true;\n        return results;\n    }\n    ;\n    /**\n     * Returns true if any loaded plugin has skipAngularStability enabled.\n     *\n     * @return {boolean}\n     */\n    skipAngularStability() {\n        const result = this.pluginObjs.some(pluginObj => pluginObj.skipAngularStability);\n        return result;\n    }\n    ;\n    /**\n     * Calls a function from a plugin safely.  If the plugin's function throws an\n     * exception or returns a rejected promise, that failure will be logged as a\n     * failed test result instead of crashing protractor.  If the tests results have\n     * already been reported, the failure will be logged to the console.\n     *\n     * @param {Object} pluginObj The plugin object containing the function to be run\n     * @param {string} funName The name of the function we want to run\n     * @param {*[]} args The arguments we want to invoke the function with\n     * @param {PromiseType} promiseType The type of promise (WebDriver or Q) that\n     *    should be used\n     * @param {boolean} resultsReported If the results have already been reported\n     * @param {*} failReturnVal The value to return if the function fails\n     *\n     * @return {webdriver.promise.Promise|Q.Promise} A promise which resolves to the\n     *     function's return value\n     */\n    safeCallPluginFun(pluginObj, funName, args, promiseType, failReturnVal) {\n        const resolver = (done) => {\n            const logError = (e) => {\n                if (this.resultsReported) {\n                    this.printPluginResults([{\n                            description: pluginObj.name + ' Runtime',\n                            assertions: [{\n                                    passed: false,\n                                    errorMsg: 'Failure during ' + funName + ': ' + (e.message || e),\n                                    stackTrace: e.stack\n                                }]\n                        }]);\n                }\n                else {\n                    pluginObj.addFailure('Failure during ' + funName + ': ' + e.message || e, { stackTrace: e.stack });\n                }\n                done(failReturnVal);\n            };\n            try {\n                const result = pluginObj[funName].apply(pluginObj, args);\n                if (webdriver.promise.isPromise(result)) {\n                    result.then(done, logError);\n                }\n                else {\n                    done(result);\n                }\n            }\n            catch (e) {\n                logError(e);\n            }\n        };\n        if (promiseType == PromiseType.Q) {\n            return q.Promise(resolver);\n        }\n        else if (ptor_1.protractor.browser.controlFlowIsEnabled()) {\n            return new webdriver.promise.Promise(resolver);\n        }\n        else {\n            return new Promise(resolver);\n        }\n    }\n    pluginFunFactory(funName, promiseType, failReturnVal) {\n        return (...args) => {\n            const promises = this.pluginObjs.filter(pluginObj => typeof pluginObj[funName] === 'function')\n                .map(pluginObj => this.safeCallPluginFun(pluginObj, funName, args, promiseType, failReturnVal));\n            return promiseType == PromiseType.Q ? q.all(promises) : webdriver.promise.all(promises);\n        };\n    }\n}\nexports.Plugins = Plugins;\n//# sourceMappingURL=plugins.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/taskRunner.js":"\"use strict\";\nconst child_process = require('child_process');\nconst events_1 = require('events');\nconst q = require('q');\nconst configParser_1 = require('./configParser');\nconst runner_1 = require('./runner');\nconst taskLogger_1 = require('./taskLogger');\n/**\n * A runner for running a specified task (capabilities + specs).\n * The TaskRunner can either run the task from the current process (via\n * './runner.js') or from a new process (via './runnerCli.js').\n *\n * @constructor\n * @param {string} configFile Path of test configuration.\n * @param {object} additionalConfig Additional configuration.\n * @param {object} task Task to run.\n * @param {boolean} runInFork Whether to run test in a forked process.\n * @constructor\n */\nclass TaskRunner extends events_1.EventEmitter {\n    constructor(configFile, additionalConfig, task, runInFork) {\n        super();\n        this.configFile = configFile;\n        this.additionalConfig = additionalConfig;\n        this.task = task;\n        this.runInFork = runInFork;\n    }\n    /**\n     * Sends the run command.\n     * @return {q.Promise} A promise that will resolve when the task finishes\n     *     running. The promise contains the following parameters representing the\n     *     result of the run:\n     *       taskId, specs, capabilities, failedCount, exitCode, specResults\n     */\n    run() {\n        let runResults = {\n            taskId: this.task.taskId,\n            specs: this.task.specs,\n            capabilities: this.task.capabilities,\n            // The following are populated while running the test:\n            failedCount: 0,\n            exitCode: -1,\n            specResults: []\n        };\n        let configParser = new configParser_1.ConfigParser();\n        if (this.configFile) {\n            configParser.addFileConfig(this.configFile);\n        }\n        if (this.additionalConfig) {\n            configParser.addConfig(this.additionalConfig);\n        }\n        let config = configParser.getConfig();\n        config.capabilities = this.task.capabilities;\n        config.specs = this.task.specs;\n        if (this.runInFork) {\n            let deferred = q.defer();\n            let childProcess = child_process.fork(__dirname + '/runnerCli.js', process.argv.slice(2), { cwd: process.cwd(), silent: true });\n            let taskLogger = new taskLogger_1.TaskLogger(this.task, childProcess.pid);\n            // stdout pipe\n            childProcess.stdout.on('data', (data) => {\n                taskLogger.log(data);\n            });\n            // stderr pipe\n            childProcess.stderr.on('data', (data) => {\n                taskLogger.log(data);\n            });\n            childProcess\n                .on('message', (m) => {\n                if (config.verboseMultiSessions) {\n                    taskLogger.peek();\n                }\n                switch (m.event) {\n                    case 'testPass':\n                        process.stdout.write('.');\n                        break;\n                    case 'testFail':\n                        process.stdout.write('F');\n                        break;\n                    case 'testsDone':\n                        runResults.failedCount = m.results.failedCount;\n                        runResults.specResults = m.results.specResults;\n                        break;\n                }\n            })\n                .on('error', (err) => {\n                taskLogger.flush();\n                deferred.reject(err);\n            })\n                .on('exit', (code) => {\n                taskLogger.flush();\n                runResults.exitCode = code;\n                deferred.resolve(runResults);\n            });\n            childProcess.send({\n                command: 'run',\n                configFile: this.configFile,\n                additionalConfig: this.additionalConfig,\n                capabilities: this.task.capabilities,\n                specs: this.task.specs\n            });\n            return deferred.promise;\n        }\n        else {\n            let runner = new runner_1.Runner(config);\n            runner.on('testsDone', (results) => {\n                runResults.failedCount = results.failedCount;\n                runResults.specResults = results.specResults;\n            });\n            return runner.run().then((exitCode) => {\n                runResults.exitCode = exitCode;\n                return runResults;\n            });\n        }\n    }\n}\nexports.TaskRunner = TaskRunner;\n//# sourceMappingURL=taskRunner.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/taskLogger.js":"\"use strict\";\nconst os = require('os');\nconst logger_1 = require('./logger');\nlet logger = new logger_1.Logger('testLogger');\nclass TaskLogger {\n    /**\n     * Log output such that metadata are appended.\n     * Calling log(data) will not flush to console until you call flush()\n     *\n     * @constructor\n     * @param {object} task Task that is being reported.\n     * @param {number} pid PID of process running the task.\n     */\n    constructor(task, pid) {\n        this.task = task;\n        this.pid = pid;\n        this.buffer = '';\n        this.insertTag = true;\n        this.logHeader_();\n    }\n    /**\n     * Log the header for the current task including information such as\n     * PID, browser name/version, task Id, specs being run.\n     *\n     * @private\n     */\n    logHeader_() {\n        let output = 'PID: ' + this.pid + os.EOL;\n        if (this.task.specs.length === 1) {\n            output += 'Specs: ' + this.task.specs.toString() + os.EOL + os.EOL;\n        }\n        this.log(output);\n    }\n    /**\n     * Prints the contents of the buffer without clearing it.\n     */\n    peek() {\n        if (this.buffer) {\n            // Flush buffer if nonempty\n            logger.info(os.EOL + '------------------------------------' + os.EOL);\n            logger.info(this.buffer);\n            logger.info(os.EOL);\n        }\n    }\n    /**\n     * Flushes the buffer to stdout.\n     */\n    flush() {\n        if (this.buffer) {\n            this.peek();\n            this.buffer = '';\n        }\n    }\n    /**\n     * Log the data in the argument such that metadata are appended.\n     * The data will be saved to a buffer until flush() is called.\n     *\n     * @param {string} data\n     */\n    log(data) {\n        let tag = '[';\n        let capabilities = this.task.capabilities;\n        tag += (capabilities.logName) ? capabilities.logName :\n            (capabilities.browserName) ? capabilities.browserName : '';\n        tag += (capabilities.version) ? (' ' + capabilities.version) : '';\n        tag += (capabilities.platform) ? (' ' + capabilities.platform) : '';\n        tag += (capabilities.logName && capabilities.count < 2) ? '' : ' #' + this.task.taskId;\n        tag += '] ';\n        data = data.toString();\n        for (let i = 0; i < data.length; i++) {\n            if (this.insertTag) {\n                this.insertTag = false;\n                // This ensures that the '\\x1B[0m' appears before the tag, so that\n                // data remains correct when color is not processed.\n                // See https://github.com/angular/protractor/pull/1216\n                if (data[i] === '\\x1B' && data.substring(i, i + 4) === '\\x1B[0m') {\n                    this.buffer += ('\\x1B[0m' + tag);\n                    i += 3;\n                    continue;\n                }\n                this.buffer += tag;\n            }\n            if (data[i] === '\\n') {\n                this.insertTag = true;\n            }\n            this.buffer += data[i];\n        }\n    }\n}\nexports.TaskLogger = TaskLogger;\n//# sourceMappingURL=taskLogger.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/taskScheduler.js":"\"use strict\";\nconst configParser_1 = require('./configParser');\n/**\n * The taskScheduler keeps track of the spec files that needs to run next\n * and which task is running what.\n */\nclass TaskQueue {\n    // A queue of specs for a particular capacity\n    constructor(capabilities, specLists) {\n        this.capabilities = capabilities;\n        this.specLists = specLists;\n        this.numRunningInstances = 0;\n        this.specsIndex = 0;\n        this.maxInstance = capabilities.maxInstances || 1;\n    }\n}\nexports.TaskQueue = TaskQueue;\nclass TaskScheduler {\n    /**\n     * A scheduler to keep track of specs that need running and their associated\n     * capabilities. It will suggest a task (combination of capabilities and spec)\n     * to run while observing the following config rules:\n     * multiCapabilities, shardTestFiles, and maxInstance.\n     * Precondition: multiCapabilities is a non-empty array\n     * (capabilities and getCapabilities will both be ignored)\n     *\n     * @constructor\n     * @param {Object} config parsed from the config file\n     */\n    constructor(config) {\n        this.config = config;\n        let excludes = configParser_1.ConfigParser.resolveFilePatterns(config.exclude, true, config.configDir);\n        let allSpecs = configParser_1.ConfigParser.resolveFilePatterns(configParser_1.ConfigParser.getSpecs(config), false, config.configDir)\n            .filter((path) => {\n            return excludes.indexOf(path) < 0;\n        });\n        let taskQueues = [];\n        config.multiCapabilities.forEach((capabilities) => {\n            let capabilitiesSpecs = allSpecs;\n            if (capabilities.specs) {\n                let capabilitiesSpecificSpecs = configParser_1.ConfigParser.resolveFilePatterns(capabilities.specs, false, config.configDir);\n                capabilitiesSpecs = capabilitiesSpecs.concat(capabilitiesSpecificSpecs);\n            }\n            if (capabilities.exclude) {\n                let capabilitiesSpecExcludes = configParser_1.ConfigParser.resolveFilePatterns(capabilities.exclude, true, config.configDir);\n                capabilitiesSpecs = capabilitiesSpecs.filter((path) => {\n                    return capabilitiesSpecExcludes.indexOf(path) < 0;\n                });\n            }\n            let specLists = [];\n            // If we shard, we return an array of one element arrays, each containing\n            // the spec file. If we don't shard, we return an one element array\n            // containing an array of all the spec files\n            if (capabilities.shardTestFiles) {\n                capabilitiesSpecs.forEach((spec) => {\n                    specLists.push([spec]);\n                });\n            }\n            else {\n                specLists.push(capabilitiesSpecs);\n            }\n            capabilities.count = capabilities.count || 1;\n            for (let i = 0; i < capabilities.count; ++i) {\n                taskQueues.push(new TaskQueue(capabilities, specLists));\n            }\n        });\n        this.taskQueues = taskQueues;\n        this.rotationIndex = 0; // Helps suggestions to rotate amongst capabilities\n    }\n    /**\n     * Get the next task that is allowed to run without going over maxInstance.\n     *\n     * @return {{capabilities: Object, specs: Array.<string>, taskId: string,\n     * done: function()}}\n     */\n    nextTask() {\n        for (let i = 0; i < this.taskQueues.length; ++i) {\n            let rotatedIndex = ((i + this.rotationIndex) % this.taskQueues.length);\n            let queue = this.taskQueues[rotatedIndex];\n            if (queue.numRunningInstances < queue.maxInstance &&\n                queue.specsIndex < queue.specLists.length) {\n                this.rotationIndex = rotatedIndex + 1;\n                ++queue.numRunningInstances;\n                let taskId = '' + rotatedIndex + 1;\n                if (queue.specLists.length > 1) {\n                    taskId += '-' + queue.specsIndex;\n                }\n                let specs = queue.specLists[queue.specsIndex];\n                ++queue.specsIndex;\n                return {\n                    capabilities: queue.capabilities,\n                    specs: specs,\n                    taskId: taskId,\n                    done: function () {\n                        --queue.numRunningInstances;\n                    }\n                };\n            }\n        }\n        return null;\n    }\n    /**\n     * Get the number of tasks left to run or are currently running.\n     *\n     * @return {number}\n     */\n    numTasksOutstanding() {\n        let count = 0;\n        this.taskQueues.forEach((queue) => {\n            count += queue.numRunningInstances + (queue.specLists.length - queue.specsIndex);\n        });\n        return count;\n    }\n    /**\n     * Get maximum number of concurrent tasks required/permitted.\n     *\n     * @return {number}\n     */\n    maxConcurrentTasks() {\n        if (this.config.maxSessions && this.config.maxSessions > 0) {\n            return this.config.maxSessions;\n        }\n        else {\n            let count = 0;\n            this.taskQueues.forEach((queue) => {\n                count += Math.min(queue.maxInstance, queue.specLists.length);\n            });\n            return count;\n        }\n    }\n    /**\n     * Returns number of tasks currently running.\n     *\n     * @return {number}\n     */\n    countActiveTasks() {\n        let count = 0;\n        this.taskQueues.forEach((queue) => {\n            count += queue.numRunningInstances;\n        });\n        return count;\n    }\n}\nexports.TaskScheduler = TaskScheduler;\n//# sourceMappingURL=taskScheduler.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/built/runnerCli.js":"/**\n * This serves as the main function for starting a test run that has been\n * requested by the launcher.\n */\n\"use strict\";\nconst configParser_1 = require('./configParser');\nconst logger_1 = require('./logger');\nconst runner_1 = require('./runner');\nlet logger = new logger_1.Logger('runnerCli');\nprocess.on('message', (m) => {\n    switch (m.command) {\n        case 'run':\n            if (!m.capabilities) {\n                throw new Error('Run message missing capabilities');\n            }\n            // Merge in config file options.\n            let configParser = new configParser_1.ConfigParser();\n            if (m.configFile) {\n                configParser.addFileConfig(m.configFile);\n            }\n            if (m.additionalConfig) {\n                configParser.addConfig(m.additionalConfig);\n            }\n            let config = configParser.getConfig();\n            logger_1.Logger.set(config);\n            // Grab capabilities to run from launcher.\n            config.capabilities = m.capabilities;\n            // Get specs to be executed by this runner\n            config.specs = m.specs;\n            // Launch test run.\n            let runner = new runner_1.Runner(config);\n            // Pipe events back to the launcher.\n            runner.on('testPass', () => {\n                process.send({ event: 'testPass' });\n            });\n            runner.on('testFail', () => {\n                process.send({ event: 'testFail' });\n            });\n            runner.on('testsDone', (results) => {\n                process.send({ event: 'testsDone', results: results });\n            });\n            runner.run()\n                .then((exitCode) => {\n                process.exit(exitCode);\n            })\n                .catch((err) => {\n                logger.info(err.message);\n                process.exit(1);\n            });\n            break;\n        default:\n            throw new Error('command ' + m.command + ' is invalid');\n    }\n});\n//# sourceMappingURL=runnerCli.js.map","/home/travis/build/npmtest/node-npmtest-protractor/node_modules/protractor/gulpfile.js":"'use strict';\n\nvar gulp = require('gulp');\nvar clangFormat = require('clang-format');\nvar gulpFormat = require('gulp-clang-format');\nvar runSequence = require('run-sequence');\nvar spawn = require('child_process').spawn;\nvar spawnSync = require('child_process').spawnSync;\nvar tslint = require('gulp-tslint');\nvar fs = require('fs');\nvar path = require('path');\nvar glob = require('glob');\nvar semver = require('semver');\n\nvar runSpawn = function(done, task, opt_arg, opt_io) {\n  opt_arg = typeof opt_arg !== 'undefined' ? opt_arg : [];\n  var stdio = 'inherit';\n  if (opt_io === 'ignore') {\n    stdio = 'ignore';\n  }\n  var child = spawn(task, opt_arg, {stdio: stdio});\n  var running = false;\n  child.on('close', function() {\n    if (!running) {\n      running = true;\n      done();\n    }\n  });\n  child.on('error', function() {\n    if (!running) {\n      console.error('gulp encountered a child error');\n      running = true;\n      done();\n    }\n  });\n};\n\ngulp.task('tslint', function() {\n  return gulp.src(['lib/**/*.ts', 'spec/**/*.ts', '!spec/install/**/*.ts'])\n      .pipe(tslint()).pipe(tslint.report());\n});\n\ngulp.task('lint', function(done) {\n  runSequence('tslint', 'jshint', 'format:enforce', done);\n});\n\n// prevent contributors from using the wrong version of node\ngulp.task('checkVersion', function(done) {\n  // read minimum node on package.json\n  var packageJson = JSON.parse(fs.readFileSync(path.resolve('package.json')));\n  var protractorVersion = packageJson.version;\n  var nodeVersion = packageJson.engines.node;\n\n  if (semver.satisfies(process.version, nodeVersion)) {\n    done();\n  } else {\n    throw new Error('minimum node version for Protractor ' +\n        protractorVersion + ' is node ' + nodeVersion);\n  }\n});\n\ngulp.task('built:copy', function(done) {\n  return gulp.src(['lib/**/*.js'])\n      .pipe(gulp.dest('built/'));\n  done();\n});\n\ngulp.task('webdriver:update', function(done) {\n  runSpawn(done, 'node', ['bin/webdriver-manager', 'update']);\n});\n\ngulp.task('jshint', function(done) {\n  runSpawn(done, 'node', ['node_modules/jshint/bin/jshint', '-c',\n      '.jshintrc', 'lib', 'spec', 'scripts',\n      '--exclude=lib/selenium-webdriver/**/*.js,lib/webdriver-js-extender/**/*.js,' +\n      'spec/dependencyTest/*.js,spec/install/**/*.js']);\n});\n\ngulp.task('format:enforce', function() {\n  var format = require('gulp-clang-format');\n  var clangFormat = require('clang-format');\n  return gulp.src(['lib/**/*.ts']).pipe(\n    format.checkFormat('file', clangFormat, {verbose: true, fail: true}));\n});\n\ngulp.task('format', function() {\n  var format = require('gulp-clang-format');\n  var clangFormat = require('clang-format');\n  return gulp.src(['lib/**/*.ts'], { base: '.' }).pipe(\n    format.format('file', clangFormat)).pipe(gulp.dest('.'));\n});\n\ngulp.task('tsc', function(done) {\n  runSpawn(done, 'node', ['node_modules/typescript/bin/tsc']);\n});\n\n\ngulp.task('prepublish', function(done) {\n  runSequence('checkVersion', 'jshint', 'tsc', 'built:copy', done);\n});\n\ngulp.task('pretest', function(done) {\n  runSequence('checkVersion',\n    ['webdriver:update', 'jshint', 'tslint', 'format'], 'tsc', 'built:copy', done);\n});\n\ngulp.task('default',['prepublish']);\n"}